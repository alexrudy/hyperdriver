pub mod hyperdriver
pub mod hyperdriver::body
pub struct hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::new() -> Self
impl<BIn, BOut, S> tower_layer::Layer<S> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Service = hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::layer(&self, inner: S) -> Self::Service
impl<BIn, BOut> core::default::Default for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::default() -> Self
impl<BIn: core::clone::Clone, BOut: core::clone::Clone> core::clone::Clone for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::clone(&self) -> hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn: core::fmt::Debug, BOut: core::fmt::Debug> core::fmt::Debug for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<BIn, BOut> core::marker::Freeze for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::marker::Send for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::marker::Sync for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::marker::Unpin for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::panic::unwind_safe::UnwindSafe for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where U: core::convert::From<T>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where U: core::convert::Into<T>
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Error = core::convert::Infallible
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where U: core::convert::TryFrom<T>
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::clone::Clone
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Owned = T
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::clone_into(&self, target: &mut T)
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::clone::Clone
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: 'static + core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::clone::Clone
pub unsafe fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub struct hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
impl<S, BIn, BOut> hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::new(inner: S) -> Self
impl<S: core::clone::Clone, BIn, BOut> core::clone::Clone for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::clone(&self) -> Self
impl<S: core::default::Default, BIn, BOut> core::default::Default for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::default() -> Self
impl<S: core::fmt::Debug, BIn, BOut> core::fmt::Debug for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T, BIn, BOut> tower_service::Service<http::request::Request<hyper::body::incoming::Incoming>> for hyperdriver::body::AdaptIncomingService<T, BIn, BOut> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BIn: core::convert::From<hyper::body::incoming::Incoming>
pub type hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::Response = http::response::Response<BOut>
pub fn hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::call(&mut self, req: http::request::Request<hyper::body::incoming::Incoming>) -> Self::Future
pub fn hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S, BIn, BOut> core::marker::Freeze for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Freeze
impl<S, BIn, BOut> core::marker::Send for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Send
impl<S, BIn, BOut> core::marker::Sync for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Sync
impl<S, BIn, BOut> core::marker::Unpin for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Unpin
impl<S, BIn, BOut> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::panic::unwind_safe::RefUnwindSafe
impl<S, BIn, BOut> core::panic::unwind_safe::UnwindSafe for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: tower_service::Service<R>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::ResBody = BOut
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where U: core::convert::From<T>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where U: core::convert::Into<T>
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Error = core::convert::Infallible
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where U: core::convert::TryFrom<T>
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::clone::Clone
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Owned = T
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::clone_into(&self, target: &mut T)
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::clone::Clone
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: 'static + core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::clone::Clone
pub unsafe fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub struct hyperdriver::body::Body
impl hyperdriver::body::Body
pub fn hyperdriver::body::Body::as_boxed(self) -> http_body_util::combinators::box_body::UnsyncBoxBody<bytes::bytes::Bytes, alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send + 'static)>>
pub fn hyperdriver::body::Body::empty() -> Self
pub fn hyperdriver::body::Body::full<D>(data: D) -> Self where D: core::convert::Into<bytes::bytes::Bytes>
pub fn hyperdriver::body::Body::try_clone(&self) -> core::option::Option<Self>
impl core::convert::From<&'static str> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(body: &'static str) -> Self
impl core::convert::From<alloc::string::String> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(body: alloc::string::String) -> Self
impl core::convert::From<alloc::vec::Vec<u8>> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(body: alloc::vec::Vec<u8>) -> Self
impl core::convert::From<axum_core::body::Body> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(body: axum_core::body::Body) -> Self
impl core::convert::From<bytes::bytes::Bytes> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(body: bytes::bytes::Bytes) -> Self
impl core::convert::From<http_body_util::empty::Empty<bytes::bytes::Bytes>> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(_body: http_body_util::empty::Empty<bytes::bytes::Bytes>) -> Self
impl core::convert::From<http_body_util::full::Full<bytes::bytes::Bytes>> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(body: http_body_util::full::Full<bytes::bytes::Bytes>) -> Self
impl core::convert::From<hyper::body::incoming::Incoming> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(body: hyper::body::incoming::Incoming) -> Self
impl core::convert::From<hyperdriver::body::Body> for axum_core::body::Body
pub fn axum_core::body::Body::from(body: hyperdriver::body::Body) -> Self
impl core::default::Default for hyperdriver::body::Body
pub fn hyperdriver::body::Body::default() -> Self
impl core::fmt::Debug for hyperdriver::body::Body
pub fn hyperdriver::body::Body::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl http_body::Body for hyperdriver::body::Body
pub type hyperdriver::body::Body::Data = bytes::bytes::Bytes
pub type hyperdriver::body::Body::Error = alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>
pub fn hyperdriver::body::Body::is_end_stream(&self) -> bool
pub fn hyperdriver::body::Body::poll_frame(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::option::Option<core::result::Result<http_body::frame::Frame<Self::Data>, Self::Error>>>
pub fn hyperdriver::body::Body::size_hint(&self) -> http_body::size_hint::SizeHint
impl hyperdriver::client::conn::connection::Connection<hyperdriver::body::Body> for hyperdriver::client::conn::protocol::mock::MockSender
pub type hyperdriver::client::conn::protocol::mock::MockSender::Error = hyperdriver::client::conn::protocol::mock::MockProtocolError
pub type hyperdriver::client::conn::protocol::mock::MockSender::Future = core::future::ready::Ready<core::result::Result<http::response::Response<hyperdriver::body::Body>, <hyperdriver::client::conn::protocol::mock::MockSender as hyperdriver::client::conn::connection::Connection<hyperdriver::body::Body>>::Error>>
pub type hyperdriver::client::conn::protocol::mock::MockSender::ResBody = hyperdriver::body::Body
pub fn hyperdriver::client::conn::protocol::mock::MockSender::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
pub fn hyperdriver::client::conn::protocol::mock::MockSender::send_request(&mut self, request: http::request::Request<hyperdriver::body::Body>) -> Self::Future
pub fn hyperdriver::client::conn::protocol::mock::MockSender::version(&self) -> http::version::Version
impl<'pin> core::marker::Unpin for hyperdriver::body::Body where __Body<'pin>: core::marker::Unpin
impl !core::marker::Freeze for hyperdriver::body::Body
impl core::marker::Send for hyperdriver::body::Body
impl !core::marker::Sync for hyperdriver::body::Body
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::body::Body
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::body::Body
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::body::Body where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::body::Body where U: core::convert::From<T>
pub fn hyperdriver::body::Body::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::body::Body where U: core::convert::Into<T>
pub type hyperdriver::body::Body::Error = core::convert::Infallible
pub fn hyperdriver::body::Body::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::body::Body where U: core::convert::TryFrom<T>
pub type hyperdriver::body::Body::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::body::Body::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::body::Body where T: 'static + core::marker::Sized
pub fn hyperdriver::body::Body::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::body::Body where T: core::marker::Sized
pub fn hyperdriver::body::Body::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::body::Body where T: core::marker::Sized
pub fn hyperdriver::body::Body::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(t: T) -> T
impl<T> http_body_util::BodyExt for hyperdriver::body::Body where T: http_body::Body + core::marker::Sized
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::body::Body where T: core::marker::Sized
pub fn hyperdriver::body::Body::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::body::Body::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::body::Body
impl<T> tracing::instrument::WithSubscriber for hyperdriver::body::Body
pub struct hyperdriver::body::IncomingRequestLayer<BIn, BOut>
impl<BIn, BOut> hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::new() -> Self
impl<BIn, BOut, S> tower_layer::Layer<S> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Service = hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::layer(&self, inner: S) -> Self::Service
impl<BIn, BOut> core::default::Default for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::default() -> Self
impl<BIn: core::clone::Clone, BOut: core::clone::Clone> core::clone::Clone for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::clone(&self) -> hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn: core::fmt::Debug, BOut: core::fmt::Debug> core::fmt::Debug for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<BIn, BOut> core::marker::Freeze for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::marker::Send for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::marker::Sync for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::marker::Unpin for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::panic::unwind_safe::UnwindSafe for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where U: core::convert::From<T>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where U: core::convert::Into<T>
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Error = core::convert::Infallible
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where U: core::convert::TryFrom<T>
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::clone::Clone
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Owned = T
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::clone_into(&self, target: &mut T)
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::clone::Clone
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: 'static + core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::clone::Clone
pub unsafe fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub struct hyperdriver::body::IncomingRequestService<S, BIn, BOut>
impl<S, BIn, BOut> hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::new(inner: S) -> Self
impl<S: core::clone::Clone, BIn, BOut> core::clone::Clone for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::clone(&self) -> Self
impl<S: core::default::Default, BIn, BOut> core::default::Default for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::default() -> Self
impl<S: core::fmt::Debug, BIn, BOut> core::fmt::Debug for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T, BIn, BOut> tower_service::Service<http::request::Request<hyper::body::incoming::Incoming>> for hyperdriver::body::AdaptIncomingService<T, BIn, BOut> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BIn: core::convert::From<hyper::body::incoming::Incoming>
pub type hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::Response = http::response::Response<BOut>
pub fn hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::call(&mut self, req: http::request::Request<hyper::body::incoming::Incoming>) -> Self::Future
pub fn hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S, BIn, BOut> core::marker::Freeze for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Freeze
impl<S, BIn, BOut> core::marker::Send for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Send
impl<S, BIn, BOut> core::marker::Sync for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Sync
impl<S, BIn, BOut> core::marker::Unpin for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Unpin
impl<S, BIn, BOut> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::panic::unwind_safe::RefUnwindSafe
impl<S, BIn, BOut> core::panic::unwind_safe::UnwindSafe for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: tower_service::Service<R>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::ResBody = BOut
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where U: core::convert::From<T>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where U: core::convert::Into<T>
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Error = core::convert::Infallible
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where U: core::convert::TryFrom<T>
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::clone::Clone
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Owned = T
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::clone_into(&self, target: &mut T)
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::clone::Clone
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: 'static + core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::clone::Clone
pub unsafe fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub mod hyperdriver::bridge
pub mod hyperdriver::bridge::io
pub struct hyperdriver::bridge::io::TokioIo<T>
impl<T> hyperdriver::bridge::io::TokioIo<T>
pub fn hyperdriver::bridge::io::TokioIo<T>::into_inner(self) -> T
pub fn hyperdriver::bridge::io::TokioIo<T>::new(inner: T) -> Self
impl<'pin, T> core::marker::Unpin for hyperdriver::bridge::io::TokioIo<T> where __TokioIo<'pin, T>: core::marker::Unpin
impl<T: core::fmt::Debug> core::fmt::Debug for hyperdriver::bridge::io::TokioIo<T>
pub fn hyperdriver::bridge::io::TokioIo<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T> core::ops::deref::Deref for hyperdriver::bridge::io::TokioIo<T>
pub type hyperdriver::bridge::io::TokioIo<T>::Target = T
pub fn hyperdriver::bridge::io::TokioIo<T>::deref(&self) -> &Self::Target
impl<T> core::ops::deref::DerefMut for hyperdriver::bridge::io::TokioIo<T>
pub fn hyperdriver::bridge::io::TokioIo<T>::deref_mut(&mut self) -> &mut Self::Target
impl<T> hyper::rt::io::Read for hyperdriver::bridge::io::TokioIo<T> where T: tokio::io::async_read::AsyncRead
pub fn hyperdriver::bridge::io::TokioIo<T>::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: hyper::rt::io::ReadBufCursor<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
impl<T> hyper::rt::io::Write for hyperdriver::bridge::io::TokioIo<T> where T: tokio::io::async_write::AsyncWrite
pub fn hyperdriver::bridge::io::TokioIo<T>::is_write_vectored(&self) -> bool
pub fn hyperdriver::bridge::io::TokioIo<T>::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::bridge::io::TokioIo<T>::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::bridge::io::TokioIo<T>::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
pub fn hyperdriver::bridge::io::TokioIo<T>::poll_write_vectored(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, bufs: &[std::io::IoSlice<'_>]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
impl<T> tokio::io::async_read::AsyncRead for hyperdriver::bridge::io::TokioIo<T> where T: hyper::rt::io::Read
pub fn hyperdriver::bridge::io::TokioIo<T>::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, tbuf: &mut tokio::io::read_buf::ReadBuf<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
impl<T> tokio::io::async_write::AsyncWrite for hyperdriver::bridge::io::TokioIo<T> where T: hyper::rt::io::Write
pub fn hyperdriver::bridge::io::TokioIo<T>::is_write_vectored(&self) -> bool
pub fn hyperdriver::bridge::io::TokioIo<T>::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::bridge::io::TokioIo<T>::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::bridge::io::TokioIo<T>::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
pub fn hyperdriver::bridge::io::TokioIo<T>::poll_write_vectored(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, bufs: &[std::io::IoSlice<'_>]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
impl<T> core::marker::Freeze for hyperdriver::bridge::io::TokioIo<T> where T: core::marker::Freeze
impl<T> core::marker::Send for hyperdriver::bridge::io::TokioIo<T> where T: core::marker::Send
impl<T> core::marker::Sync for hyperdriver::bridge::io::TokioIo<T> where T: core::marker::Sync
impl<T> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::bridge::io::TokioIo<T> where T: core::panic::unwind_safe::RefUnwindSafe
impl<T> core::panic::unwind_safe::UnwindSafe for hyperdriver::bridge::io::TokioIo<T> where T: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::bridge::io::TokioIo<T> where B: http_body::Body
impl<R> tokio::io::util::async_read_ext::AsyncReadExt for hyperdriver::bridge::io::TokioIo<T> where R: tokio::io::async_read::AsyncRead + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::bridge::io::TokioIo<T> where U: core::convert::From<T>
pub fn hyperdriver::bridge::io::TokioIo<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::bridge::io::TokioIo<T> where U: core::convert::Into<T>
pub type hyperdriver::bridge::io::TokioIo<T>::Error = core::convert::Infallible
pub fn hyperdriver::bridge::io::TokioIo<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::bridge::io::TokioIo<T> where U: core::convert::TryFrom<T>
pub type hyperdriver::bridge::io::TokioIo<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::bridge::io::TokioIo<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::bridge::io::TokioIo<T> where T: 'static + core::marker::Sized
pub fn hyperdriver::bridge::io::TokioIo<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::bridge::io::TokioIo<T> where T: core::marker::Sized
pub fn hyperdriver::bridge::io::TokioIo<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::bridge::io::TokioIo<T> where T: core::marker::Sized
pub fn hyperdriver::bridge::io::TokioIo<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::bridge::io::TokioIo<T>
pub fn hyperdriver::bridge::io::TokioIo<T>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::bridge::io::TokioIo<T> where T: core::marker::Sized
pub fn hyperdriver::bridge::io::TokioIo<T>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::bridge::io::TokioIo<T>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::bridge::io::TokioIo<T>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::bridge::io::TokioIo<T>
impl<W> tokio::io::util::async_write_ext::AsyncWriteExt for hyperdriver::bridge::io::TokioIo<T> where W: tokio::io::async_write::AsyncWrite + core::marker::Sized
pub mod hyperdriver::bridge::rt
pub struct hyperdriver::bridge::rt::TokioCurrentThreadExecutor
impl hyperdriver::bridge::rt::TokioCurrentThreadExecutor
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::new() -> Self
impl core::clone::Clone for hyperdriver::bridge::rt::TokioCurrentThreadExecutor
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::clone(&self) -> hyperdriver::bridge::rt::TokioCurrentThreadExecutor
impl core::default::Default for hyperdriver::bridge::rt::TokioCurrentThreadExecutor
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::default() -> hyperdriver::bridge::rt::TokioCurrentThreadExecutor
impl core::fmt::Debug for hyperdriver::bridge::rt::TokioCurrentThreadExecutor
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for hyperdriver::bridge::rt::TokioCurrentThreadExecutor
impl<F> hyper::rt::Executor<F> for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where F: core::future::future::Future + 'static, <F as core::future::future::Future>::Output: 'static
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::execute(&self, future: F)
impl core::marker::Freeze for hyperdriver::bridge::rt::TokioCurrentThreadExecutor
impl core::marker::Send for hyperdriver::bridge::rt::TokioCurrentThreadExecutor
impl core::marker::Sync for hyperdriver::bridge::rt::TokioCurrentThreadExecutor
impl core::marker::Unpin for hyperdriver::bridge::rt::TokioCurrentThreadExecutor
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::bridge::rt::TokioCurrentThreadExecutor
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::bridge::rt::TokioCurrentThreadExecutor
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where B: http_body::Body
impl<E, B, T> hyper::rt::bounds::h2_client::Http2ClientConnExec<B, T> for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where E: hyper::rt::Executor<hyper::proto::h2::client::H2ClientFuture<B, T>>, B: http_body::Body + 'static, <B as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>, hyper::proto::h2::client::H2ClientFuture<B, T>: core::future::future::Future<Output = ()>, T: hyper::rt::io::Read + hyper::rt::io::Write + core::marker::Unpin
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::execute_h2_future(&mut self, future: hyper::proto::h2::client::H2ClientFuture<B, T>)
impl<E, F, B> hyper::rt::bounds::h2::Http2ServerConnExec<F, B> for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where E: hyper::rt::Executor<hyper::proto::h2::server::H2Stream<F, B>> + core::clone::Clone, hyper::proto::h2::server::H2Stream<F, B>: core::future::future::Future<Output = ()>, B: http_body::Body
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::execute_h2stream(&mut self, fut: hyper::proto::h2::server::H2Stream<F, B>)
impl<P, S, A, B, E> hyperdriver::server::GracefulServerExecutor<P, S, A, B> for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where P: hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Service, <A as hyperdriver::server::Accept>::Conn, B>, S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept, E: hyperdriver::server::ServerExecutor<P, S, A, B> + hyper::rt::Executor<GracefulConnectionDriver<tracing::instrument::Instrumented<<P as hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Service, <A as hyperdriver::server::Accept>::Conn, B>>::Connection>, <P as hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Service, <A as hyperdriver::server::Accept>::Conn, B>>::Error>> + Sealed<(P, S, A, B, ())>
impl<P, S, A, B, E> hyperdriver::server::ServerExecutor<P, S, A, B> for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where P: hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Service, <A as hyperdriver::server::Accept>::Conn, B>, S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept, E: hyper::rt::Executor<ConnectionDriver<tracing::instrument::Instrumented<<P as hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Service, <A as hyperdriver::server::Accept>::Conn, B>>::Connection>, <P as hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Service, <A as hyperdriver::server::Accept>::Conn, B>>::Error>>
impl<T, U> core::convert::Into<U> for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where U: core::convert::From<T>
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where U: core::convert::Into<T>
pub type hyperdriver::bridge::rt::TokioCurrentThreadExecutor::Error = core::convert::Infallible
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where U: core::convert::TryFrom<T>
pub type hyperdriver::bridge::rt::TokioCurrentThreadExecutor::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where T: core::clone::Clone
pub type hyperdriver::bridge::rt::TokioCurrentThreadExecutor::Owned = T
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::clone_into(&self, target: &mut T)
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where T: core::clone::Clone
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where T: 'static + core::marker::Sized
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where T: core::marker::Sized
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where T: core::marker::Sized
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where T: core::clone::Clone
pub unsafe fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::bridge::rt::TokioCurrentThreadExecutor
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::bridge::rt::TokioCurrentThreadExecutor where T: core::marker::Sized
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::bridge::rt::TokioCurrentThreadExecutor::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::bridge::rt::TokioCurrentThreadExecutor
impl<T> tracing::instrument::WithSubscriber for hyperdriver::bridge::rt::TokioCurrentThreadExecutor
pub struct hyperdriver::bridge::rt::TokioExecutor
impl hyperdriver::bridge::rt::TokioExecutor
pub fn hyperdriver::bridge::rt::TokioExecutor::new() -> Self
impl core::clone::Clone for hyperdriver::bridge::rt::TokioExecutor
pub fn hyperdriver::bridge::rt::TokioExecutor::clone(&self) -> hyperdriver::bridge::rt::TokioExecutor
impl core::default::Default for hyperdriver::bridge::rt::TokioExecutor
pub fn hyperdriver::bridge::rt::TokioExecutor::default() -> hyperdriver::bridge::rt::TokioExecutor
impl core::fmt::Debug for hyperdriver::bridge::rt::TokioExecutor
pub fn hyperdriver::bridge::rt::TokioExecutor::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for hyperdriver::bridge::rt::TokioExecutor
impl<F> hyper::rt::Executor<F> for hyperdriver::bridge::rt::TokioExecutor where F: core::future::future::Future + core::marker::Send + 'static, <F as core::future::future::Future>::Output: core::marker::Send + 'static
pub fn hyperdriver::bridge::rt::TokioExecutor::execute(&self, future: F)
impl core::marker::Freeze for hyperdriver::bridge::rt::TokioExecutor
impl core::marker::Send for hyperdriver::bridge::rt::TokioExecutor
impl core::marker::Sync for hyperdriver::bridge::rt::TokioExecutor
impl core::marker::Unpin for hyperdriver::bridge::rt::TokioExecutor
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::bridge::rt::TokioExecutor
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::bridge::rt::TokioExecutor
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::bridge::rt::TokioExecutor where B: http_body::Body
impl<E, B, T> hyper::rt::bounds::h2_client::Http2ClientConnExec<B, T> for hyperdriver::bridge::rt::TokioExecutor where E: hyper::rt::Executor<hyper::proto::h2::client::H2ClientFuture<B, T>>, B: http_body::Body + 'static, <B as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>, hyper::proto::h2::client::H2ClientFuture<B, T>: core::future::future::Future<Output = ()>, T: hyper::rt::io::Read + hyper::rt::io::Write + core::marker::Unpin
pub fn hyperdriver::bridge::rt::TokioExecutor::execute_h2_future(&mut self, future: hyper::proto::h2::client::H2ClientFuture<B, T>)
impl<E, F, B> hyper::rt::bounds::h2::Http2ServerConnExec<F, B> for hyperdriver::bridge::rt::TokioExecutor where E: hyper::rt::Executor<hyper::proto::h2::server::H2Stream<F, B>> + core::clone::Clone, hyper::proto::h2::server::H2Stream<F, B>: core::future::future::Future<Output = ()>, B: http_body::Body
pub fn hyperdriver::bridge::rt::TokioExecutor::execute_h2stream(&mut self, fut: hyper::proto::h2::server::H2Stream<F, B>)
impl<P, S, A, B, E> hyperdriver::server::GracefulServerExecutor<P, S, A, B> for hyperdriver::bridge::rt::TokioExecutor where P: hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Service, <A as hyperdriver::server::Accept>::Conn, B>, S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept, E: hyperdriver::server::ServerExecutor<P, S, A, B> + hyper::rt::Executor<GracefulConnectionDriver<tracing::instrument::Instrumented<<P as hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Service, <A as hyperdriver::server::Accept>::Conn, B>>::Connection>, <P as hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Service, <A as hyperdriver::server::Accept>::Conn, B>>::Error>> + Sealed<(P, S, A, B, ())>
impl<P, S, A, B, E> hyperdriver::server::ServerExecutor<P, S, A, B> for hyperdriver::bridge::rt::TokioExecutor where P: hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Service, <A as hyperdriver::server::Accept>::Conn, B>, S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept, E: hyper::rt::Executor<ConnectionDriver<tracing::instrument::Instrumented<<P as hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Service, <A as hyperdriver::server::Accept>::Conn, B>>::Connection>, <P as hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Service, <A as hyperdriver::server::Accept>::Conn, B>>::Error>>
impl<T, U> core::convert::Into<U> for hyperdriver::bridge::rt::TokioExecutor where U: core::convert::From<T>
pub fn hyperdriver::bridge::rt::TokioExecutor::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::bridge::rt::TokioExecutor where U: core::convert::Into<T>
pub type hyperdriver::bridge::rt::TokioExecutor::Error = core::convert::Infallible
pub fn hyperdriver::bridge::rt::TokioExecutor::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::bridge::rt::TokioExecutor where U: core::convert::TryFrom<T>
pub type hyperdriver::bridge::rt::TokioExecutor::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::bridge::rt::TokioExecutor::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::bridge::rt::TokioExecutor where T: core::clone::Clone
pub type hyperdriver::bridge::rt::TokioExecutor::Owned = T
pub fn hyperdriver::bridge::rt::TokioExecutor::clone_into(&self, target: &mut T)
pub fn hyperdriver::bridge::rt::TokioExecutor::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::bridge::rt::TokioExecutor where T: core::clone::Clone
pub fn hyperdriver::bridge::rt::TokioExecutor::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::bridge::rt::TokioExecutor where T: 'static + core::marker::Sized
pub fn hyperdriver::bridge::rt::TokioExecutor::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::bridge::rt::TokioExecutor where T: core::marker::Sized
pub fn hyperdriver::bridge::rt::TokioExecutor::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::bridge::rt::TokioExecutor where T: core::marker::Sized
pub fn hyperdriver::bridge::rt::TokioExecutor::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::bridge::rt::TokioExecutor where T: core::clone::Clone
pub unsafe fn hyperdriver::bridge::rt::TokioExecutor::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::bridge::rt::TokioExecutor
pub fn hyperdriver::bridge::rt::TokioExecutor::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::bridge::rt::TokioExecutor where T: core::marker::Sized
pub fn hyperdriver::bridge::rt::TokioExecutor::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::bridge::rt::TokioExecutor::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::bridge::rt::TokioExecutor
impl<T> tracing::instrument::WithSubscriber for hyperdriver::bridge::rt::TokioExecutor
pub mod hyperdriver::bridge::service
pub struct hyperdriver::bridge::service::TowerHyperFuture<S, R> where S: tower_service::Service<R>
impl<'pin, S, R> core::marker::Unpin for hyperdriver::bridge::service::TowerHyperFuture<S, R> where S: tower_service::Service<R>, __TowerHyperFuture<'pin, S, R>: core::marker::Unpin
impl<S, R: core::fmt::Debug> core::fmt::Debug for hyperdriver::bridge::service::TowerHyperFuture<S, R> where S: tower_service::Service<R> + core::fmt::Debug
pub fn hyperdriver::bridge::service::TowerHyperFuture<S, R>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S, R> core::future::future::Future for hyperdriver::bridge::service::TowerHyperFuture<S, R> where S: tower_service::Service<R>
pub type hyperdriver::bridge::service::TowerHyperFuture<S, R>::Output = core::result::Result<<S as tower_service::Service<R>>::Response, <S as tower_service::Service<R>>::Error>
pub fn hyperdriver::bridge::service::TowerHyperFuture<S, R>::poll(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<Self::Output>
impl<S, R> core::marker::Freeze for hyperdriver::bridge::service::TowerHyperFuture<S, R> where S: core::marker::Freeze, <S as tower_service::Service<R>>::Future: core::marker::Freeze, R: core::marker::Freeze
impl<S, R> core::marker::Send for hyperdriver::bridge::service::TowerHyperFuture<S, R> where S: core::marker::Send, <S as tower_service::Service<R>>::Future: core::marker::Send, R: core::marker::Send
impl<S, R> core::marker::Sync for hyperdriver::bridge::service::TowerHyperFuture<S, R> where S: core::marker::Sync, <S as tower_service::Service<R>>::Future: core::marker::Sync, R: core::marker::Sync
impl<S, R> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::bridge::service::TowerHyperFuture<S, R> where S: core::panic::unwind_safe::RefUnwindSafe, <S as tower_service::Service<R>>::Future: core::panic::unwind_safe::RefUnwindSafe, R: core::panic::unwind_safe::RefUnwindSafe
impl<S, R> core::panic::unwind_safe::UnwindSafe for hyperdriver::bridge::service::TowerHyperFuture<S, R> where S: core::panic::unwind_safe::UnwindSafe, <S as tower_service::Service<R>>::Future: core::panic::unwind_safe::UnwindSafe, R: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::bridge::service::TowerHyperFuture<S, R> where B: http_body::Body
impl<F, T, E> futures_core::future::TryFuture for hyperdriver::bridge::service::TowerHyperFuture<S, R> where F: core::future::future::Future<Output = core::result::Result<T, E>> + core::marker::Sized
pub type hyperdriver::bridge::service::TowerHyperFuture<S, R>::Error = E
pub type hyperdriver::bridge::service::TowerHyperFuture<S, R>::Ok = T
pub fn hyperdriver::bridge::service::TowerHyperFuture<S, R>::try_poll(self: core::pin::Pin<&mut F>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<<F as core::future::future::Future>::Output>
impl<F> core::future::into_future::IntoFuture for hyperdriver::bridge::service::TowerHyperFuture<S, R> where F: core::future::future::Future
pub type hyperdriver::bridge::service::TowerHyperFuture<S, R>::IntoFuture = F
pub type hyperdriver::bridge::service::TowerHyperFuture<S, R>::Output = <F as core::future::future::Future>::Output
pub fn hyperdriver::bridge::service::TowerHyperFuture<S, R>::into_future(self) -> <F as core::future::into_future::IntoFuture>::IntoFuture
impl<Fut> futures_util::future::try_future::TryFutureExt for hyperdriver::bridge::service::TowerHyperFuture<S, R> where Fut: futures_core::future::TryFuture + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::bridge::service::TowerHyperFuture<S, R> where U: core::convert::From<T>
pub fn hyperdriver::bridge::service::TowerHyperFuture<S, R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::bridge::service::TowerHyperFuture<S, R> where U: core::convert::Into<T>
pub type hyperdriver::bridge::service::TowerHyperFuture<S, R>::Error = core::convert::Infallible
pub fn hyperdriver::bridge::service::TowerHyperFuture<S, R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::bridge::service::TowerHyperFuture<S, R> where U: core::convert::TryFrom<T>
pub type hyperdriver::bridge::service::TowerHyperFuture<S, R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::bridge::service::TowerHyperFuture<S, R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::bridge::service::TowerHyperFuture<S, R> where T: 'static + core::marker::Sized
pub fn hyperdriver::bridge::service::TowerHyperFuture<S, R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::bridge::service::TowerHyperFuture<S, R> where T: core::marker::Sized
pub fn hyperdriver::bridge::service::TowerHyperFuture<S, R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::bridge::service::TowerHyperFuture<S, R> where T: core::marker::Sized
pub fn hyperdriver::bridge::service::TowerHyperFuture<S, R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::bridge::service::TowerHyperFuture<S, R>
pub fn hyperdriver::bridge::service::TowerHyperFuture<S, R>::from(t: T) -> T
impl<T> futures_util::future::future::FutureExt for hyperdriver::bridge::service::TowerHyperFuture<S, R> where T: core::future::future::Future + core::marker::Sized
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::bridge::service::TowerHyperFuture<S, R> where T: core::marker::Sized
pub fn hyperdriver::bridge::service::TowerHyperFuture<S, R>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::bridge::service::TowerHyperFuture<S, R>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::bridge::service::TowerHyperFuture<S, R>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::bridge::service::TowerHyperFuture<S, R>
pub struct hyperdriver::bridge::service::TowerHyperService<S>
impl<S> hyperdriver::bridge::service::TowerHyperService<S>
pub fn hyperdriver::bridge::service::TowerHyperService<S>::new(inner: S) -> Self
impl<S, R> hyper::service::service::Service<R> for hyperdriver::bridge::service::TowerHyperService<S> where S: tower_service::Service<R> + core::clone::Clone
pub type hyperdriver::bridge::service::TowerHyperService<S>::Error = <S as tower_service::Service<R>>::Error
pub type hyperdriver::bridge::service::TowerHyperService<S>::Future = hyperdriver::bridge::service::TowerHyperFuture<S, R>
pub type hyperdriver::bridge::service::TowerHyperService<S>::Response = <S as tower_service::Service<R>>::Response
pub fn hyperdriver::bridge::service::TowerHyperService<S>::call(&self, req: R) -> Self::Future
impl<S: core::clone::Clone> core::clone::Clone for hyperdriver::bridge::service::TowerHyperService<S>
pub fn hyperdriver::bridge::service::TowerHyperService<S>::clone(&self) -> hyperdriver::bridge::service::TowerHyperService<S>
impl<S: core::fmt::Debug> core::fmt::Debug for hyperdriver::bridge::service::TowerHyperService<S>
pub fn hyperdriver::bridge::service::TowerHyperService<S>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S> core::marker::Freeze for hyperdriver::bridge::service::TowerHyperService<S> where S: core::marker::Freeze
impl<S> core::marker::Send for hyperdriver::bridge::service::TowerHyperService<S> where S: core::marker::Send
impl<S> core::marker::Sync for hyperdriver::bridge::service::TowerHyperService<S> where S: core::marker::Sync
impl<S> core::marker::Unpin for hyperdriver::bridge::service::TowerHyperService<S> where S: core::marker::Unpin
impl<S> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::bridge::service::TowerHyperService<S> where S: core::panic::unwind_safe::RefUnwindSafe
impl<S> core::panic::unwind_safe::UnwindSafe for hyperdriver::bridge::service::TowerHyperService<S> where S: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::bridge::service::TowerHyperService<S> where B: http_body::Body
impl<T, B1, B2> hyper::service::http::HttpService<B1> for hyperdriver::bridge::service::TowerHyperService<S> where T: hyper::service::service::Service<http::request::Request<B1>, Response = http::response::Response<B2>>, B2: http_body::Body, <T as hyper::service::service::Service<http::request::Request<B1>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::bridge::service::TowerHyperService<S>::Error = <T as hyper::service::service::Service<http::request::Request<B1>>>::Error
pub type hyperdriver::bridge::service::TowerHyperService<S>::Future = <T as hyper::service::service::Service<http::request::Request<B1>>>::Future
pub type hyperdriver::bridge::service::TowerHyperService<S>::ResBody = B2
pub fn hyperdriver::bridge::service::TowerHyperService<S>::call(&mut self, req: http::request::Request<B1>) -> <T as hyper::service::http::HttpService<B1>>::Future
impl<T, U> core::convert::Into<U> for hyperdriver::bridge::service::TowerHyperService<S> where U: core::convert::From<T>
pub fn hyperdriver::bridge::service::TowerHyperService<S>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::bridge::service::TowerHyperService<S> where U: core::convert::Into<T>
pub type hyperdriver::bridge::service::TowerHyperService<S>::Error = core::convert::Infallible
pub fn hyperdriver::bridge::service::TowerHyperService<S>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::bridge::service::TowerHyperService<S> where U: core::convert::TryFrom<T>
pub type hyperdriver::bridge::service::TowerHyperService<S>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::bridge::service::TowerHyperService<S>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::bridge::service::TowerHyperService<S> where T: core::clone::Clone
pub type hyperdriver::bridge::service::TowerHyperService<S>::Owned = T
pub fn hyperdriver::bridge::service::TowerHyperService<S>::clone_into(&self, target: &mut T)
pub fn hyperdriver::bridge::service::TowerHyperService<S>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::bridge::service::TowerHyperService<S> where T: core::clone::Clone
pub fn hyperdriver::bridge::service::TowerHyperService<S>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::bridge::service::TowerHyperService<S> where T: 'static + core::marker::Sized
pub fn hyperdriver::bridge::service::TowerHyperService<S>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::bridge::service::TowerHyperService<S> where T: core::marker::Sized
pub fn hyperdriver::bridge::service::TowerHyperService<S>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::bridge::service::TowerHyperService<S> where T: core::marker::Sized
pub fn hyperdriver::bridge::service::TowerHyperService<S>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::bridge::service::TowerHyperService<S> where T: core::clone::Clone
pub unsafe fn hyperdriver::bridge::service::TowerHyperService<S>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::bridge::service::TowerHyperService<S>
pub fn hyperdriver::bridge::service::TowerHyperService<S>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::bridge::service::TowerHyperService<S> where T: core::marker::Sized
pub fn hyperdriver::bridge::service::TowerHyperService<S>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::bridge::service::TowerHyperService<S>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::bridge::service::TowerHyperService<S>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::bridge::service::TowerHyperService<S>
pub mod hyperdriver::client
pub mod hyperdriver::client::conn
pub mod hyperdriver::client::conn::connection
#[non_exhaustive] pub enum hyperdriver::client::conn::connection::ConnectionError
pub hyperdriver::client::conn::connection::ConnectionError::Canceled(hyper::error::Error)
pub hyperdriver::client::conn::connection::ConnectionError::Closed(hyper::error::Error)
pub hyperdriver::client::conn::connection::ConnectionError::Connecting(alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync + 'static)>)
pub hyperdriver::client::conn::connection::ConnectionError::Handshake(alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync + 'static)>)
pub hyperdriver::client::conn::connection::ConnectionError::InvalidUri(hyperdriver::client::pool::UriError)
pub hyperdriver::client::conn::connection::ConnectionError::Timeout
impl core::convert::From<hyperdriver::client::pool::UriError> for hyperdriver::client::conn::connection::ConnectionError
pub fn hyperdriver::client::conn::connection::ConnectionError::from(source: hyperdriver::client::pool::UriError) -> Self
impl core::error::Error for hyperdriver::client::conn::connection::ConnectionError
pub fn hyperdriver::client::conn::connection::ConnectionError::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl core::fmt::Debug for hyperdriver::client::conn::connection::ConnectionError
pub fn hyperdriver::client::conn::connection::ConnectionError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::client::conn::connection::ConnectionError
pub fn hyperdriver::client::conn::connection::ConnectionError::fmt(&self, __formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl !core::marker::Freeze for hyperdriver::client::conn::connection::ConnectionError
impl core::marker::Send for hyperdriver::client::conn::connection::ConnectionError
impl core::marker::Sync for hyperdriver::client::conn::connection::ConnectionError
impl core::marker::Unpin for hyperdriver::client::conn::connection::ConnectionError
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::connection::ConnectionError
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::connection::ConnectionError
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::connection::ConnectionError where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::connection::ConnectionError where U: core::convert::From<T>
pub fn hyperdriver::client::conn::connection::ConnectionError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::connection::ConnectionError where U: core::convert::Into<T>
pub type hyperdriver::client::conn::connection::ConnectionError::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::connection::ConnectionError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::connection::ConnectionError where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::connection::ConnectionError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::connection::ConnectionError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for hyperdriver::client::conn::connection::ConnectionError where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::client::conn::connection::ConnectionError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for hyperdriver::client::conn::connection::ConnectionError where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::connection::ConnectionError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::connection::ConnectionError where T: core::marker::Sized
pub fn hyperdriver::client::conn::connection::ConnectionError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::connection::ConnectionError where T: core::marker::Sized
pub fn hyperdriver::client::conn::connection::ConnectionError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::connection::ConnectionError
pub fn hyperdriver::client::conn::connection::ConnectionError::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::client::conn::connection::ConnectionError where T: core::fmt::Display
pub fn hyperdriver::client::conn::connection::ConnectionError::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::connection::ConnectionError where T: core::marker::Sized
pub fn hyperdriver::client::conn::connection::ConnectionError::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::connection::ConnectionError::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::connection::ConnectionError
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::connection::ConnectionError
#[non_exhaustive] pub enum hyperdriver::client::conn::connection::UriError
pub hyperdriver::client::conn::connection::UriError::InvalidUri(http::uri::InvalidUri)
pub hyperdriver::client::conn::connection::UriError::MissingScheme(http::uri::Uri)
impl core::convert::From<http::uri::InvalidUri> for hyperdriver::client::pool::UriError
pub fn hyperdriver::client::pool::UriError::from(source: http::uri::InvalidUri) -> Self
impl core::convert::From<hyperdriver::client::pool::UriError> for hyperdriver::client::conn::connection::ConnectionError
pub fn hyperdriver::client::conn::connection::ConnectionError::from(source: hyperdriver::client::pool::UriError) -> Self
impl core::error::Error for hyperdriver::client::pool::UriError
pub fn hyperdriver::client::pool::UriError::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl core::fmt::Debug for hyperdriver::client::pool::UriError
pub fn hyperdriver::client::pool::UriError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::client::pool::UriError
pub fn hyperdriver::client::pool::UriError::fmt(&self, __formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl !core::marker::Freeze for hyperdriver::client::pool::UriError
impl core::marker::Send for hyperdriver::client::pool::UriError
impl core::marker::Sync for hyperdriver::client::pool::UriError
impl core::marker::Unpin for hyperdriver::client::pool::UriError
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::pool::UriError
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::pool::UriError
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::pool::UriError where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::pool::UriError where U: core::convert::From<T>
pub fn hyperdriver::client::pool::UriError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::pool::UriError where U: core::convert::Into<T>
pub type hyperdriver::client::pool::UriError::Error = core::convert::Infallible
pub fn hyperdriver::client::pool::UriError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::pool::UriError where U: core::convert::TryFrom<T>
pub type hyperdriver::client::pool::UriError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::pool::UriError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for hyperdriver::client::pool::UriError where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::client::pool::UriError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for hyperdriver::client::pool::UriError where T: 'static + core::marker::Sized
pub fn hyperdriver::client::pool::UriError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::pool::UriError where T: core::marker::Sized
pub fn hyperdriver::client::pool::UriError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::pool::UriError where T: core::marker::Sized
pub fn hyperdriver::client::pool::UriError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::pool::UriError
pub fn hyperdriver::client::pool::UriError::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::client::pool::UriError where T: core::fmt::Display
pub fn hyperdriver::client::pool::UriError::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::pool::UriError where T: core::marker::Sized
pub fn hyperdriver::client::pool::UriError::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::pool::UriError::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::pool::UriError
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::pool::UriError
pub struct hyperdriver::client::conn::connection::HttpConnection<B>
impl<B> core::fmt::Debug for hyperdriver::client::conn::connection::HttpConnection<B> where B: http_body::Body + core::marker::Send + 'static
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<B> hyperdriver::client::conn::connection::Connection<B> for hyperdriver::client::conn::connection::HttpConnection<B> where B: http_body::Body + core::marker::Send + 'static
pub type hyperdriver::client::conn::connection::HttpConnection<B>::Error = hyper::error::Error
pub type hyperdriver::client::conn::connection::HttpConnection<B>::Future = core::pin::Pin<alloc::boxed::Box<(dyn core::future::future::Future<Output = core::result::Result<http::response::Response<hyper::body::incoming::Incoming>, hyper::error::Error>> + core::marker::Send)>>
pub type hyperdriver::client::conn::connection::HttpConnection<B>::ResBody = hyper::body::incoming::Incoming
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::send_request(&mut self, request: http::request::Request<B>) -> Self::Future
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::version(&self) -> http::version::Version
impl<B> hyperdriver::client::pool::PoolableConnection for hyperdriver::client::conn::connection::HttpConnection<B> where B: core::marker::Send + 'static
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::can_share(&self) -> bool
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::is_open(&self) -> bool
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::reuse(&mut self) -> core::option::Option<Self>
impl<B> core::marker::Freeze for hyperdriver::client::conn::connection::HttpConnection<B>
impl<B> core::marker::Send for hyperdriver::client::conn::connection::HttpConnection<B> where B: core::marker::Send
impl<B> core::marker::Sync for hyperdriver::client::conn::connection::HttpConnection<B> where B: core::marker::Send
impl<B> core::marker::Unpin for hyperdriver::client::conn::connection::HttpConnection<B>
impl<B> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::connection::HttpConnection<B>
impl<B> !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::connection::HttpConnection<B>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::connection::HttpConnection<B> where B: http_body::Body
impl<T, B> hyperdriver::client::conn::connection::ConnectionExt<B> for hyperdriver::client::conn::connection::HttpConnection<B> where T: hyperdriver::client::conn::connection::Connection<B>
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::connection::HttpConnection<B> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::connection::HttpConnection<B> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::connection::HttpConnection<B>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::connection::HttpConnection<B> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::connection::HttpConnection<B>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::client::conn::connection::HttpConnection<B> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::connection::HttpConnection<B> where T: core::marker::Sized
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::connection::HttpConnection<B> where T: core::marker::Sized
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::connection::HttpConnection<B>
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::connection::HttpConnection<B> where T: core::marker::Sized
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::connection::HttpConnection<B>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::connection::HttpConnection<B>
pub struct hyperdriver::client::conn::connection::WhenReady<'a, C, B> where C: hyperdriver::client::conn::connection::Connection<B> + core::marker::Sized
impl<'a, C, B: core::fmt::Debug> core::fmt::Debug for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where C: hyperdriver::client::conn::connection::Connection<B> + core::marker::Sized + core::fmt::Debug
pub fn hyperdriver::client::conn::connection::WhenReady<'a, C, B>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'a, C, B> core::future::future::Future for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where C: hyperdriver::client::conn::connection::Connection<B> + core::marker::Sized
pub type hyperdriver::client::conn::connection::WhenReady<'a, C, B>::Output = core::result::Result<(), <C as hyperdriver::client::conn::connection::Connection<B>>::Error>
pub fn hyperdriver::client::conn::connection::WhenReady<'a, C, B>::poll(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<Self::Output>
impl<'a, C, B> core::marker::Freeze for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where C: core::marker::Sized
impl<'a, C, B> core::marker::Send for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where C: core::marker::Send + core::marker::Sized
impl<'a, C, B> core::marker::Sync for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where C: core::marker::Sync + core::marker::Sized
impl<'a, C, B> core::marker::Unpin for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where C: core::marker::Sized
impl<'a, C, B> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where C: core::panic::unwind_safe::RefUnwindSafe + core::marker::Sized
impl<'a, C, B> !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::connection::WhenReady<'a, C, B>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where B: http_body::Body
impl<F, T, E> futures_core::future::TryFuture for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where F: core::future::future::Future<Output = core::result::Result<T, E>> + core::marker::Sized
pub type hyperdriver::client::conn::connection::WhenReady<'a, C, B>::Error = E
pub type hyperdriver::client::conn::connection::WhenReady<'a, C, B>::Ok = T
pub fn hyperdriver::client::conn::connection::WhenReady<'a, C, B>::try_poll(self: core::pin::Pin<&mut F>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<<F as core::future::future::Future>::Output>
impl<F> core::future::into_future::IntoFuture for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where F: core::future::future::Future
pub type hyperdriver::client::conn::connection::WhenReady<'a, C, B>::IntoFuture = F
pub type hyperdriver::client::conn::connection::WhenReady<'a, C, B>::Output = <F as core::future::future::Future>::Output
pub fn hyperdriver::client::conn::connection::WhenReady<'a, C, B>::into_future(self) -> <F as core::future::into_future::IntoFuture>::IntoFuture
impl<Fut> futures_util::future::try_future::TryFutureExt for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where Fut: futures_core::future::TryFuture + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::connection::WhenReady<'a, C, B>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::connection::WhenReady<'a, C, B>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::connection::WhenReady<'a, C, B>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::connection::WhenReady<'a, C, B>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::connection::WhenReady<'a, C, B>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::connection::WhenReady<'a, C, B>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where T: core::marker::Sized
pub fn hyperdriver::client::conn::connection::WhenReady<'a, C, B>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where T: core::marker::Sized
pub fn hyperdriver::client::conn::connection::WhenReady<'a, C, B>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::connection::WhenReady<'a, C, B>
pub fn hyperdriver::client::conn::connection::WhenReady<'a, C, B>::from(t: T) -> T
impl<T> futures_util::future::future::FutureExt for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where T: core::future::future::Future + core::marker::Sized
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::connection::WhenReady<'a, C, B> where T: core::marker::Sized
pub fn hyperdriver::client::conn::connection::WhenReady<'a, C, B>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::connection::WhenReady<'a, C, B>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::connection::WhenReady<'a, C, B>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::connection::WhenReady<'a, C, B>
pub trait hyperdriver::client::conn::connection::Connection<B>
pub type hyperdriver::client::conn::connection::Connection::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::client::conn::connection::Connection::Future: core::future::future::Future<Output = core::result::Result<http::response::Response<Self::ResBody>, Self::Error>> + core::marker::Send + 'static
pub type hyperdriver::client::conn::connection::Connection::ResBody: http_body::Body + core::marker::Send + 'static
pub fn hyperdriver::client::conn::connection::Connection::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
pub fn hyperdriver::client::conn::connection::Connection::send_request(&mut self, request: http::request::Request<B>) -> Self::Future
pub fn hyperdriver::client::conn::connection::Connection::version(&self) -> http::version::Version
impl hyperdriver::client::conn::connection::Connection<hyperdriver::body::Body> for hyperdriver::client::conn::protocol::mock::MockSender
pub type hyperdriver::client::conn::protocol::mock::MockSender::Error = hyperdriver::client::conn::protocol::mock::MockProtocolError
pub type hyperdriver::client::conn::protocol::mock::MockSender::Future = core::future::ready::Ready<core::result::Result<http::response::Response<hyperdriver::body::Body>, <hyperdriver::client::conn::protocol::mock::MockSender as hyperdriver::client::conn::connection::Connection<hyperdriver::body::Body>>::Error>>
pub type hyperdriver::client::conn::protocol::mock::MockSender::ResBody = hyperdriver::body::Body
pub fn hyperdriver::client::conn::protocol::mock::MockSender::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
pub fn hyperdriver::client::conn::protocol::mock::MockSender::send_request(&mut self, request: http::request::Request<hyperdriver::body::Body>) -> Self::Future
pub fn hyperdriver::client::conn::protocol::mock::MockSender::version(&self) -> http::version::Version
impl<B> hyperdriver::client::conn::connection::Connection<B> for hyperdriver::client::conn::connection::HttpConnection<B> where B: http_body::Body + core::marker::Send + 'static
pub type hyperdriver::client::conn::connection::HttpConnection<B>::Error = hyper::error::Error
pub type hyperdriver::client::conn::connection::HttpConnection<B>::Future = core::pin::Pin<alloc::boxed::Box<(dyn core::future::future::Future<Output = core::result::Result<http::response::Response<hyper::body::incoming::Incoming>, hyper::error::Error>> + core::marker::Send)>>
pub type hyperdriver::client::conn::connection::HttpConnection<B>::ResBody = hyper::body::incoming::Incoming
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::send_request(&mut self, request: http::request::Request<B>) -> Self::Future
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::version(&self) -> http::version::Version
pub trait hyperdriver::client::conn::connection::ConnectionExt<B>: hyperdriver::client::conn::connection::Connection<B>
pub fn hyperdriver::client::conn::connection::ConnectionExt::when_ready(&mut self) -> hyperdriver::client::conn::connection::WhenReady<'_, Self, B>
impl<T, B> hyperdriver::client::conn::connection::ConnectionExt<B> for T where T: hyperdriver::client::conn::connection::Connection<B>
pub mod hyperdriver::client::conn::dns
pub enum hyperdriver::client::conn::dns::IpVersion
pub hyperdriver::client::conn::dns::IpVersion::V4
pub hyperdriver::client::conn::dns::IpVersion::V6
impl hyperdriver::client::conn::dns::IpVersion
pub fn hyperdriver::client::conn::dns::IpVersion::is_v4(&self) -> bool
pub fn hyperdriver::client::conn::dns::IpVersion::is_v6(&self) -> bool
impl core::clone::Clone for hyperdriver::client::conn::dns::IpVersion
pub fn hyperdriver::client::conn::dns::IpVersion::clone(&self) -> hyperdriver::client::conn::dns::IpVersion
impl core::cmp::Eq for hyperdriver::client::conn::dns::IpVersion
impl core::cmp::PartialEq for hyperdriver::client::conn::dns::IpVersion
pub fn hyperdriver::client::conn::dns::IpVersion::eq(&self, other: &hyperdriver::client::conn::dns::IpVersion) -> bool
impl core::fmt::Debug for hyperdriver::client::conn::dns::IpVersion
pub fn hyperdriver::client::conn::dns::IpVersion::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for hyperdriver::client::conn::dns::IpVersion
pub fn hyperdriver::client::conn::dns::IpVersion::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::Copy for hyperdriver::client::conn::dns::IpVersion
impl core::marker::StructuralPartialEq for hyperdriver::client::conn::dns::IpVersion
impl core::marker::Freeze for hyperdriver::client::conn::dns::IpVersion
impl core::marker::Send for hyperdriver::client::conn::dns::IpVersion
impl core::marker::Sync for hyperdriver::client::conn::dns::IpVersion
impl core::marker::Unpin for hyperdriver::client::conn::dns::IpVersion
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::dns::IpVersion
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::dns::IpVersion
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::dns::IpVersion where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::client::conn::dns::IpVersion where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::conn::dns::IpVersion::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::client::conn::dns::IpVersion where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::conn::dns::IpVersion::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::dns::IpVersion where U: core::convert::From<T>
pub fn hyperdriver::client::conn::dns::IpVersion::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::dns::IpVersion where U: core::convert::Into<T>
pub type hyperdriver::client::conn::dns::IpVersion::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::dns::IpVersion::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::dns::IpVersion where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::dns::IpVersion::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::dns::IpVersion::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::dns::IpVersion where T: core::clone::Clone
pub type hyperdriver::client::conn::dns::IpVersion::Owned = T
pub fn hyperdriver::client::conn::dns::IpVersion::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::dns::IpVersion::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::dns::IpVersion where T: core::clone::Clone
pub fn hyperdriver::client::conn::dns::IpVersion::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::dns::IpVersion where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::dns::IpVersion::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::dns::IpVersion where T: core::marker::Sized
pub fn hyperdriver::client::conn::dns::IpVersion::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::dns::IpVersion where T: core::marker::Sized
pub fn hyperdriver::client::conn::dns::IpVersion::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::dns::IpVersion where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::dns::IpVersion::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::dns::IpVersion
pub fn hyperdriver::client::conn::dns::IpVersion::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::dns::IpVersion where T: core::marker::Sized
pub fn hyperdriver::client::conn::dns::IpVersion::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::dns::IpVersion::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::dns::IpVersion
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::dns::IpVersion
pub struct hyperdriver::client::conn::dns::GaiFuture
impl core::fmt::Debug for hyperdriver::client::conn::dns::GaiFuture
pub fn hyperdriver::client::conn::dns::GaiFuture::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::future::future::Future for hyperdriver::client::conn::dns::GaiFuture
pub type hyperdriver::client::conn::dns::GaiFuture::Output = core::result::Result<hyperdriver::client::conn::dns::SocketAddrs, std::io::error::Error>
pub fn hyperdriver::client::conn::dns::GaiFuture::poll(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<Self::Output>
impl core::ops::drop::Drop for hyperdriver::client::conn::dns::GaiFuture
pub fn hyperdriver::client::conn::dns::GaiFuture::drop(&mut self)
impl<'pin> core::marker::Unpin for hyperdriver::client::conn::dns::GaiFuture where __GaiFuture<'pin>: core::marker::Unpin
impl core::marker::Freeze for hyperdriver::client::conn::dns::GaiFuture
impl core::marker::Send for hyperdriver::client::conn::dns::GaiFuture
impl core::marker::Sync for hyperdriver::client::conn::dns::GaiFuture
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::dns::GaiFuture
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::dns::GaiFuture
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::dns::GaiFuture where B: http_body::Body
impl<F, T, E> futures_core::future::TryFuture for hyperdriver::client::conn::dns::GaiFuture where F: core::future::future::Future<Output = core::result::Result<T, E>> + core::marker::Sized
pub type hyperdriver::client::conn::dns::GaiFuture::Error = E
pub type hyperdriver::client::conn::dns::GaiFuture::Ok = T
pub fn hyperdriver::client::conn::dns::GaiFuture::try_poll(self: core::pin::Pin<&mut F>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<<F as core::future::future::Future>::Output>
impl<F> core::future::into_future::IntoFuture for hyperdriver::client::conn::dns::GaiFuture where F: core::future::future::Future
pub type hyperdriver::client::conn::dns::GaiFuture::IntoFuture = F
pub type hyperdriver::client::conn::dns::GaiFuture::Output = <F as core::future::future::Future>::Output
pub fn hyperdriver::client::conn::dns::GaiFuture::into_future(self) -> <F as core::future::into_future::IntoFuture>::IntoFuture
impl<Fut> futures_util::future::try_future::TryFutureExt for hyperdriver::client::conn::dns::GaiFuture where Fut: futures_core::future::TryFuture + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::dns::GaiFuture where U: core::convert::From<T>
pub fn hyperdriver::client::conn::dns::GaiFuture::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::dns::GaiFuture where U: core::convert::Into<T>
pub type hyperdriver::client::conn::dns::GaiFuture::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::dns::GaiFuture::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::dns::GaiFuture where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::dns::GaiFuture::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::dns::GaiFuture::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::client::conn::dns::GaiFuture where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::dns::GaiFuture::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::dns::GaiFuture where T: core::marker::Sized
pub fn hyperdriver::client::conn::dns::GaiFuture::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::dns::GaiFuture where T: core::marker::Sized
pub fn hyperdriver::client::conn::dns::GaiFuture::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::dns::GaiFuture
pub fn hyperdriver::client::conn::dns::GaiFuture::from(t: T) -> T
impl<T> futures_util::future::future::FutureExt for hyperdriver::client::conn::dns::GaiFuture where T: core::future::future::Future + core::marker::Sized
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::dns::GaiFuture where T: core::marker::Sized
pub fn hyperdriver::client::conn::dns::GaiFuture::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::dns::GaiFuture::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::dns::GaiFuture
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::dns::GaiFuture
pub struct hyperdriver::client::conn::dns::GaiResolver
impl hyperdriver::client::conn::dns::GaiResolver
pub fn hyperdriver::client::conn::dns::GaiResolver::new() -> Self
impl core::clone::Clone for hyperdriver::client::conn::dns::GaiResolver
pub fn hyperdriver::client::conn::dns::GaiResolver::clone(&self) -> hyperdriver::client::conn::dns::GaiResolver
impl core::default::Default for hyperdriver::client::conn::dns::GaiResolver
pub fn hyperdriver::client::conn::dns::GaiResolver::default() -> hyperdriver::client::conn::dns::GaiResolver
impl core::fmt::Debug for hyperdriver::client::conn::dns::GaiResolver
pub fn hyperdriver::client::conn::dns::GaiResolver::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for hyperdriver::client::conn::dns::GaiResolver
impl tower_service::Service<alloc::boxed::Box<str>> for hyperdriver::client::conn::dns::GaiResolver
pub type hyperdriver::client::conn::dns::GaiResolver::Error = std::io::error::Error
pub type hyperdriver::client::conn::dns::GaiResolver::Future = hyperdriver::client::conn::dns::GaiFuture
pub type hyperdriver::client::conn::dns::GaiResolver::Response = hyperdriver::client::conn::dns::SocketAddrs
pub fn hyperdriver::client::conn::dns::GaiResolver::call(&mut self, host: alloc::boxed::Box<str>) -> Self::Future
pub fn hyperdriver::client::conn::dns::GaiResolver::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl core::marker::Freeze for hyperdriver::client::conn::dns::GaiResolver
impl core::marker::Send for hyperdriver::client::conn::dns::GaiResolver
impl core::marker::Sync for hyperdriver::client::conn::dns::GaiResolver
impl core::marker::Unpin for hyperdriver::client::conn::dns::GaiResolver
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::dns::GaiResolver
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::dns::GaiResolver
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::dns::GaiResolver where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::client::conn::dns::GaiResolver where S: tower_service::Service<R>
pub fn hyperdriver::client::conn::dns::GaiResolver::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::client::conn::dns::GaiResolver::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::dns::GaiResolver where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::dns::GaiResolver where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::dns::GaiResolver where U: core::convert::From<T>
pub fn hyperdriver::client::conn::dns::GaiResolver::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::dns::GaiResolver where U: core::convert::Into<T>
pub type hyperdriver::client::conn::dns::GaiResolver::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::dns::GaiResolver::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::dns::GaiResolver where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::dns::GaiResolver::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::dns::GaiResolver::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::dns::GaiResolver where T: core::clone::Clone
pub type hyperdriver::client::conn::dns::GaiResolver::Owned = T
pub fn hyperdriver::client::conn::dns::GaiResolver::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::dns::GaiResolver::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::dns::GaiResolver where T: core::clone::Clone
pub fn hyperdriver::client::conn::dns::GaiResolver::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::dns::GaiResolver where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::dns::GaiResolver::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::dns::GaiResolver where T: core::marker::Sized
pub fn hyperdriver::client::conn::dns::GaiResolver::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::dns::GaiResolver where T: core::marker::Sized
pub fn hyperdriver::client::conn::dns::GaiResolver::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::dns::GaiResolver where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::dns::GaiResolver::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::dns::GaiResolver
pub fn hyperdriver::client::conn::dns::GaiResolver::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::dns::GaiResolver where T: core::marker::Sized
pub fn hyperdriver::client::conn::dns::GaiResolver::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::dns::GaiResolver::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::dns::GaiResolver
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::dns::GaiResolver
pub struct hyperdriver::client::conn::dns::SocketAddrs(_)
impl core::clone::Clone for hyperdriver::client::conn::dns::SocketAddrs
pub fn hyperdriver::client::conn::dns::SocketAddrs::clone(&self) -> hyperdriver::client::conn::dns::SocketAddrs
impl core::default::Default for hyperdriver::client::conn::dns::SocketAddrs
pub fn hyperdriver::client::conn::dns::SocketAddrs::default() -> hyperdriver::client::conn::dns::SocketAddrs
impl core::fmt::Debug for hyperdriver::client::conn::dns::SocketAddrs
pub fn hyperdriver::client::conn::dns::SocketAddrs::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::iter::traits::collect::FromIterator<core::net::socket_addr::SocketAddr> for hyperdriver::client::conn::dns::SocketAddrs
pub fn hyperdriver::client::conn::dns::SocketAddrs::from_iter<T: core::iter::traits::collect::IntoIterator<Item = core::net::socket_addr::SocketAddr>>(iter: T) -> Self
impl<'a> core::iter::traits::collect::IntoIterator for &'a hyperdriver::client::conn::dns::SocketAddrs
pub type &'a hyperdriver::client::conn::dns::SocketAddrs::IntoIter = alloc::collections::vec_deque::iter::Iter<'a, core::net::socket_addr::SocketAddr>
pub type &'a hyperdriver::client::conn::dns::SocketAddrs::Item = &'a core::net::socket_addr::SocketAddr
pub fn &'a hyperdriver::client::conn::dns::SocketAddrs::into_iter(self) -> Self::IntoIter
impl core::marker::Freeze for hyperdriver::client::conn::dns::SocketAddrs
impl core::marker::Send for hyperdriver::client::conn::dns::SocketAddrs
impl core::marker::Sync for hyperdriver::client::conn::dns::SocketAddrs
impl core::marker::Unpin for hyperdriver::client::conn::dns::SocketAddrs
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::dns::SocketAddrs
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::dns::SocketAddrs
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::dns::SocketAddrs where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::dns::SocketAddrs where U: core::convert::From<T>
pub fn hyperdriver::client::conn::dns::SocketAddrs::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::dns::SocketAddrs where U: core::convert::Into<T>
pub type hyperdriver::client::conn::dns::SocketAddrs::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::dns::SocketAddrs::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::dns::SocketAddrs where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::dns::SocketAddrs::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::dns::SocketAddrs::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::dns::SocketAddrs where T: core::clone::Clone
pub type hyperdriver::client::conn::dns::SocketAddrs::Owned = T
pub fn hyperdriver::client::conn::dns::SocketAddrs::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::dns::SocketAddrs::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::dns::SocketAddrs where T: core::clone::Clone
pub fn hyperdriver::client::conn::dns::SocketAddrs::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::dns::SocketAddrs where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::dns::SocketAddrs::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::dns::SocketAddrs where T: core::marker::Sized
pub fn hyperdriver::client::conn::dns::SocketAddrs::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::dns::SocketAddrs where T: core::marker::Sized
pub fn hyperdriver::client::conn::dns::SocketAddrs::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::dns::SocketAddrs where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::dns::SocketAddrs::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::dns::SocketAddrs
pub fn hyperdriver::client::conn::dns::SocketAddrs::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::dns::SocketAddrs where T: core::marker::Sized
pub fn hyperdriver::client::conn::dns::SocketAddrs::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::dns::SocketAddrs::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::dns::SocketAddrs
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::dns::SocketAddrs
pub trait hyperdriver::client::conn::dns::IpVersionExt
pub fn hyperdriver::client::conn::dns::IpVersionExt::version(&self) -> hyperdriver::client::conn::dns::IpVersion
impl hyperdriver::client::conn::dns::IpVersionExt for core::net::ip_addr::IpAddr
pub fn core::net::ip_addr::IpAddr::version(&self) -> hyperdriver::client::conn::dns::IpVersion
impl hyperdriver::client::conn::dns::IpVersionExt for core::net::socket_addr::SocketAddr
pub fn core::net::socket_addr::SocketAddr::version(&self) -> hyperdriver::client::conn::dns::IpVersion
pub mod hyperdriver::client::conn::protocol
pub use hyperdriver::client::conn::protocol::http1
pub use hyperdriver::client::conn::protocol::http2
pub mod hyperdriver::client::conn::protocol::auto
pub struct hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>
impl<B> hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::http1(&mut self) -> &mut hyper::client::conn::http1::Builder
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::http2(&mut self) -> &mut hyper::client::conn::http2::Builder<hyperdriver::bridge::rt::TokioExecutor>
impl<B: core::fmt::Debug> core::fmt::Debug for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<B> core::clone::Clone for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::clone(&self) -> Self
impl<B> core::default::Default for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::default() -> Self
impl<IO, B> tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>> for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where IO: hyperdriver::info::tls::HasTlsConnectionInfo + hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Send + core::marker::Sync, B: http_body::Body + core::marker::Unpin + core::marker::Send + 'static, <B as http_body::Body>::Data: core::marker::Send, <B as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub type hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::Error = hyperdriver::client::conn::connection::ConnectionError
pub type hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::Future = HttpConnectFuture<IO, B>
pub type hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::Response = hyperdriver::client::conn::connection::HttpConnection<B>
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::call(&mut self, req: hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>) -> Self::Future
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<B> core::marker::Freeze for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>
impl<B> core::marker::Send for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>
impl<B> core::marker::Sync for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>
impl<B> core::marker::Unpin for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>
impl<B> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>
impl<B> !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where S: tower_service::Service<R>
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where T: core::clone::Clone
pub type hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::Owned = T
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where T: core::clone::Clone
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>
pub mod hyperdriver::client::conn::protocol::mock
pub struct hyperdriver::client::conn::protocol::mock::MockProtocol
impl core::clone::Clone for hyperdriver::client::conn::protocol::mock::MockProtocol
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::clone(&self) -> hyperdriver::client::conn::protocol::mock::MockProtocol
impl core::cmp::Eq for hyperdriver::client::conn::protocol::mock::MockProtocol
impl core::cmp::PartialEq for hyperdriver::client::conn::protocol::mock::MockProtocol
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::eq(&self, other: &hyperdriver::client::conn::protocol::mock::MockProtocol) -> bool
impl core::default::Default for hyperdriver::client::conn::protocol::mock::MockProtocol
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::default() -> hyperdriver::client::conn::protocol::mock::MockProtocol
impl core::fmt::Debug for hyperdriver::client::conn::protocol::mock::MockProtocol
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::StructuralPartialEq for hyperdriver::client::conn::protocol::mock::MockProtocol
impl tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<hyperdriver::client::conn::stream::mock::MockStream, hyperdriver::body::Body>> for hyperdriver::client::conn::protocol::mock::MockProtocol
pub type hyperdriver::client::conn::protocol::mock::MockProtocol::Error = hyperdriver::client::conn::connection::ConnectionError
pub type hyperdriver::client::conn::protocol::mock::MockProtocol::Future = core::future::ready::Ready<core::result::Result<hyperdriver::client::conn::protocol::mock::MockSender, hyperdriver::client::conn::connection::ConnectionError>>
pub type hyperdriver::client::conn::protocol::mock::MockProtocol::Response = hyperdriver::client::conn::protocol::mock::MockSender
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::call(&mut self, req: hyperdriver::client::conn::protocol::ProtocolRequest<hyperdriver::client::conn::stream::mock::MockStream, hyperdriver::body::Body>) -> Self::Future
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl core::marker::Freeze for hyperdriver::client::conn::protocol::mock::MockProtocol
impl core::marker::Send for hyperdriver::client::conn::protocol::mock::MockProtocol
impl core::marker::Sync for hyperdriver::client::conn::protocol::mock::MockProtocol
impl core::marker::Unpin for hyperdriver::client::conn::protocol::mock::MockProtocol
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::protocol::mock::MockProtocol
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::protocol::mock::MockProtocol
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::protocol::mock::MockProtocol where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::client::conn::protocol::mock::MockProtocol where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::client::conn::protocol::mock::MockProtocol where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::equivalent(&self, key: &K) -> bool
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::client::conn::protocol::mock::MockProtocol where S: tower_service::Service<R>
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::protocol::mock::MockProtocol where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::protocol::mock::MockProtocol where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::protocol::mock::MockProtocol where U: core::convert::From<T>
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::protocol::mock::MockProtocol where U: core::convert::Into<T>
pub type hyperdriver::client::conn::protocol::mock::MockProtocol::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::protocol::mock::MockProtocol where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::protocol::mock::MockProtocol::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::protocol::mock::MockProtocol where T: core::clone::Clone
pub type hyperdriver::client::conn::protocol::mock::MockProtocol::Owned = T
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::protocol::mock::MockProtocol where T: core::clone::Clone
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::protocol::mock::MockProtocol where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::protocol::mock::MockProtocol where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::protocol::mock::MockProtocol where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::protocol::mock::MockProtocol where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::protocol::mock::MockProtocol::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::protocol::mock::MockProtocol
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::protocol::mock::MockProtocol where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::protocol::mock::MockProtocol
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::protocol::mock::MockProtocol
pub struct hyperdriver::client::conn::protocol::mock::MockProtocolError
impl core::cmp::Eq for hyperdriver::client::conn::protocol::mock::MockProtocolError
impl core::cmp::PartialEq for hyperdriver::client::conn::protocol::mock::MockProtocolError
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::eq(&self, other: &hyperdriver::client::conn::protocol::mock::MockProtocolError) -> bool
impl core::default::Default for hyperdriver::client::conn::protocol::mock::MockProtocolError
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::default() -> hyperdriver::client::conn::protocol::mock::MockProtocolError
impl core::error::Error for hyperdriver::client::conn::protocol::mock::MockProtocolError
impl core::fmt::Debug for hyperdriver::client::conn::protocol::mock::MockProtocolError
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::client::conn::protocol::mock::MockProtocolError
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::fmt(&self, __formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::StructuralPartialEq for hyperdriver::client::conn::protocol::mock::MockProtocolError
impl core::marker::Freeze for hyperdriver::client::conn::protocol::mock::MockProtocolError
impl core::marker::Send for hyperdriver::client::conn::protocol::mock::MockProtocolError
impl core::marker::Sync for hyperdriver::client::conn::protocol::mock::MockProtocolError
impl core::marker::Unpin for hyperdriver::client::conn::protocol::mock::MockProtocolError
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::protocol::mock::MockProtocolError
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::protocol::mock::MockProtocolError
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::protocol::mock::MockProtocolError where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::client::conn::protocol::mock::MockProtocolError where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::client::conn::protocol::mock::MockProtocolError where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::protocol::mock::MockProtocolError where U: core::convert::From<T>
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::protocol::mock::MockProtocolError where U: core::convert::Into<T>
pub type hyperdriver::client::conn::protocol::mock::MockProtocolError::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::protocol::mock::MockProtocolError where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::protocol::mock::MockProtocolError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for hyperdriver::client::conn::protocol::mock::MockProtocolError where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for hyperdriver::client::conn::protocol::mock::MockProtocolError where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::protocol::mock::MockProtocolError where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::protocol::mock::MockProtocolError where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::protocol::mock::MockProtocolError
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::client::conn::protocol::mock::MockProtocolError where T: core::fmt::Display
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::protocol::mock::MockProtocolError where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::protocol::mock::MockProtocolError::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::protocol::mock::MockProtocolError
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::protocol::mock::MockProtocolError
pub struct hyperdriver::client::conn::protocol::mock::MockSender
impl hyperdriver::client::conn::protocol::mock::MockSender
pub fn hyperdriver::client::conn::protocol::mock::MockSender::close(&self)
pub fn hyperdriver::client::conn::protocol::mock::MockSender::id(&self) -> hyperdriver::client::conn::stream::mock::StreamID
pub fn hyperdriver::client::conn::protocol::mock::MockSender::new() -> Self
pub fn hyperdriver::client::conn::protocol::mock::MockSender::reusable() -> Self
pub fn hyperdriver::client::conn::protocol::mock::MockSender::single() -> Self
impl core::clone::Clone for hyperdriver::client::conn::protocol::mock::MockSender
pub fn hyperdriver::client::conn::protocol::mock::MockSender::clone(&self) -> hyperdriver::client::conn::protocol::mock::MockSender
impl core::default::Default for hyperdriver::client::conn::protocol::mock::MockSender
pub fn hyperdriver::client::conn::protocol::mock::MockSender::default() -> Self
impl core::fmt::Debug for hyperdriver::client::conn::protocol::mock::MockSender
pub fn hyperdriver::client::conn::protocol::mock::MockSender::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl hyperdriver::client::conn::connection::Connection<hyperdriver::body::Body> for hyperdriver::client::conn::protocol::mock::MockSender
pub type hyperdriver::client::conn::protocol::mock::MockSender::Error = hyperdriver::client::conn::protocol::mock::MockProtocolError
pub type hyperdriver::client::conn::protocol::mock::MockSender::Future = core::future::ready::Ready<core::result::Result<http::response::Response<hyperdriver::body::Body>, <hyperdriver::client::conn::protocol::mock::MockSender as hyperdriver::client::conn::connection::Connection<hyperdriver::body::Body>>::Error>>
pub type hyperdriver::client::conn::protocol::mock::MockSender::ResBody = hyperdriver::body::Body
pub fn hyperdriver::client::conn::protocol::mock::MockSender::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
pub fn hyperdriver::client::conn::protocol::mock::MockSender::send_request(&mut self, request: http::request::Request<hyperdriver::body::Body>) -> Self::Future
pub fn hyperdriver::client::conn::protocol::mock::MockSender::version(&self) -> http::version::Version
impl hyperdriver::client::pool::PoolableConnection for hyperdriver::client::conn::protocol::mock::MockSender
pub fn hyperdriver::client::conn::protocol::mock::MockSender::can_share(&self) -> bool
pub fn hyperdriver::client::conn::protocol::mock::MockSender::is_open(&self) -> bool
pub fn hyperdriver::client::conn::protocol::mock::MockSender::reuse(&mut self) -> core::option::Option<Self>
impl core::marker::Freeze for hyperdriver::client::conn::protocol::mock::MockSender
impl core::marker::Send for hyperdriver::client::conn::protocol::mock::MockSender
impl core::marker::Sync for hyperdriver::client::conn::protocol::mock::MockSender
impl core::marker::Unpin for hyperdriver::client::conn::protocol::mock::MockSender
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::protocol::mock::MockSender
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::protocol::mock::MockSender
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::protocol::mock::MockSender where B: http_body::Body
impl<T, B> hyperdriver::client::conn::connection::ConnectionExt<B> for hyperdriver::client::conn::protocol::mock::MockSender where T: hyperdriver::client::conn::connection::Connection<B>
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::protocol::mock::MockSender where U: core::convert::From<T>
pub fn hyperdriver::client::conn::protocol::mock::MockSender::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::protocol::mock::MockSender where U: core::convert::Into<T>
pub type hyperdriver::client::conn::protocol::mock::MockSender::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::protocol::mock::MockSender::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::protocol::mock::MockSender where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::protocol::mock::MockSender::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::protocol::mock::MockSender::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::protocol::mock::MockSender where T: core::clone::Clone
pub type hyperdriver::client::conn::protocol::mock::MockSender::Owned = T
pub fn hyperdriver::client::conn::protocol::mock::MockSender::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::protocol::mock::MockSender::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::protocol::mock::MockSender where T: core::clone::Clone
pub fn hyperdriver::client::conn::protocol::mock::MockSender::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::protocol::mock::MockSender where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockSender::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::protocol::mock::MockSender where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockSender::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::protocol::mock::MockSender where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockSender::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::protocol::mock::MockSender where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::protocol::mock::MockSender::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::protocol::mock::MockSender
pub fn hyperdriver::client::conn::protocol::mock::MockSender::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::protocol::mock::MockSender where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::mock::MockSender::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::protocol::mock::MockSender::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::protocol::mock::MockSender
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::protocol::mock::MockSender
pub enum hyperdriver::client::conn::protocol::HttpProtocol
pub hyperdriver::client::conn::protocol::HttpProtocol::Http1
pub hyperdriver::client::conn::protocol::HttpProtocol::Http2
impl hyperdriver::client::conn::protocol::HttpProtocol
pub fn hyperdriver::client::conn::protocol::HttpProtocol::multiplex(&self) -> bool
pub fn hyperdriver::client::conn::protocol::HttpProtocol::version(&self) -> http::version::Version
impl core::clone::Clone for hyperdriver::client::conn::protocol::HttpProtocol
pub fn hyperdriver::client::conn::protocol::HttpProtocol::clone(&self) -> hyperdriver::client::conn::protocol::HttpProtocol
impl core::cmp::Eq for hyperdriver::client::conn::protocol::HttpProtocol
impl core::cmp::PartialEq for hyperdriver::client::conn::protocol::HttpProtocol
pub fn hyperdriver::client::conn::protocol::HttpProtocol::eq(&self, other: &hyperdriver::client::conn::protocol::HttpProtocol) -> bool
impl core::convert::From<http::version::Version> for hyperdriver::client::conn::protocol::HttpProtocol
pub fn hyperdriver::client::conn::protocol::HttpProtocol::from(version: http::version::Version) -> Self
impl core::fmt::Debug for hyperdriver::client::conn::protocol::HttpProtocol
pub fn hyperdriver::client::conn::protocol::HttpProtocol::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for hyperdriver::client::conn::protocol::HttpProtocol
pub fn hyperdriver::client::conn::protocol::HttpProtocol::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::Copy for hyperdriver::client::conn::protocol::HttpProtocol
impl core::marker::StructuralPartialEq for hyperdriver::client::conn::protocol::HttpProtocol
impl core::marker::Freeze for hyperdriver::client::conn::protocol::HttpProtocol
impl core::marker::Send for hyperdriver::client::conn::protocol::HttpProtocol
impl core::marker::Sync for hyperdriver::client::conn::protocol::HttpProtocol
impl core::marker::Unpin for hyperdriver::client::conn::protocol::HttpProtocol
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::protocol::HttpProtocol
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::protocol::HttpProtocol
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::protocol::HttpProtocol where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::client::conn::protocol::HttpProtocol where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::conn::protocol::HttpProtocol::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::client::conn::protocol::HttpProtocol where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::conn::protocol::HttpProtocol::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::protocol::HttpProtocol where U: core::convert::From<T>
pub fn hyperdriver::client::conn::protocol::HttpProtocol::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::protocol::HttpProtocol where U: core::convert::Into<T>
pub type hyperdriver::client::conn::protocol::HttpProtocol::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::protocol::HttpProtocol::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::protocol::HttpProtocol where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::protocol::HttpProtocol::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::protocol::HttpProtocol::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::protocol::HttpProtocol where T: core::clone::Clone
pub type hyperdriver::client::conn::protocol::HttpProtocol::Owned = T
pub fn hyperdriver::client::conn::protocol::HttpProtocol::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::protocol::HttpProtocol::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::protocol::HttpProtocol where T: core::clone::Clone
pub fn hyperdriver::client::conn::protocol::HttpProtocol::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::protocol::HttpProtocol where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::protocol::HttpProtocol::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::protocol::HttpProtocol where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::HttpProtocol::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::protocol::HttpProtocol where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::HttpProtocol::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::protocol::HttpProtocol where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::protocol::HttpProtocol::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::protocol::HttpProtocol
pub fn hyperdriver::client::conn::protocol::HttpProtocol::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::protocol::HttpProtocol where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::HttpProtocol::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::protocol::HttpProtocol::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::protocol::HttpProtocol
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::protocol::HttpProtocol
#[non_exhaustive] pub struct hyperdriver::client::conn::protocol::ProtocolRequest<IO: hyperdriver::info::HasConnectionInfo, B>
pub hyperdriver::client::conn::protocol::ProtocolRequest::transport: IO
pub hyperdriver::client::conn::protocol::ProtocolRequest::version: hyperdriver::client::conn::protocol::HttpProtocol
impl tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<hyperdriver::client::conn::stream::mock::MockStream, hyperdriver::body::Body>> for hyperdriver::client::conn::protocol::mock::MockProtocol
pub type hyperdriver::client::conn::protocol::mock::MockProtocol::Error = hyperdriver::client::conn::connection::ConnectionError
pub type hyperdriver::client::conn::protocol::mock::MockProtocol::Future = core::future::ready::Ready<core::result::Result<hyperdriver::client::conn::protocol::mock::MockSender, hyperdriver::client::conn::connection::ConnectionError>>
pub type hyperdriver::client::conn::protocol::mock::MockProtocol::Response = hyperdriver::client::conn::protocol::mock::MockSender
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::call(&mut self, req: hyperdriver::client::conn::protocol::ProtocolRequest<hyperdriver::client::conn::stream::mock::MockStream, hyperdriver::body::Body>) -> Self::Future
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<E, IO, BIn> tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<IO, BIn>> for hyper::client::conn::http2::Builder<E> where E: hyper::rt::bounds::h2_client::Http2ClientConnExec<BIn, hyperdriver::bridge::io::TokioIo<IO>> + core::marker::Unpin + core::marker::Send + core::marker::Sync + core::clone::Clone + 'static, IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, BIn: http_body::Body + core::marker::Unpin + core::marker::Send + 'static, <BIn as http_body::Body>::Data: core::marker::Send, <BIn as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub type hyper::client::conn::http2::Builder<E>::Error = hyperdriver::client::conn::connection::ConnectionError
pub type hyper::client::conn::http2::Builder<E>::Future = core::pin::Pin<alloc::boxed::Box<(dyn core::future::future::Future<Output = core::result::Result<hyperdriver::client::conn::connection::HttpConnection<BIn>, hyperdriver::client::conn::connection::ConnectionError>> + core::marker::Send)>>
pub type hyper::client::conn::http2::Builder<E>::Response = hyperdriver::client::conn::connection::HttpConnection<BIn>
pub fn hyper::client::conn::http2::Builder<E>::call(&mut self, req: hyperdriver::client::conn::protocol::ProtocolRequest<IO, BIn>) -> Self::Future
pub fn hyper::client::conn::http2::Builder<E>::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<IO, B> tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>> for hyper::client::conn::http1::Builder where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, B: http_body::Body + core::marker::Unpin + core::marker::Send + 'static, <B as http_body::Body>::Data: core::marker::Send, <B as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub type hyper::client::conn::http1::Builder::Error = hyperdriver::client::conn::connection::ConnectionError
pub type hyper::client::conn::http1::Builder::Future = core::pin::Pin<alloc::boxed::Box<(dyn core::future::future::Future<Output = core::result::Result<hyperdriver::client::conn::connection::HttpConnection<B>, hyperdriver::client::conn::connection::ConnectionError>> + core::marker::Send)>>
pub type hyper::client::conn::http1::Builder::Response = hyperdriver::client::conn::connection::HttpConnection<B>
pub fn hyper::client::conn::http1::Builder::call(&mut self, req: hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>) -> Self::Future
pub fn hyper::client::conn::http1::Builder::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<IO, B> tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>> for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where IO: hyperdriver::info::tls::HasTlsConnectionInfo + hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Send + core::marker::Sync, B: http_body::Body + core::marker::Unpin + core::marker::Send + 'static, <B as http_body::Body>::Data: core::marker::Send, <B as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub type hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::Error = hyperdriver::client::conn::connection::ConnectionError
pub type hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::Future = HttpConnectFuture<IO, B>
pub type hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::Response = hyperdriver::client::conn::connection::HttpConnection<B>
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::call(&mut self, req: hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>) -> Self::Future
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<IO: core::fmt::Debug + hyperdriver::info::HasConnectionInfo, B: core::fmt::Debug> core::fmt::Debug for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<IO, B> core::marker::Freeze for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where IO: core::marker::Freeze
impl<IO, B> core::marker::Send for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where IO: core::marker::Send
impl<IO, B> core::marker::Sync for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where IO: core::marker::Sync
impl<IO, B> core::marker::Unpin for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where IO: core::marker::Unpin
impl<IO, B> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where IO: core::panic::unwind_safe::RefUnwindSafe
impl<IO, B> core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where IO: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>
pub trait hyperdriver::client::conn::protocol::Protocol<IO, B> where IO: hyperdriver::info::HasConnectionInfo, Self: tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>, Response = Self::Connection>
pub type hyperdriver::client::conn::protocol::Protocol::Connection: hyperdriver::client::conn::connection::Connection<B>
pub type hyperdriver::client::conn::protocol::Protocol::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::client::conn::protocol::Protocol::Future: core::future::future::Future<Output = core::result::Result<Self::Connection, <Self as hyperdriver::client::conn::protocol::Protocol<IO, B>>::Error>> + core::marker::Send + 'static
pub fn hyperdriver::client::conn::protocol::Protocol::connect(&mut self, transport: IO, version: hyperdriver::client::conn::protocol::HttpProtocol) -> <Self as hyperdriver::client::conn::protocol::Protocol<IO, B>>::Future
pub fn hyperdriver::client::conn::protocol::Protocol::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <Self as hyperdriver::client::conn::protocol::Protocol<IO, B>>::Error>>
impl<T, C, IO, B> hyperdriver::client::conn::protocol::Protocol<IO, B> for T where IO: hyperdriver::info::HasConnectionInfo, T: tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>, Response = C> + core::marker::Send + 'static, <T as tower_service::Service>::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static, <T as tower_service::Service>::Future: core::marker::Send + 'static, C: hyperdriver::client::conn::connection::Connection<B>
pub type T::Connection = C
pub type T::Error = <T as tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>>>::Error
pub type T::Future = <T as tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>>>::Future
pub fn T::connect(&mut self, transport: IO, version: hyperdriver::client::conn::protocol::HttpProtocol) -> <Self as hyperdriver::client::conn::protocol::Protocol<IO, B>>::Future
pub fn T::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <Self as hyperdriver::client::conn::protocol::Protocol<IO, B>>::Error>>
pub mod hyperdriver::client::conn::stream
pub mod hyperdriver::client::conn::stream::mock
pub struct hyperdriver::client::conn::stream::mock::MockAddress
impl core::clone::Clone for hyperdriver::client::conn::stream::mock::MockAddress
pub fn hyperdriver::client::conn::stream::mock::MockAddress::clone(&self) -> hyperdriver::client::conn::stream::mock::MockAddress
impl core::cmp::Eq for hyperdriver::client::conn::stream::mock::MockAddress
impl core::cmp::PartialEq for hyperdriver::client::conn::stream::mock::MockAddress
pub fn hyperdriver::client::conn::stream::mock::MockAddress::eq(&self, other: &hyperdriver::client::conn::stream::mock::MockAddress) -> bool
impl core::default::Default for hyperdriver::client::conn::stream::mock::MockAddress
pub fn hyperdriver::client::conn::stream::mock::MockAddress::default() -> hyperdriver::client::conn::stream::mock::MockAddress
impl core::fmt::Debug for hyperdriver::client::conn::stream::mock::MockAddress
pub fn hyperdriver::client::conn::stream::mock::MockAddress::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::client::conn::stream::mock::MockAddress
pub fn hyperdriver::client::conn::stream::mock::MockAddress::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::StructuralPartialEq for hyperdriver::client::conn::stream::mock::MockAddress
impl core::marker::Freeze for hyperdriver::client::conn::stream::mock::MockAddress
impl core::marker::Send for hyperdriver::client::conn::stream::mock::MockAddress
impl core::marker::Sync for hyperdriver::client::conn::stream::mock::MockAddress
impl core::marker::Unpin for hyperdriver::client::conn::stream::mock::MockAddress
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::stream::mock::MockAddress
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::stream::mock::MockAddress
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::stream::mock::MockAddress where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::client::conn::stream::mock::MockAddress where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::MockAddress::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::client::conn::stream::mock::MockAddress where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::MockAddress::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::stream::mock::MockAddress where U: core::convert::From<T>
pub fn hyperdriver::client::conn::stream::mock::MockAddress::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::stream::mock::MockAddress where U: core::convert::Into<T>
pub type hyperdriver::client::conn::stream::mock::MockAddress::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::stream::mock::MockAddress::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::stream::mock::MockAddress where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::stream::mock::MockAddress::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::stream::mock::MockAddress::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::stream::mock::MockAddress where T: core::clone::Clone
pub type hyperdriver::client::conn::stream::mock::MockAddress::Owned = T
pub fn hyperdriver::client::conn::stream::mock::MockAddress::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::stream::mock::MockAddress::to_owned(&self) -> T
impl<T> alloc::string::ToString for hyperdriver::client::conn::stream::mock::MockAddress where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::MockAddress::to_string(&self) -> alloc::string::String
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::stream::mock::MockAddress where T: core::clone::Clone
pub fn hyperdriver::client::conn::stream::mock::MockAddress::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::stream::mock::MockAddress where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::MockAddress::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::stream::mock::MockAddress where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::MockAddress::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::stream::mock::MockAddress where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::MockAddress::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::stream::mock::MockAddress where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::stream::mock::MockAddress::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::stream::mock::MockAddress
pub fn hyperdriver::client::conn::stream::mock::MockAddress::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::client::conn::stream::mock::MockAddress where T: core::fmt::Display
pub fn hyperdriver::client::conn::stream::mock::MockAddress::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::stream::mock::MockAddress where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::MockAddress::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::stream::mock::MockAddress::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::stream::mock::MockAddress
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::stream::mock::MockAddress
pub struct hyperdriver::client::conn::stream::mock::MockStream
impl hyperdriver::client::conn::stream::mock::MockStream
pub fn hyperdriver::client::conn::stream::mock::MockStream::close(&self)
pub fn hyperdriver::client::conn::stream::mock::MockStream::id(&self) -> hyperdriver::client::conn::stream::mock::StreamID
pub fn hyperdriver::client::conn::stream::mock::MockStream::is_open(&self) -> bool
pub fn hyperdriver::client::conn::stream::mock::MockStream::new(reuse: bool) -> Self
pub fn hyperdriver::client::conn::stream::mock::MockStream::reusable() -> Self
pub fn hyperdriver::client::conn::stream::mock::MockStream::single() -> Self
impl core::clone::Clone for hyperdriver::client::conn::stream::mock::MockStream
pub fn hyperdriver::client::conn::stream::mock::MockStream::clone(&self) -> hyperdriver::client::conn::stream::mock::MockStream
impl core::fmt::Debug for hyperdriver::client::conn::stream::mock::MockStream
pub fn hyperdriver::client::conn::stream::mock::MockStream::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl hyperdriver::client::pool::PoolableStream for hyperdriver::client::conn::stream::mock::MockStream
pub fn hyperdriver::client::conn::stream::mock::MockStream::can_share(&self) -> bool
impl hyperdriver::info::HasConnectionInfo for hyperdriver::client::conn::stream::mock::MockStream
pub type hyperdriver::client::conn::stream::mock::MockStream::Addr = hyperdriver::client::conn::stream::mock::MockAddress
pub fn hyperdriver::client::conn::stream::mock::MockStream::info(&self) -> hyperdriver::info::ConnectionInfo<Self::Addr>
impl core::marker::Freeze for hyperdriver::client::conn::stream::mock::MockStream
impl core::marker::Send for hyperdriver::client::conn::stream::mock::MockStream
impl core::marker::Sync for hyperdriver::client::conn::stream::mock::MockStream
impl core::marker::Unpin for hyperdriver::client::conn::stream::mock::MockStream
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::stream::mock::MockStream
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::stream::mock::MockStream
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::stream::mock::MockStream where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::stream::mock::MockStream where U: core::convert::From<T>
pub fn hyperdriver::client::conn::stream::mock::MockStream::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::stream::mock::MockStream where U: core::convert::Into<T>
pub type hyperdriver::client::conn::stream::mock::MockStream::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::stream::mock::MockStream::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::stream::mock::MockStream where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::stream::mock::MockStream::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::stream::mock::MockStream::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::stream::mock::MockStream where T: core::clone::Clone
pub type hyperdriver::client::conn::stream::mock::MockStream::Owned = T
pub fn hyperdriver::client::conn::stream::mock::MockStream::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::stream::mock::MockStream::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::stream::mock::MockStream where T: core::clone::Clone
pub fn hyperdriver::client::conn::stream::mock::MockStream::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::stream::mock::MockStream where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::MockStream::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::stream::mock::MockStream where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::MockStream::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::stream::mock::MockStream where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::MockStream::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::stream::mock::MockStream where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::stream::mock::MockStream::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::stream::mock::MockStream
pub fn hyperdriver::client::conn::stream::mock::MockStream::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::stream::mock::MockStream where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::MockStream::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::stream::mock::MockStream::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::stream::mock::MockStream
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::stream::mock::MockStream
pub struct hyperdriver::client::conn::stream::mock::MockTls<IO>
impl<IO> hyperdriver::client::conn::stream::mock::MockTls<IO>
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::new(inner: IO, info: hyperdriver::info::tls::TlsConnectionInfo) -> Self
impl<'pin, IO> core::marker::Unpin for hyperdriver::client::conn::stream::mock::MockTls<IO> where __MockTls<'pin, IO>: core::marker::Unpin
impl<IO: core::fmt::Debug> core::fmt::Debug for hyperdriver::client::conn::stream::mock::MockTls<IO>
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<IO> core::ops::deref::Deref for hyperdriver::client::conn::stream::mock::MockTls<IO>
pub type hyperdriver::client::conn::stream::mock::MockTls<IO>::Target = IO
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::deref(&self) -> &Self::Target
impl<IO> core::ops::deref::DerefMut for hyperdriver::client::conn::stream::mock::MockTls<IO>
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::deref_mut(&mut self) -> &mut Self::Target
impl<IO> hyperdriver::info::HasConnectionInfo for hyperdriver::client::conn::stream::mock::MockTls<IO> where IO: hyperdriver::info::HasConnectionInfo
pub type hyperdriver::client::conn::stream::mock::MockTls<IO>::Addr = <IO as hyperdriver::info::HasConnectionInfo>::Addr
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::info(&self) -> hyperdriver::info::ConnectionInfo<Self::Addr>
impl<IO> hyperdriver::info::tls::HasTlsConnectionInfo for hyperdriver::client::conn::stream::mock::MockTls<IO> where IO: hyperdriver::info::HasConnectionInfo
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::tls_info(&self) -> core::option::Option<&hyperdriver::info::tls::TlsConnectionInfo>
impl<IO> hyperdriver::stream::tls::TlsHandshakeStream for hyperdriver::client::conn::stream::mock::MockTls<IO> where IO: hyperdriver::stream::tls::TlsHandshakeStream
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::poll_handshake(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
impl<IO> tokio::io::async_read::AsyncRead for hyperdriver::client::conn::stream::mock::MockTls<IO> where IO: tokio::io::async_read::AsyncRead
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &mut tokio::io::read_buf::ReadBuf<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
impl<IO> tokio::io::async_write::AsyncWrite for hyperdriver::client::conn::stream::mock::MockTls<IO> where IO: tokio::io::async_write::AsyncWrite
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
impl<IO> core::marker::Freeze for hyperdriver::client::conn::stream::mock::MockTls<IO> where IO: core::marker::Freeze
impl<IO> core::marker::Send for hyperdriver::client::conn::stream::mock::MockTls<IO> where IO: core::marker::Send
impl<IO> core::marker::Sync for hyperdriver::client::conn::stream::mock::MockTls<IO> where IO: core::marker::Sync
impl<IO> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::stream::mock::MockTls<IO> where IO: core::panic::unwind_safe::RefUnwindSafe
impl<IO> core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::stream::mock::MockTls<IO> where IO: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::stream::mock::MockTls<IO> where B: http_body::Body
impl<R> tokio::io::util::async_read_ext::AsyncReadExt for hyperdriver::client::conn::stream::mock::MockTls<IO> where R: tokio::io::async_read::AsyncRead + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::stream::mock::MockTls<IO> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::stream::mock::MockTls<IO> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::stream::mock::MockTls<IO>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::stream::mock::MockTls<IO> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::stream::mock::MockTls<IO>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::client::conn::stream::mock::MockTls<IO> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::stream::mock::MockTls<IO> where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::stream::mock::MockTls<IO> where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::stream::mock::MockTls<IO>
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::from(t: T) -> T
impl<T> hyperdriver::stream::tls::TlsHandshakeExt for hyperdriver::client::conn::stream::mock::MockTls<IO> where T: hyperdriver::stream::tls::TlsHandshakeStream
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::stream::mock::MockTls<IO> where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::stream::mock::MockTls<IO>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::stream::mock::MockTls<IO>
impl<W> tokio::io::util::async_write_ext::AsyncWriteExt for hyperdriver::client::conn::stream::mock::MockTls<IO> where W: tokio::io::async_write::AsyncWrite + core::marker::Sized
pub struct hyperdriver::client::conn::stream::mock::StreamID(_)
impl hyperdriver::client::conn::stream::mock::StreamID
pub fn hyperdriver::client::conn::stream::mock::StreamID::new() -> Self
impl core::clone::Clone for hyperdriver::client::conn::stream::mock::StreamID
pub fn hyperdriver::client::conn::stream::mock::StreamID::clone(&self) -> hyperdriver::client::conn::stream::mock::StreamID
impl core::cmp::Eq for hyperdriver::client::conn::stream::mock::StreamID
impl core::cmp::PartialEq for hyperdriver::client::conn::stream::mock::StreamID
pub fn hyperdriver::client::conn::stream::mock::StreamID::eq(&self, other: &hyperdriver::client::conn::stream::mock::StreamID) -> bool
impl core::default::Default for hyperdriver::client::conn::stream::mock::StreamID
pub fn hyperdriver::client::conn::stream::mock::StreamID::default() -> Self
impl core::fmt::Debug for hyperdriver::client::conn::stream::mock::StreamID
pub fn hyperdriver::client::conn::stream::mock::StreamID::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::client::conn::stream::mock::StreamID
pub fn hyperdriver::client::conn::stream::mock::StreamID::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for hyperdriver::client::conn::stream::mock::StreamID
pub fn hyperdriver::client::conn::stream::mock::StreamID::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::Copy for hyperdriver::client::conn::stream::mock::StreamID
impl core::marker::StructuralPartialEq for hyperdriver::client::conn::stream::mock::StreamID
impl core::marker::Freeze for hyperdriver::client::conn::stream::mock::StreamID
impl core::marker::Send for hyperdriver::client::conn::stream::mock::StreamID
impl core::marker::Sync for hyperdriver::client::conn::stream::mock::StreamID
impl core::marker::Unpin for hyperdriver::client::conn::stream::mock::StreamID
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::stream::mock::StreamID
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::stream::mock::StreamID
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::stream::mock::StreamID where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::client::conn::stream::mock::StreamID where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::StreamID::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::client::conn::stream::mock::StreamID where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::StreamID::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::stream::mock::StreamID where U: core::convert::From<T>
pub fn hyperdriver::client::conn::stream::mock::StreamID::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::stream::mock::StreamID where U: core::convert::Into<T>
pub type hyperdriver::client::conn::stream::mock::StreamID::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::stream::mock::StreamID::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::stream::mock::StreamID where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::stream::mock::StreamID::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::stream::mock::StreamID::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::stream::mock::StreamID where T: core::clone::Clone
pub type hyperdriver::client::conn::stream::mock::StreamID::Owned = T
pub fn hyperdriver::client::conn::stream::mock::StreamID::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::stream::mock::StreamID::to_owned(&self) -> T
impl<T> alloc::string::ToString for hyperdriver::client::conn::stream::mock::StreamID where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::StreamID::to_string(&self) -> alloc::string::String
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::stream::mock::StreamID where T: core::clone::Clone
pub fn hyperdriver::client::conn::stream::mock::StreamID::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::stream::mock::StreamID where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::StreamID::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::stream::mock::StreamID where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::StreamID::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::stream::mock::StreamID where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::StreamID::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::stream::mock::StreamID where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::stream::mock::StreamID::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::stream::mock::StreamID
pub fn hyperdriver::client::conn::stream::mock::StreamID::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::client::conn::stream::mock::StreamID where T: core::fmt::Display
pub fn hyperdriver::client::conn::stream::mock::StreamID::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::stream::mock::StreamID where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::mock::StreamID::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::stream::mock::StreamID::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::stream::mock::StreamID
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::stream::mock::StreamID
pub struct hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo
impl hyperdriver::client::conn::stream::Stream
pub async fn hyperdriver::client::conn::stream::Stream::connect(addr: impl core::convert::Into<core::net::socket_addr::SocketAddr>) -> std::io::error::Result<Self>
impl<IO> hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub fn hyperdriver::client::conn::stream::Stream<IO>::tls(self, domain: &str, config: alloc::sync::Arc<rustls::client::client_conn::ClientConfig>) -> Self
impl<IO> hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo
pub fn hyperdriver::client::conn::stream::Stream<IO>::map<F, T>(self, f: F) -> hyperdriver::client::conn::stream::Stream<T> where F: core::ops::function::FnOnce(IO) -> T, T: hyperdriver::info::HasConnectionInfo
pub fn hyperdriver::client::conn::stream::Stream<IO>::new(inner: IO) -> Self
impl core::convert::From<hyperdriver::stream::duplex::DuplexStream> for hyperdriver::client::conn::stream::Stream
pub fn hyperdriver::client::conn::stream::Stream::from(stream: hyperdriver::stream::duplex::DuplexStream) -> Self
impl core::convert::From<hyperdriver::stream::tcp::TcpStream> for hyperdriver::client::conn::stream::Stream
pub fn hyperdriver::client::conn::stream::Stream::from(stream: hyperdriver::stream::tcp::TcpStream) -> Self
impl core::convert::From<hyperdriver::stream::unix::UnixStream> for hyperdriver::client::conn::stream::Stream
pub fn hyperdriver::client::conn::stream::Stream::from(stream: hyperdriver::stream::unix::UnixStream) -> Self
impl<'pin, IO> core::marker::Unpin for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo, __Stream<'pin, IO>: core::marker::Unpin
impl<IO> core::fmt::Debug for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + core::fmt::Debug
pub fn hyperdriver::client::conn::stream::Stream<IO>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<IO> hyperdriver::client::pool::PoolableStream for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + core::marker::Unpin + core::marker::Send + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send + core::marker::Unpin + core::clone::Clone
pub fn hyperdriver::client::conn::stream::Stream<IO>::can_share(&self) -> bool
impl<IO> hyperdriver::info::HasConnectionInfo for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin + core::clone::Clone
pub type hyperdriver::client::conn::stream::Stream<IO>::Addr = <IO as hyperdriver::info::HasConnectionInfo>::Addr
pub fn hyperdriver::client::conn::stream::Stream<IO>::info(&self) -> hyperdriver::info::ConnectionInfo<<IO as hyperdriver::info::HasConnectionInfo>::Addr>
impl<IO> hyperdriver::info::tls::HasTlsConnectionInfo for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin + core::clone::Clone
pub fn hyperdriver::client::conn::stream::Stream<IO>::tls_info(&self) -> core::option::Option<&hyperdriver::info::tls::TlsConnectionInfo>
impl<IO> hyperdriver::stream::tls::TlsHandshakeStream for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send + core::marker::Unpin + core::clone::Clone
pub fn hyperdriver::client::conn::stream::Stream<IO>::poll_handshake(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
impl<IO> tokio::io::async_read::AsyncRead for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin
pub fn hyperdriver::client::conn::stream::Stream<IO>::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &mut tokio::io::read_buf::ReadBuf<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
impl<IO> tokio::io::async_write::AsyncWrite for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin
pub fn hyperdriver::client::conn::stream::Stream<IO>::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::client::conn::stream::Stream<IO>::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::client::conn::stream::Stream<IO>::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
impl<IO> core::marker::Freeze for hyperdriver::client::conn::stream::Stream<IO> where IO: core::marker::Freeze, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Freeze
impl<IO> core::marker::Send for hyperdriver::client::conn::stream::Stream<IO> where IO: core::marker::Send
impl<IO> core::marker::Sync for hyperdriver::client::conn::stream::Stream<IO> where IO: core::marker::Sync, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Sync
impl<IO> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::stream::Stream<IO>
impl<IO> !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::stream::Stream<IO>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::stream::Stream<IO> where B: http_body::Body
impl<R> tokio::io::util::async_read_ext::AsyncReadExt for hyperdriver::client::conn::stream::Stream<IO> where R: tokio::io::async_read::AsyncRead + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::stream::Stream<IO> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::stream::Stream<IO>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::stream::Stream<IO> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::stream::Stream<IO>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::stream::Stream<IO>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::stream::Stream<IO> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::stream::Stream<IO>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::stream::Stream<IO>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::client::conn::stream::Stream<IO> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::stream::Stream<IO>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::stream::Stream<IO> where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::Stream<IO>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::stream::Stream<IO> where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::Stream<IO>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::stream::Stream<IO>
pub fn hyperdriver::client::conn::stream::Stream<IO>::from(t: T) -> T
impl<T> hyperdriver::stream::tls::TlsHandshakeExt for hyperdriver::client::conn::stream::Stream<IO> where T: hyperdriver::stream::tls::TlsHandshakeStream
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::stream::Stream<IO> where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::Stream<IO>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::stream::Stream<IO>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::stream::Stream<IO>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::stream::Stream<IO>
impl<W> tokio::io::util::async_write_ext::AsyncWriteExt for hyperdriver::client::conn::stream::Stream<IO> where W: tokio::io::async_write::AsyncWrite + core::marker::Sized
pub struct hyperdriver::client::conn::stream::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo
impl hyperdriver::client::conn::stream::TlsStream<hyperdriver::stream::tcp::TcpStream>
pub async fn hyperdriver::client::conn::stream::TlsStream<hyperdriver::stream::tcp::TcpStream>::connect(addr: impl tokio::net::addr::ToSocketAddrs, domain: &str, config: alloc::sync::Arc<rustls::client::client_conn::ClientConfig>) -> std::io::error::Result<Self>
impl<IO> hyperdriver::client::conn::stream::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::new(stream: IO, domain: &str, config: alloc::sync::Arc<rustls::client::client_conn::ClientConfig>) -> Self
impl<IO> core::convert::From<tokio_rustls::Connect<IO>> for hyperdriver::client::conn::stream::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::from(accept: tokio_rustls::Connect<IO>) -> Self
impl<IO> core::fmt::Debug for hyperdriver::client::conn::stream::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo + core::fmt::Debug, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::fmt::Debug
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<IO> hyperdriver::client::pool::PoolableStream for hyperdriver::client::conn::stream::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo + core::marker::Unpin + core::marker::Send + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Unpin + core::marker::Send
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::can_share(&self) -> bool
impl<IO> hyperdriver::info::HasConnectionInfo for hyperdriver::client::conn::stream::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub type hyperdriver::client::conn::stream::TlsStream<IO>::Addr = <IO as hyperdriver::info::HasConnectionInfo>::Addr
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::info(&self) -> hyperdriver::info::ConnectionInfo<Self::Addr>
impl<IO> hyperdriver::info::tls::HasTlsConnectionInfo for hyperdriver::client::conn::stream::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::tls_info(&self) -> core::option::Option<&hyperdriver::info::tls::TlsConnectionInfo>
impl<IO> hyperdriver::stream::tls::TlsHandshakeStream for hyperdriver::client::conn::stream::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send + core::marker::Unpin
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::poll_handshake(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
impl<IO> tokio::io::async_read::AsyncRead for hyperdriver::client::conn::stream::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &mut tokio::io::read_buf::ReadBuf<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
impl<IO> tokio::io::async_write::AsyncWrite for hyperdriver::client::conn::stream::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<std::io::error::Result<usize>>
impl<IO> core::marker::Freeze for hyperdriver::client::conn::stream::TlsStream<IO> where <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Freeze
impl<IO> core::marker::Send for hyperdriver::client::conn::stream::TlsStream<IO> where IO: core::marker::Send
impl<IO> core::marker::Sync for hyperdriver::client::conn::stream::TlsStream<IO> where <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Sync, IO: core::marker::Sync
impl<IO> core::marker::Unpin for hyperdriver::client::conn::stream::TlsStream<IO> where <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin
impl<IO> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::stream::TlsStream<IO>
impl<IO> !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::stream::TlsStream<IO>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::stream::TlsStream<IO> where B: http_body::Body
impl<R> tokio::io::util::async_read_ext::AsyncReadExt for hyperdriver::client::conn::stream::TlsStream<IO> where R: tokio::io::async_read::AsyncRead + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::stream::TlsStream<IO> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::stream::TlsStream<IO> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::stream::TlsStream<IO>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::stream::TlsStream<IO> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::stream::TlsStream<IO>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::client::conn::stream::TlsStream<IO> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::stream::TlsStream<IO> where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::stream::TlsStream<IO> where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::stream::TlsStream<IO>
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::from(t: T) -> T
impl<T> hyperdriver::stream::tls::TlsHandshakeExt for hyperdriver::client::conn::stream::TlsStream<IO> where T: hyperdriver::stream::tls::TlsHandshakeStream
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::stream::TlsStream<IO> where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::stream::TlsStream<IO>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::stream::TlsStream<IO>
impl<W> tokio::io::util::async_write_ext::AsyncWriteExt for hyperdriver::client::conn::stream::TlsStream<IO> where W: tokio::io::async_write::AsyncWrite + core::marker::Sized
pub mod hyperdriver::client::conn::transport
pub mod hyperdriver::client::conn::transport::duplex
pub struct hyperdriver::client::conn::transport::duplex::DuplexTransport
impl hyperdriver::client::conn::transport::duplex::DuplexTransport
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::new(max_buf_size: usize, client: hyperdriver::stream::duplex::DuplexClient) -> Self
impl core::clone::Clone for hyperdriver::client::conn::transport::duplex::DuplexTransport
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::clone(&self) -> hyperdriver::client::conn::transport::duplex::DuplexTransport
impl core::fmt::Debug for hyperdriver::client::conn::transport::duplex::DuplexTransport
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl tower_service::Service<http::uri::Uri> for hyperdriver::client::conn::transport::duplex::DuplexTransport
pub type hyperdriver::client::conn::transport::duplex::DuplexTransport::Error = std::io::error::Error
pub type hyperdriver::client::conn::transport::duplex::DuplexTransport::Future = core::pin::Pin<alloc::boxed::Box<(dyn core::future::future::Future<Output = core::result::Result<hyperdriver::stream::duplex::DuplexStream, std::io::error::Error>> + core::marker::Send)>>
pub type hyperdriver::client::conn::transport::duplex::DuplexTransport::Response = hyperdriver::stream::duplex::DuplexStream
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::call(&mut self, _req: http::uri::Uri) -> Self::Future
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl core::marker::Freeze for hyperdriver::client::conn::transport::duplex::DuplexTransport
impl core::marker::Send for hyperdriver::client::conn::transport::duplex::DuplexTransport
impl core::marker::Sync for hyperdriver::client::conn::transport::duplex::DuplexTransport
impl core::marker::Unpin for hyperdriver::client::conn::transport::duplex::DuplexTransport
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::transport::duplex::DuplexTransport
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::transport::duplex::DuplexTransport
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::transport::duplex::DuplexTransport where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::client::conn::transport::duplex::DuplexTransport where S: tower_service::Service<R>
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, IO> hyperdriver::client::conn::transport::Transport for hyperdriver::client::conn::transport::duplex::DuplexTransport where T: tower_service::Service<http::uri::Uri, Response = IO> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, <T as tower_service::Service<http::uri::Uri>>::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static, <T as tower_service::Service<http::uri::Uri>>::Future: core::marker::Send + 'static, IO: hyperdriver::info::HasConnectionInfo + core::marker::Send + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send
pub type hyperdriver::client::conn::transport::duplex::DuplexTransport::Error = <T as tower_service::Service<http::uri::Uri>>::Error
pub type hyperdriver::client::conn::transport::duplex::DuplexTransport::Future = <T as tower_service::Service<http::uri::Uri>>::Future
pub type hyperdriver::client::conn::transport::duplex::DuplexTransport::IO = IO
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::connect(&mut self, uri: http::uri::Uri) -> <Self as tower_service::Service<http::uri::Uri>>::Future
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <Self as hyperdriver::client::conn::transport::Transport>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::transport::duplex::DuplexTransport where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::transport::duplex::DuplexTransport where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::transport::duplex::DuplexTransport where U: core::convert::From<T>
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::transport::duplex::DuplexTransport where U: core::convert::Into<T>
pub type hyperdriver::client::conn::transport::duplex::DuplexTransport::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::transport::duplex::DuplexTransport where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::transport::duplex::DuplexTransport::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::transport::duplex::DuplexTransport where T: core::clone::Clone
pub type hyperdriver::client::conn::transport::duplex::DuplexTransport::Owned = T
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::transport::duplex::DuplexTransport where T: core::clone::Clone
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::transport::duplex::DuplexTransport where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::transport::duplex::DuplexTransport where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::transport::duplex::DuplexTransport where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::transport::duplex::DuplexTransport where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::transport::duplex::DuplexTransport::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::transport::duplex::DuplexTransport
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::from(t: T) -> T
impl<T> hyperdriver::client::conn::transport::TransportExt for hyperdriver::client::conn::transport::duplex::DuplexTransport where T: hyperdriver::client::conn::transport::Transport
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::transport::duplex::DuplexTransport where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::transport::duplex::DuplexTransport::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::transport::duplex::DuplexTransport
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::transport::duplex::DuplexTransport
pub mod hyperdriver::client::conn::transport::mock
pub struct hyperdriver::client::conn::transport::mock::MockConnectionError
impl core::cmp::Eq for hyperdriver::client::conn::transport::mock::MockConnectionError
impl core::cmp::PartialEq for hyperdriver::client::conn::transport::mock::MockConnectionError
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::eq(&self, other: &hyperdriver::client::conn::transport::mock::MockConnectionError) -> bool
impl core::error::Error for hyperdriver::client::conn::transport::mock::MockConnectionError
impl core::fmt::Debug for hyperdriver::client::conn::transport::mock::MockConnectionError
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::client::conn::transport::mock::MockConnectionError
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::fmt(&self, __formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::StructuralPartialEq for hyperdriver::client::conn::transport::mock::MockConnectionError
impl core::marker::Freeze for hyperdriver::client::conn::transport::mock::MockConnectionError
impl core::marker::Send for hyperdriver::client::conn::transport::mock::MockConnectionError
impl core::marker::Sync for hyperdriver::client::conn::transport::mock::MockConnectionError
impl core::marker::Unpin for hyperdriver::client::conn::transport::mock::MockConnectionError
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::transport::mock::MockConnectionError
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::transport::mock::MockConnectionError
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::transport::mock::MockConnectionError where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::client::conn::transport::mock::MockConnectionError where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::client::conn::transport::mock::MockConnectionError where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::transport::mock::MockConnectionError where U: core::convert::From<T>
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::transport::mock::MockConnectionError where U: core::convert::Into<T>
pub type hyperdriver::client::conn::transport::mock::MockConnectionError::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::transport::mock::MockConnectionError where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::transport::mock::MockConnectionError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for hyperdriver::client::conn::transport::mock::MockConnectionError where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for hyperdriver::client::conn::transport::mock::MockConnectionError where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::transport::mock::MockConnectionError where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::transport::mock::MockConnectionError where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::transport::mock::MockConnectionError
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::client::conn::transport::mock::MockConnectionError where T: core::fmt::Display
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::transport::mock::MockConnectionError where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::transport::mock::MockConnectionError::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::transport::mock::MockConnectionError
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::transport::mock::MockConnectionError
pub struct hyperdriver::client::conn::transport::mock::MockTransport
impl hyperdriver::client::conn::transport::mock::MockTransport
pub fn hyperdriver::client::conn::transport::mock::MockTransport::channel(rx: tokio::sync::oneshot::Receiver<hyperdriver::client::conn::stream::mock::MockStream>) -> Self
pub fn hyperdriver::client::conn::transport::mock::MockTransport::connector(self, uri: http::uri::Uri, version: hyperdriver::client::conn::protocol::HttpProtocol) -> self::checkout::Connector<Self, hyperdriver::client::conn::protocol::mock::MockProtocol, hyperdriver::body::Body>
pub fn hyperdriver::client::conn::transport::mock::MockTransport::error() -> Self
pub fn hyperdriver::client::conn::transport::mock::MockTransport::new(reuse: bool) -> Self
pub fn hyperdriver::client::conn::transport::mock::MockTransport::reusable() -> Self
pub fn hyperdriver::client::conn::transport::mock::MockTransport::single() -> Self
impl core::clone::Clone for hyperdriver::client::conn::transport::mock::MockTransport
pub fn hyperdriver::client::conn::transport::mock::MockTransport::clone(&self) -> Self
impl core::fmt::Debug for hyperdriver::client::conn::transport::mock::MockTransport
pub fn hyperdriver::client::conn::transport::mock::MockTransport::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl tower_service::Service<http::uri::Uri> for hyperdriver::client::conn::transport::mock::MockTransport
pub type hyperdriver::client::conn::transport::mock::MockTransport::Error = hyperdriver::client::conn::transport::mock::MockConnectionError
pub type hyperdriver::client::conn::transport::mock::MockTransport::Future = core::pin::Pin<alloc::boxed::Box<(dyn core::future::future::Future<Output = core::result::Result<<hyperdriver::client::conn::transport::mock::MockTransport as tower_service::Service<http::uri::Uri>>::Response, <hyperdriver::client::conn::transport::mock::MockTransport as tower_service::Service<http::uri::Uri>>::Error>> + core::marker::Send)>>
pub type hyperdriver::client::conn::transport::mock::MockTransport::Response = hyperdriver::client::conn::stream::mock::MockStream
pub fn hyperdriver::client::conn::transport::mock::MockTransport::call(&mut self, _req: http::uri::Uri) -> Self::Future
pub fn hyperdriver::client::conn::transport::mock::MockTransport::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl core::marker::Freeze for hyperdriver::client::conn::transport::mock::MockTransport
impl core::marker::Send for hyperdriver::client::conn::transport::mock::MockTransport
impl core::marker::Sync for hyperdriver::client::conn::transport::mock::MockTransport
impl core::marker::Unpin for hyperdriver::client::conn::transport::mock::MockTransport
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::transport::mock::MockTransport
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::transport::mock::MockTransport
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::transport::mock::MockTransport where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::client::conn::transport::mock::MockTransport where S: tower_service::Service<R>
pub fn hyperdriver::client::conn::transport::mock::MockTransport::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::client::conn::transport::mock::MockTransport::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, IO> hyperdriver::client::conn::transport::Transport for hyperdriver::client::conn::transport::mock::MockTransport where T: tower_service::Service<http::uri::Uri, Response = IO> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, <T as tower_service::Service<http::uri::Uri>>::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static, <T as tower_service::Service<http::uri::Uri>>::Future: core::marker::Send + 'static, IO: hyperdriver::info::HasConnectionInfo + core::marker::Send + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send
pub type hyperdriver::client::conn::transport::mock::MockTransport::Error = <T as tower_service::Service<http::uri::Uri>>::Error
pub type hyperdriver::client::conn::transport::mock::MockTransport::Future = <T as tower_service::Service<http::uri::Uri>>::Future
pub type hyperdriver::client::conn::transport::mock::MockTransport::IO = IO
pub fn hyperdriver::client::conn::transport::mock::MockTransport::connect(&mut self, uri: http::uri::Uri) -> <Self as tower_service::Service<http::uri::Uri>>::Future
pub fn hyperdriver::client::conn::transport::mock::MockTransport::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <Self as hyperdriver::client::conn::transport::Transport>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::transport::mock::MockTransport where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::transport::mock::MockTransport where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::transport::mock::MockTransport where U: core::convert::From<T>
pub fn hyperdriver::client::conn::transport::mock::MockTransport::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::transport::mock::MockTransport where U: core::convert::Into<T>
pub type hyperdriver::client::conn::transport::mock::MockTransport::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::transport::mock::MockTransport::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::transport::mock::MockTransport where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::transport::mock::MockTransport::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::transport::mock::MockTransport::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::transport::mock::MockTransport where T: core::clone::Clone
pub type hyperdriver::client::conn::transport::mock::MockTransport::Owned = T
pub fn hyperdriver::client::conn::transport::mock::MockTransport::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::transport::mock::MockTransport::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::transport::mock::MockTransport where T: core::clone::Clone
pub fn hyperdriver::client::conn::transport::mock::MockTransport::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::transport::mock::MockTransport where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::transport::mock::MockTransport::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::transport::mock::MockTransport where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::mock::MockTransport::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::transport::mock::MockTransport where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::mock::MockTransport::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::transport::mock::MockTransport where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::transport::mock::MockTransport::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::transport::mock::MockTransport
pub fn hyperdriver::client::conn::transport::mock::MockTransport::from(t: T) -> T
impl<T> hyperdriver::client::conn::transport::TransportExt for hyperdriver::client::conn::transport::mock::MockTransport where T: hyperdriver::client::conn::transport::Transport
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::transport::mock::MockTransport where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::mock::MockTransport::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::transport::mock::MockTransport::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::transport::mock::MockTransport
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::transport::mock::MockTransport
pub mod hyperdriver::client::conn::transport::tcp
pub struct hyperdriver::client::conn::transport::tcp::InvalidUri
impl core::error::Error for hyperdriver::client::conn::transport::tcp::InvalidUri
impl core::fmt::Debug for hyperdriver::client::conn::transport::tcp::InvalidUri
pub fn hyperdriver::client::conn::transport::tcp::InvalidUri::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::client::conn::transport::tcp::InvalidUri
pub fn hyperdriver::client::conn::transport::tcp::InvalidUri::fmt(&self, __formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Freeze for hyperdriver::client::conn::transport::tcp::InvalidUri
impl core::marker::Send for hyperdriver::client::conn::transport::tcp::InvalidUri
impl core::marker::Sync for hyperdriver::client::conn::transport::tcp::InvalidUri
impl core::marker::Unpin for hyperdriver::client::conn::transport::tcp::InvalidUri
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::transport::tcp::InvalidUri
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::transport::tcp::InvalidUri
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::transport::tcp::InvalidUri where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::transport::tcp::InvalidUri where U: core::convert::From<T>
pub fn hyperdriver::client::conn::transport::tcp::InvalidUri::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::transport::tcp::InvalidUri where U: core::convert::Into<T>
pub type hyperdriver::client::conn::transport::tcp::InvalidUri::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::transport::tcp::InvalidUri::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::transport::tcp::InvalidUri where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::transport::tcp::InvalidUri::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::transport::tcp::InvalidUri::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for hyperdriver::client::conn::transport::tcp::InvalidUri where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::InvalidUri::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for hyperdriver::client::conn::transport::tcp::InvalidUri where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::InvalidUri::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::transport::tcp::InvalidUri where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::InvalidUri::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::transport::tcp::InvalidUri where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::InvalidUri::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::transport::tcp::InvalidUri
pub fn hyperdriver::client::conn::transport::tcp::InvalidUri::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::client::conn::transport::tcp::InvalidUri where T: core::fmt::Display
pub fn hyperdriver::client::conn::transport::tcp::InvalidUri::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::transport::tcp::InvalidUri where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::InvalidUri::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::transport::tcp::InvalidUri::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::transport::tcp::InvalidUri
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::transport::tcp::InvalidUri
pub struct hyperdriver::client::conn::transport::tcp::TcpConnectionError
impl core::convert::From<tokio::runtime::task::error::JoinError> for hyperdriver::client::conn::transport::tcp::TcpConnectionError
pub fn hyperdriver::client::conn::transport::tcp::TcpConnectionError::from(value: tokio::runtime::task::error::JoinError) -> Self
impl core::error::Error for hyperdriver::client::conn::transport::tcp::TcpConnectionError
pub fn hyperdriver::client::conn::transport::tcp::TcpConnectionError::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl core::fmt::Debug for hyperdriver::client::conn::transport::tcp::TcpConnectionError
pub fn hyperdriver::client::conn::transport::tcp::TcpConnectionError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::client::conn::transport::tcp::TcpConnectionError
pub fn hyperdriver::client::conn::transport::tcp::TcpConnectionError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Freeze for hyperdriver::client::conn::transport::tcp::TcpConnectionError
impl core::marker::Send for hyperdriver::client::conn::transport::tcp::TcpConnectionError
impl core::marker::Sync for hyperdriver::client::conn::transport::tcp::TcpConnectionError
impl core::marker::Unpin for hyperdriver::client::conn::transport::tcp::TcpConnectionError
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::transport::tcp::TcpConnectionError
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::transport::tcp::TcpConnectionError
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::transport::tcp::TcpConnectionError where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::transport::tcp::TcpConnectionError where U: core::convert::From<T>
pub fn hyperdriver::client::conn::transport::tcp::TcpConnectionError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::transport::tcp::TcpConnectionError where U: core::convert::Into<T>
pub type hyperdriver::client::conn::transport::tcp::TcpConnectionError::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::transport::tcp::TcpConnectionError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::transport::tcp::TcpConnectionError where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::transport::tcp::TcpConnectionError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::transport::tcp::TcpConnectionError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for hyperdriver::client::conn::transport::tcp::TcpConnectionError where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpConnectionError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for hyperdriver::client::conn::transport::tcp::TcpConnectionError where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpConnectionError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::transport::tcp::TcpConnectionError where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpConnectionError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::transport::tcp::TcpConnectionError where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpConnectionError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::transport::tcp::TcpConnectionError
pub fn hyperdriver::client::conn::transport::tcp::TcpConnectionError::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::client::conn::transport::tcp::TcpConnectionError where T: core::fmt::Display
pub fn hyperdriver::client::conn::transport::tcp::TcpConnectionError::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::transport::tcp::TcpConnectionError where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpConnectionError::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::transport::tcp::TcpConnectionError::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::transport::tcp::TcpConnectionError
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::transport::tcp::TcpConnectionError
pub struct hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>
impl hyperdriver::client::conn::transport::tcp::TcpTransport
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport::builder() -> hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<()>
impl<R, IO> hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::config(&self) -> &hyperdriver::client::conn::transport::tcp::TcpTransportConfig
impl<IO> core::default::Default for hyperdriver::client::conn::transport::tcp::TcpTransport<hyperdriver::client::conn::dns::GaiResolver, IO>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<hyperdriver::client::conn::dns::GaiResolver, IO>::default() -> Self
impl<R, IO> core::clone::Clone for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where R: core::clone::Clone
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::clone(&self) -> Self
impl<R, IO> tower_service::Service<http::uri::Uri> for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where R: tower_service::Service<alloc::boxed::Box<str>, Response = hyperdriver::client::conn::dns::SocketAddrs, Error = std::io::error::Error> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, <R as tower_service::Service>::Future: core::marker::Send, hyperdriver::stream::tcp::TcpStream: core::convert::Into<IO>, IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Unpin + core::marker::Send + 'static
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::Error = hyperdriver::client::conn::transport::tcp::TcpConnectionError
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::Future = core::pin::Pin<alloc::boxed::Box<(dyn core::future::future::Future<Output = core::result::Result<<hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> as tower_service::Service<http::uri::Uri>>::Response, <hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> as tower_service::Service<http::uri::Uri>>::Error>> + core::marker::Send)>>
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::Response = IO
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::call(&mut self, req: http::uri::Uri) -> Self::Future
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<R: core::fmt::Debug, IO: core::fmt::Debug> core::fmt::Debug for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<R, IO> core::marker::Freeze for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where R: core::marker::Freeze
impl<R, IO> core::marker::Send for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where R: core::marker::Send
impl<R, IO> core::marker::Sync for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where R: core::marker::Sync
impl<R, IO> core::marker::Unpin for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where R: core::marker::Unpin
impl<R, IO> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R, IO> core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where R: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where B: http_body::Body
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::Service = S
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::Service = S
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where S: tower_service::Service<R>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where T: core::clone::Clone
pub type hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::Owned = T
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where T: core::clone::Clone
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::from(t: T) -> T
impl<T> hyperdriver::client::conn::transport::TransportExt for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where T: hyperdriver::client::conn::transport::Transport
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>
pub struct hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>
impl<R> hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R> where R: tower_service::Service<alloc::boxed::Box<str>, Response = hyperdriver::client::conn::dns::SocketAddrs, Error = std::io::error::Error> + core::marker::Send + core::clone::Clone + 'static
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::build<IO>(self) -> hyperdriver::client::conn::transport::tcp::TcpTransport<R, IO>
impl<R> hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::config(&mut self) -> &mut hyperdriver::client::conn::transport::tcp::TcpTransportConfig
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::with_config(self, config: hyperdriver::client::conn::transport::tcp::TcpTransportConfig) -> Self
impl<R> hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::resolver(&mut self) -> &R
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::with_gai_resolver(self) -> hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<hyperdriver::client::conn::dns::GaiResolver>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::with_resolver<R2>(self, resolver: R2) -> hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R2>
impl<R: core::fmt::Debug> core::fmt::Debug for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<R> core::marker::Freeze for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R> where R: core::marker::Freeze
impl<R> core::marker::Send for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R> where R: core::marker::Send
impl<R> core::marker::Sync for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R> where R: core::marker::Unpin
impl<R> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R> core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R> where R: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::transport::tcp::TcpTransportBuilder<R>
#[non_exhaustive] pub struct hyperdriver::client::conn::transport::tcp::TcpTransportConfig
pub hyperdriver::client::conn::transport::tcp::TcpTransportConfig::connect_timeout: core::option::Option<core::time::Duration>
pub hyperdriver::client::conn::transport::tcp::TcpTransportConfig::happy_eyeballs_concurrency: core::option::Option<usize>
pub hyperdriver::client::conn::transport::tcp::TcpTransportConfig::happy_eyeballs_timeout: core::option::Option<core::time::Duration>
pub hyperdriver::client::conn::transport::tcp::TcpTransportConfig::keep_alive_timeout: core::option::Option<core::time::Duration>
pub hyperdriver::client::conn::transport::tcp::TcpTransportConfig::local_address_ipv4: core::option::Option<core::net::ip_addr::Ipv4Addr>
pub hyperdriver::client::conn::transport::tcp::TcpTransportConfig::local_address_ipv6: core::option::Option<core::net::ip_addr::Ipv6Addr>
pub hyperdriver::client::conn::transport::tcp::TcpTransportConfig::nodelay: bool
pub hyperdriver::client::conn::transport::tcp::TcpTransportConfig::recv_buffer_size: core::option::Option<usize>
pub hyperdriver::client::conn::transport::tcp::TcpTransportConfig::reuse_address: bool
pub hyperdriver::client::conn::transport::tcp::TcpTransportConfig::send_buffer_size: core::option::Option<usize>
impl core::clone::Clone for hyperdriver::client::conn::transport::tcp::TcpTransportConfig
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::clone(&self) -> hyperdriver::client::conn::transport::tcp::TcpTransportConfig
impl core::default::Default for hyperdriver::client::conn::transport::tcp::TcpTransportConfig
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::default() -> Self
impl core::fmt::Debug for hyperdriver::client::conn::transport::tcp::TcpTransportConfig
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Freeze for hyperdriver::client::conn::transport::tcp::TcpTransportConfig
impl core::marker::Send for hyperdriver::client::conn::transport::tcp::TcpTransportConfig
impl core::marker::Sync for hyperdriver::client::conn::transport::tcp::TcpTransportConfig
impl core::marker::Unpin for hyperdriver::client::conn::transport::tcp::TcpTransportConfig
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::transport::tcp::TcpTransportConfig
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::transport::tcp::TcpTransportConfig
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::transport::tcp::TcpTransportConfig where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::transport::tcp::TcpTransportConfig where U: core::convert::From<T>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::transport::tcp::TcpTransportConfig where U: core::convert::Into<T>
pub type hyperdriver::client::conn::transport::tcp::TcpTransportConfig::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::transport::tcp::TcpTransportConfig where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::transport::tcp::TcpTransportConfig::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::transport::tcp::TcpTransportConfig where T: core::clone::Clone
pub type hyperdriver::client::conn::transport::tcp::TcpTransportConfig::Owned = T
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::transport::tcp::TcpTransportConfig where T: core::clone::Clone
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::transport::tcp::TcpTransportConfig where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::transport::tcp::TcpTransportConfig where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::transport::tcp::TcpTransportConfig where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::transport::tcp::TcpTransportConfig where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::transport::tcp::TcpTransportConfig
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::transport::tcp::TcpTransportConfig where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::transport::tcp::TcpTransportConfig::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::transport::tcp::TcpTransportConfig
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::transport::tcp::TcpTransportConfig
pub mod hyperdriver::client::conn::transport::tls
pub struct hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>
impl<T> hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::config(&self) -> &alloc::sync::Arc<rustls::client::client_conn::ClientConfig>
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::into_parts(self) -> (T, alloc::sync::Arc<rustls::client::client_conn::ClientConfig>)
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::new(transport: T, config: alloc::sync::Arc<rustls::client::client_conn::ClientConfig>) -> Self
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::transport(&self) -> &T
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::transport_mut(&mut self) -> &mut T
impl<T: core::clone::Clone> core::clone::Clone for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::clone(&self) -> hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>
impl<T: core::fmt::Debug> core::fmt::Debug for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T> tower_service::Service<http::uri::Uri> for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where T: hyperdriver::client::conn::transport::Transport, <T as hyperdriver::client::conn::transport::Transport>::IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <<T as hyperdriver::client::conn::transport::Transport>::IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Send + core::marker::Unpin
pub type hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::Error = hyperdriver::client::conn::transport::TlsConnectionError<<T as hyperdriver::client::conn::transport::Transport>::Error>
pub type hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::Future = TlsConnectionFuture<T>
pub type hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::Response = hyperdriver::client::conn::stream::Stream<<T as hyperdriver::client::conn::transport::Transport>::IO>
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::call(&mut self, req: http::uri::Uri) -> Self::Future
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<T> core::marker::Freeze for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where T: core::marker::Freeze
impl<T> core::marker::Send for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where T: core::marker::Send
impl<T> core::marker::Sync for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where T: core::marker::Sync
impl<T> core::marker::Unpin for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where T: core::marker::Unpin
impl<T> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>
impl<T> !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where S: tower_service::Service<R>
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where T: core::clone::Clone
pub type hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::Owned = T
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where T: core::clone::Clone
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::from(t: T) -> T
impl<T> hyperdriver::client::conn::transport::TransportExt for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where T: hyperdriver::client::conn::transport::Transport
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::transport::tls::TlsTransportWrapper<T>
#[non_exhaustive] pub enum hyperdriver::client::conn::transport::TlsConnectionError<E>
pub hyperdriver::client::conn::transport::TlsConnectionError::Connection(E)
pub hyperdriver::client::conn::transport::TlsConnectionError::Handshake(std::io::error::Error)
pub hyperdriver::client::conn::transport::TlsConnectionError::NoDomain
pub hyperdriver::client::conn::transport::TlsConnectionError::TlsDisabled
impl<E: core::fmt::Debug> core::fmt::Debug for hyperdriver::client::conn::transport::TlsConnectionError<E>
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<E> core::convert::From<E> for hyperdriver::client::conn::transport::TlsConnectionError<E>
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::from(source: E) -> Self
impl<E> core::error::Error for hyperdriver::client::conn::transport::TlsConnectionError<E> where E: core::error::Error, Self: core::fmt::Debug + core::fmt::Display
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl<E> core::fmt::Display for hyperdriver::client::conn::transport::TlsConnectionError<E> where E: core::fmt::Display
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::fmt(&self, __formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<E> core::marker::Freeze for hyperdriver::client::conn::transport::TlsConnectionError<E> where E: core::marker::Freeze
impl<E> core::marker::Send for hyperdriver::client::conn::transport::TlsConnectionError<E> where E: core::marker::Send
impl<E> core::marker::Sync for hyperdriver::client::conn::transport::TlsConnectionError<E> where E: core::marker::Sync
impl<E> core::marker::Unpin for hyperdriver::client::conn::transport::TlsConnectionError<E> where E: core::marker::Unpin
impl<E> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::transport::TlsConnectionError<E>
impl<E> !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::transport::TlsConnectionError<E>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::transport::TlsConnectionError<E> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::transport::TlsConnectionError<E> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::transport::TlsConnectionError<E> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::transport::TlsConnectionError<E>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::transport::TlsConnectionError<E> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::transport::TlsConnectionError<E>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for hyperdriver::client::conn::transport::TlsConnectionError<E> where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for hyperdriver::client::conn::transport::TlsConnectionError<E> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::transport::TlsConnectionError<E> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::transport::TlsConnectionError<E> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::transport::TlsConnectionError<E>
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::from(t: T) -> T
impl<T> core::convert::From<never> for hyperdriver::client::conn::transport::TlsConnectionError<E>
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::from(t: never) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::client::conn::transport::TlsConnectionError<E> where T: core::fmt::Display
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::transport::TlsConnectionError<E> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::transport::TlsConnectionError<E>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::transport::TlsConnectionError<E>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::transport::TlsConnectionError<E>
pub struct hyperdriver::client::conn::transport::IntoStream<T>
impl<T> hyperdriver::client::conn::transport::IntoStream<T>
pub fn hyperdriver::client::conn::transport::IntoStream<T>::new(transport: T) -> Self
impl<T: core::clone::Clone> core::clone::Clone for hyperdriver::client::conn::transport::IntoStream<T>
pub fn hyperdriver::client::conn::transport::IntoStream<T>::clone(&self) -> hyperdriver::client::conn::transport::IntoStream<T>
impl<T: core::fmt::Debug> core::fmt::Debug for hyperdriver::client::conn::transport::IntoStream<T>
pub fn hyperdriver::client::conn::transport::IntoStream<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T> tower_service::Service<http::uri::Uri> for hyperdriver::client::conn::transport::IntoStream<T> where T: hyperdriver::client::conn::transport::Transport, <T as hyperdriver::client::conn::transport::Transport>::IO: core::convert::Into<hyperdriver::client::conn::stream::Stream> + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin + core::marker::Send + 'static, <<T as hyperdriver::client::conn::transport::Transport>::IO as hyperdriver::info::HasConnectionInfo>::Addr: core::convert::Into<hyperdriver::info::BraidAddr>
pub type hyperdriver::client::conn::transport::IntoStream<T>::Error = <T as hyperdriver::client::conn::transport::Transport>::Error
pub type hyperdriver::client::conn::transport::IntoStream<T>::Future = ConnectFuture<T>
pub type hyperdriver::client::conn::transport::IntoStream<T>::Response = hyperdriver::client::conn::stream::Stream
pub fn hyperdriver::client::conn::transport::IntoStream<T>::call(&mut self, req: http::uri::Uri) -> Self::Future
pub fn hyperdriver::client::conn::transport::IntoStream<T>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<T> core::marker::Freeze for hyperdriver::client::conn::transport::IntoStream<T> where T: core::marker::Freeze
impl<T> core::marker::Send for hyperdriver::client::conn::transport::IntoStream<T> where T: core::marker::Send
impl<T> core::marker::Sync for hyperdriver::client::conn::transport::IntoStream<T> where T: core::marker::Sync
impl<T> core::marker::Unpin for hyperdriver::client::conn::transport::IntoStream<T> where T: core::marker::Unpin
impl<T> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::transport::IntoStream<T> where T: core::panic::unwind_safe::RefUnwindSafe
impl<T> core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::transport::IntoStream<T> where T: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::transport::IntoStream<T> where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::client::conn::transport::IntoStream<T> where S: tower_service::Service<R>
pub fn hyperdriver::client::conn::transport::IntoStream<T>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::client::conn::transport::IntoStream<T>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::transport::IntoStream<T> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::transport::IntoStream<T> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::transport::IntoStream<T> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::transport::IntoStream<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::transport::IntoStream<T> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::transport::IntoStream<T>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::transport::IntoStream<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::transport::IntoStream<T> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::transport::IntoStream<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::transport::IntoStream<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::transport::IntoStream<T> where T: core::clone::Clone
pub type hyperdriver::client::conn::transport::IntoStream<T>::Owned = T
pub fn hyperdriver::client::conn::transport::IntoStream<T>::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::transport::IntoStream<T>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::transport::IntoStream<T> where T: core::clone::Clone
pub fn hyperdriver::client::conn::transport::IntoStream<T>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::transport::IntoStream<T> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::transport::IntoStream<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::transport::IntoStream<T> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::IntoStream<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::transport::IntoStream<T> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::IntoStream<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::transport::IntoStream<T> where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::transport::IntoStream<T>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::transport::IntoStream<T>
pub fn hyperdriver::client::conn::transport::IntoStream<T>::from(t: T) -> T
impl<T> hyperdriver::client::conn::transport::TransportExt for hyperdriver::client::conn::transport::IntoStream<T> where T: hyperdriver::client::conn::transport::Transport
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::transport::IntoStream<T> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::IntoStream<T>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::transport::IntoStream<T>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::transport::IntoStream<T>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::transport::IntoStream<T>
pub struct hyperdriver::client::conn::transport::TlsTransport<T>
impl<T> hyperdriver::client::conn::transport::TlsTransport<T>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::inner(&self) -> &T
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::inner_mut(&mut self) -> &mut T
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::into_inner(self) -> T
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::into_parts(self) -> (T, core::option::Option<alloc::sync::Arc<rustls::client::client_conn::ClientConfig>>)
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::new(transport: T) -> Self
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::tls_config(&self) -> core::option::Option<&alloc::sync::Arc<rustls::client::client_conn::ClientConfig>>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::with_default_tls(self) -> Self
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::with_tls(self, config: alloc::sync::Arc<rustls::client::client_conn::ClientConfig>) -> Self
impl<T: core::clone::Clone> core::clone::Clone for hyperdriver::client::conn::transport::TlsTransport<T>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::clone(&self) -> hyperdriver::client::conn::transport::TlsTransport<T>
impl<T: core::default::Default> core::default::Default for hyperdriver::client::conn::transport::TlsTransport<T>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::default() -> Self
impl<T: core::fmt::Debug> core::fmt::Debug for hyperdriver::client::conn::transport::TlsTransport<T>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T> tower_service::Service<http::uri::Uri> for hyperdriver::client::conn::transport::TlsTransport<T> where T: hyperdriver::client::conn::transport::Transport, <T as hyperdriver::client::conn::transport::Transport>::IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <<T as hyperdriver::client::conn::transport::Transport>::IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Send + core::marker::Unpin
pub type hyperdriver::client::conn::transport::TlsTransport<T>::Error = hyperdriver::client::conn::transport::TlsConnectionError<<T as hyperdriver::client::conn::transport::Transport>::Error>
pub type hyperdriver::client::conn::transport::TlsTransport<T>::Future = TransportBraidFuture<T>
pub type hyperdriver::client::conn::transport::TlsTransport<T>::Response = hyperdriver::client::conn::stream::Stream<<T as hyperdriver::client::conn::transport::Transport>::IO>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::call(&mut self, req: http::uri::Uri) -> Self::Future
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<T> core::marker::Freeze for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::marker::Freeze
impl<T> core::marker::Send for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::marker::Send
impl<T> core::marker::Sync for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::marker::Sync
impl<T> core::marker::Unpin for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::marker::Unpin
impl<T> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::transport::TlsTransport<T>
impl<T> !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::transport::TlsTransport<T>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::transport::TlsTransport<T> where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::client::conn::transport::TlsTransport<T> where S: tower_service::Service<R>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::transport::TlsTransport<T> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::transport::TlsTransport<T> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::transport::TlsTransport<T> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::transport::TlsTransport<T> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::transport::TlsTransport<T>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::transport::TlsTransport<T> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::transport::TlsTransport<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::clone::Clone
pub type hyperdriver::client::conn::transport::TlsTransport<T>::Owned = T
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::clone::Clone
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::transport::TlsTransport<T> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::transport::TlsTransport<T>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::transport::TlsTransport<T>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::from(t: T) -> T
impl<T> hyperdriver::client::conn::transport::TransportExt for hyperdriver::client::conn::transport::TlsTransport<T> where T: hyperdriver::client::conn::transport::Transport
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::transport::TlsTransport<T>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::transport::TlsTransport<T>
pub trait hyperdriver::client::conn::transport::Transport: core::clone::Clone + core::marker::Send
pub type hyperdriver::client::conn::transport::Transport::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::client::conn::transport::Transport::Future: core::future::future::Future<Output = core::result::Result<Self::IO, <Self as hyperdriver::client::conn::transport::Transport>::Error>> + core::marker::Send + 'static
pub type hyperdriver::client::conn::transport::Transport::IO: hyperdriver::info::HasConnectionInfo + core::marker::Send + 'static
pub fn hyperdriver::client::conn::transport::Transport::connect(&mut self, uri: http::uri::Uri) -> <Self as hyperdriver::client::conn::transport::Transport>::Future
pub fn hyperdriver::client::conn::transport::Transport::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <Self as hyperdriver::client::conn::transport::Transport>::Error>>
impl<T, IO> hyperdriver::client::conn::transport::Transport for T where T: tower_service::Service<http::uri::Uri, Response = IO> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, <T as tower_service::Service>::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static, <T as tower_service::Service>::Future: core::marker::Send + 'static, IO: hyperdriver::info::HasConnectionInfo + core::marker::Send + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send
pub type T::Error = <T as tower_service::Service<http::uri::Uri>>::Error
pub type T::Future = <T as tower_service::Service<http::uri::Uri>>::Future
pub type T::IO = IO
pub fn T::connect(&mut self, uri: http::uri::Uri) -> <Self as tower_service::Service<http::uri::Uri>>::Future
pub fn T::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <Self as hyperdriver::client::conn::transport::Transport>::Error>>
pub trait hyperdriver::client::conn::transport::TransportExt: hyperdriver::client::conn::transport::Transport
pub fn hyperdriver::client::conn::transport::TransportExt::into_stream(self) -> hyperdriver::client::conn::transport::IntoStream<Self> where Self::IO: core::convert::Into<hyperdriver::client::conn::stream::Stream> + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin + core::marker::Send + 'static, <<Self as hyperdriver::client::conn::transport::Transport>::IO as hyperdriver::info::HasConnectionInfo>::Addr: core::convert::Into<hyperdriver::info::BraidAddr>
pub fn hyperdriver::client::conn::transport::TransportExt::with_default_tls(self) -> hyperdriver::client::conn::transport::TlsTransport<Self> where Self: core::marker::Sized
pub fn hyperdriver::client::conn::transport::TransportExt::with_optional_tls(self, config: core::option::Option<alloc::sync::Arc<rustls::client::client_conn::ClientConfig>>) -> hyperdriver::client::conn::transport::TlsTransport<Self> where Self: core::marker::Sized
pub fn hyperdriver::client::conn::transport::TransportExt::with_tls(self, config: alloc::sync::Arc<rustls::client::client_conn::ClientConfig>) -> hyperdriver::client::conn::transport::TlsTransport<Self> where Self: core::marker::Sized
pub fn hyperdriver::client::conn::transport::TransportExt::without_tls(self) -> hyperdriver::client::conn::transport::TlsTransport<Self> where Self: core::marker::Sized
impl<T> hyperdriver::client::conn::transport::TransportExt for T where T: hyperdriver::client::conn::transport::Transport
#[non_exhaustive] pub struct hyperdriver::client::conn::ProtocolRequest<IO: hyperdriver::info::HasConnectionInfo, B>
pub hyperdriver::client::conn::ProtocolRequest::transport: IO
pub hyperdriver::client::conn::ProtocolRequest::version: hyperdriver::client::conn::protocol::HttpProtocol
impl tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<hyperdriver::client::conn::stream::mock::MockStream, hyperdriver::body::Body>> for hyperdriver::client::conn::protocol::mock::MockProtocol
pub type hyperdriver::client::conn::protocol::mock::MockProtocol::Error = hyperdriver::client::conn::connection::ConnectionError
pub type hyperdriver::client::conn::protocol::mock::MockProtocol::Future = core::future::ready::Ready<core::result::Result<hyperdriver::client::conn::protocol::mock::MockSender, hyperdriver::client::conn::connection::ConnectionError>>
pub type hyperdriver::client::conn::protocol::mock::MockProtocol::Response = hyperdriver::client::conn::protocol::mock::MockSender
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::call(&mut self, req: hyperdriver::client::conn::protocol::ProtocolRequest<hyperdriver::client::conn::stream::mock::MockStream, hyperdriver::body::Body>) -> Self::Future
pub fn hyperdriver::client::conn::protocol::mock::MockProtocol::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<E, IO, BIn> tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<IO, BIn>> for hyper::client::conn::http2::Builder<E> where E: hyper::rt::bounds::h2_client::Http2ClientConnExec<BIn, hyperdriver::bridge::io::TokioIo<IO>> + core::marker::Unpin + core::marker::Send + core::marker::Sync + core::clone::Clone + 'static, IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, BIn: http_body::Body + core::marker::Unpin + core::marker::Send + 'static, <BIn as http_body::Body>::Data: core::marker::Send, <BIn as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub type hyper::client::conn::http2::Builder<E>::Error = hyperdriver::client::conn::connection::ConnectionError
pub type hyper::client::conn::http2::Builder<E>::Future = core::pin::Pin<alloc::boxed::Box<(dyn core::future::future::Future<Output = core::result::Result<hyperdriver::client::conn::connection::HttpConnection<BIn>, hyperdriver::client::conn::connection::ConnectionError>> + core::marker::Send)>>
pub type hyper::client::conn::http2::Builder<E>::Response = hyperdriver::client::conn::connection::HttpConnection<BIn>
pub fn hyper::client::conn::http2::Builder<E>::call(&mut self, req: hyperdriver::client::conn::protocol::ProtocolRequest<IO, BIn>) -> Self::Future
pub fn hyper::client::conn::http2::Builder<E>::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<IO, B> tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>> for hyper::client::conn::http1::Builder where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, B: http_body::Body + core::marker::Unpin + core::marker::Send + 'static, <B as http_body::Body>::Data: core::marker::Send, <B as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub type hyper::client::conn::http1::Builder::Error = hyperdriver::client::conn::connection::ConnectionError
pub type hyper::client::conn::http1::Builder::Future = core::pin::Pin<alloc::boxed::Box<(dyn core::future::future::Future<Output = core::result::Result<hyperdriver::client::conn::connection::HttpConnection<B>, hyperdriver::client::conn::connection::ConnectionError>> + core::marker::Send)>>
pub type hyper::client::conn::http1::Builder::Response = hyperdriver::client::conn::connection::HttpConnection<B>
pub fn hyper::client::conn::http1::Builder::call(&mut self, req: hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>) -> Self::Future
pub fn hyper::client::conn::http1::Builder::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<IO, B> tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>> for hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B> where IO: hyperdriver::info::tls::HasTlsConnectionInfo + hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Send + core::marker::Sync, B: http_body::Body + core::marker::Unpin + core::marker::Send + 'static, <B as http_body::Body>::Data: core::marker::Send, <B as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub type hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::Error = hyperdriver::client::conn::connection::ConnectionError
pub type hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::Future = HttpConnectFuture<IO, B>
pub type hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::Response = hyperdriver::client::conn::connection::HttpConnection<B>
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::call(&mut self, req: hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>) -> Self::Future
pub fn hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<B>::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<IO: core::fmt::Debug + hyperdriver::info::HasConnectionInfo, B: core::fmt::Debug> core::fmt::Debug for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<IO, B> core::marker::Freeze for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where IO: core::marker::Freeze
impl<IO, B> core::marker::Send for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where IO: core::marker::Send
impl<IO, B> core::marker::Sync for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where IO: core::marker::Sync
impl<IO, B> core::marker::Unpin for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where IO: core::marker::Unpin
impl<IO, B> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where IO: core::panic::unwind_safe::RefUnwindSafe
impl<IO, B> core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where IO: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B> where T: core::marker::Sized
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>
pub struct hyperdriver::client::conn::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo
impl hyperdriver::client::conn::stream::Stream
pub async fn hyperdriver::client::conn::stream::Stream::connect(addr: impl core::convert::Into<core::net::socket_addr::SocketAddr>) -> std::io::error::Result<Self>
impl<IO> hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub fn hyperdriver::client::conn::stream::Stream<IO>::tls(self, domain: &str, config: alloc::sync::Arc<rustls::client::client_conn::ClientConfig>) -> Self
impl<IO> hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo
pub fn hyperdriver::client::conn::stream::Stream<IO>::map<F, T>(self, f: F) -> hyperdriver::client::conn::stream::Stream<T> where F: core::ops::function::FnOnce(IO) -> T, T: hyperdriver::info::HasConnectionInfo
pub fn hyperdriver::client::conn::stream::Stream<IO>::new(inner: IO) -> Self
impl core::convert::From<hyperdriver::stream::duplex::DuplexStream> for hyperdriver::client::conn::stream::Stream
pub fn hyperdriver::client::conn::stream::Stream::from(stream: hyperdriver::stream::duplex::DuplexStream) -> Self
impl core::convert::From<hyperdriver::stream::tcp::TcpStream> for hyperdriver::client::conn::stream::Stream
pub fn hyperdriver::client::conn::stream::Stream::from(stream: hyperdriver::stream::tcp::TcpStream) -> Self
impl core::convert::From<hyperdriver::stream::unix::UnixStream> for hyperdriver::client::conn::stream::Stream
pub fn hyperdriver::client::conn::stream::Stream::from(stream: hyperdriver::stream::unix::UnixStream) -> Self
impl<'pin, IO> core::marker::Unpin for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo, __Stream<'pin, IO>: core::marker::Unpin
impl<IO> core::fmt::Debug for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + core::fmt::Debug
pub fn hyperdriver::client::conn::stream::Stream<IO>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<IO> hyperdriver::client::pool::PoolableStream for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + core::marker::Unpin + core::marker::Send + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send + core::marker::Unpin + core::clone::Clone
pub fn hyperdriver::client::conn::stream::Stream<IO>::can_share(&self) -> bool
impl<IO> hyperdriver::info::HasConnectionInfo for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin + core::clone::Clone
pub type hyperdriver::client::conn::stream::Stream<IO>::Addr = <IO as hyperdriver::info::HasConnectionInfo>::Addr
pub fn hyperdriver::client::conn::stream::Stream<IO>::info(&self) -> hyperdriver::info::ConnectionInfo<<IO as hyperdriver::info::HasConnectionInfo>::Addr>
impl<IO> hyperdriver::info::tls::HasTlsConnectionInfo for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin + core::clone::Clone
pub fn hyperdriver::client::conn::stream::Stream<IO>::tls_info(&self) -> core::option::Option<&hyperdriver::info::tls::TlsConnectionInfo>
impl<IO> hyperdriver::stream::tls::TlsHandshakeStream for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send + core::marker::Unpin + core::clone::Clone
pub fn hyperdriver::client::conn::stream::Stream<IO>::poll_handshake(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
impl<IO> tokio::io::async_read::AsyncRead for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin
pub fn hyperdriver::client::conn::stream::Stream<IO>::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &mut tokio::io::read_buf::ReadBuf<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
impl<IO> tokio::io::async_write::AsyncWrite for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin
pub fn hyperdriver::client::conn::stream::Stream<IO>::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::client::conn::stream::Stream<IO>::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::client::conn::stream::Stream<IO>::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
impl<IO> core::marker::Freeze for hyperdriver::client::conn::stream::Stream<IO> where IO: core::marker::Freeze, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Freeze
impl<IO> core::marker::Send for hyperdriver::client::conn::stream::Stream<IO> where IO: core::marker::Send
impl<IO> core::marker::Sync for hyperdriver::client::conn::stream::Stream<IO> where IO: core::marker::Sync, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Sync
impl<IO> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::stream::Stream<IO>
impl<IO> !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::stream::Stream<IO>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::stream::Stream<IO> where B: http_body::Body
impl<R> tokio::io::util::async_read_ext::AsyncReadExt for hyperdriver::client::conn::stream::Stream<IO> where R: tokio::io::async_read::AsyncRead + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::stream::Stream<IO> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::stream::Stream<IO>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::stream::Stream<IO> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::stream::Stream<IO>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::stream::Stream<IO>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::stream::Stream<IO> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::stream::Stream<IO>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::stream::Stream<IO>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::client::conn::stream::Stream<IO> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::stream::Stream<IO>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::stream::Stream<IO> where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::Stream<IO>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::stream::Stream<IO> where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::Stream<IO>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::conn::stream::Stream<IO>
pub fn hyperdriver::client::conn::stream::Stream<IO>::from(t: T) -> T
impl<T> hyperdriver::stream::tls::TlsHandshakeExt for hyperdriver::client::conn::stream::Stream<IO> where T: hyperdriver::stream::tls::TlsHandshakeStream
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::stream::Stream<IO> where T: core::marker::Sized
pub fn hyperdriver::client::conn::stream::Stream<IO>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::stream::Stream<IO>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::stream::Stream<IO>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::stream::Stream<IO>
impl<W> tokio::io::util::async_write_ext::AsyncWriteExt for hyperdriver::client::conn::stream::Stream<IO> where W: tokio::io::async_write::AsyncWrite + core::marker::Sized
pub struct hyperdriver::client::conn::TlsTransport<T>
impl<T> hyperdriver::client::conn::transport::TlsTransport<T>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::inner(&self) -> &T
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::inner_mut(&mut self) -> &mut T
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::into_inner(self) -> T
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::into_parts(self) -> (T, core::option::Option<alloc::sync::Arc<rustls::client::client_conn::ClientConfig>>)
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::new(transport: T) -> Self
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::tls_config(&self) -> core::option::Option<&alloc::sync::Arc<rustls::client::client_conn::ClientConfig>>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::with_default_tls(self) -> Self
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::with_tls(self, config: alloc::sync::Arc<rustls::client::client_conn::ClientConfig>) -> Self
impl<T: core::clone::Clone> core::clone::Clone for hyperdriver::client::conn::transport::TlsTransport<T>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::clone(&self) -> hyperdriver::client::conn::transport::TlsTransport<T>
impl<T: core::default::Default> core::default::Default for hyperdriver::client::conn::transport::TlsTransport<T>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::default() -> Self
impl<T: core::fmt::Debug> core::fmt::Debug for hyperdriver::client::conn::transport::TlsTransport<T>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T> tower_service::Service<http::uri::Uri> for hyperdriver::client::conn::transport::TlsTransport<T> where T: hyperdriver::client::conn::transport::Transport, <T as hyperdriver::client::conn::transport::Transport>::IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <<T as hyperdriver::client::conn::transport::Transport>::IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Send + core::marker::Unpin
pub type hyperdriver::client::conn::transport::TlsTransport<T>::Error = hyperdriver::client::conn::transport::TlsConnectionError<<T as hyperdriver::client::conn::transport::Transport>::Error>
pub type hyperdriver::client::conn::transport::TlsTransport<T>::Future = TransportBraidFuture<T>
pub type hyperdriver::client::conn::transport::TlsTransport<T>::Response = hyperdriver::client::conn::stream::Stream<<T as hyperdriver::client::conn::transport::Transport>::IO>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::call(&mut self, req: http::uri::Uri) -> Self::Future
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<T> core::marker::Freeze for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::marker::Freeze
impl<T> core::marker::Send for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::marker::Send
impl<T> core::marker::Sync for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::marker::Sync
impl<T> core::marker::Unpin for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::marker::Unpin
impl<T> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::conn::transport::TlsTransport<T>
impl<T> !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::conn::transport::TlsTransport<T>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::conn::transport::TlsTransport<T> where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::client::conn::transport::TlsTransport<T> where S: tower_service::Service<R>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::transport::TlsTransport<T> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::conn::transport::TlsTransport<T> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::conn::transport::TlsTransport<T> where U: core::convert::From<T>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::conn::transport::TlsTransport<T> where U: core::convert::Into<T>
pub type hyperdriver::client::conn::transport::TlsTransport<T>::Error = core::convert::Infallible
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::conn::transport::TlsTransport<T> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::conn::transport::TlsTransport<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::clone::Clone
pub type hyperdriver::client::conn::transport::TlsTransport<T>::Owned = T
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::clone::Clone
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::conn::transport::TlsTransport<T> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::clone::Clone
pub unsafe fn hyperdriver::client::conn::transport::TlsTransport<T>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::conn::transport::TlsTransport<T>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::from(t: T) -> T
impl<T> hyperdriver::client::conn::transport::TransportExt for hyperdriver::client::conn::transport::TlsTransport<T> where T: hyperdriver::client::conn::transport::Transport
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::conn::transport::TlsTransport<T> where T: core::marker::Sized
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::conn::transport::TlsTransport<T>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::conn::transport::TlsTransport<T>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::conn::transport::TlsTransport<T>
pub trait hyperdriver::client::conn::Connection<B>
pub type hyperdriver::client::conn::Connection::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::client::conn::Connection::Future: core::future::future::Future<Output = core::result::Result<http::response::Response<Self::ResBody>, Self::Error>> + core::marker::Send + 'static
pub type hyperdriver::client::conn::Connection::ResBody: http_body::Body + core::marker::Send + 'static
pub fn hyperdriver::client::conn::Connection::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
pub fn hyperdriver::client::conn::Connection::send_request(&mut self, request: http::request::Request<B>) -> Self::Future
pub fn hyperdriver::client::conn::Connection::version(&self) -> http::version::Version
impl hyperdriver::client::conn::connection::Connection<hyperdriver::body::Body> for hyperdriver::client::conn::protocol::mock::MockSender
pub type hyperdriver::client::conn::protocol::mock::MockSender::Error = hyperdriver::client::conn::protocol::mock::MockProtocolError
pub type hyperdriver::client::conn::protocol::mock::MockSender::Future = core::future::ready::Ready<core::result::Result<http::response::Response<hyperdriver::body::Body>, <hyperdriver::client::conn::protocol::mock::MockSender as hyperdriver::client::conn::connection::Connection<hyperdriver::body::Body>>::Error>>
pub type hyperdriver::client::conn::protocol::mock::MockSender::ResBody = hyperdriver::body::Body
pub fn hyperdriver::client::conn::protocol::mock::MockSender::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
pub fn hyperdriver::client::conn::protocol::mock::MockSender::send_request(&mut self, request: http::request::Request<hyperdriver::body::Body>) -> Self::Future
pub fn hyperdriver::client::conn::protocol::mock::MockSender::version(&self) -> http::version::Version
impl<B> hyperdriver::client::conn::connection::Connection<B> for hyperdriver::client::conn::connection::HttpConnection<B> where B: http_body::Body + core::marker::Send + 'static
pub type hyperdriver::client::conn::connection::HttpConnection<B>::Error = hyper::error::Error
pub type hyperdriver::client::conn::connection::HttpConnection<B>::Future = core::pin::Pin<alloc::boxed::Box<(dyn core::future::future::Future<Output = core::result::Result<http::response::Response<hyper::body::incoming::Incoming>, hyper::error::Error>> + core::marker::Send)>>
pub type hyperdriver::client::conn::connection::HttpConnection<B>::ResBody = hyper::body::incoming::Incoming
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::send_request(&mut self, request: http::request::Request<B>) -> Self::Future
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::version(&self) -> http::version::Version
pub trait hyperdriver::client::conn::Protocol<IO, B> where IO: hyperdriver::info::HasConnectionInfo, Self: tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>, Response = Self::Connection>
pub type hyperdriver::client::conn::Protocol::Connection: hyperdriver::client::conn::connection::Connection<B>
pub type hyperdriver::client::conn::Protocol::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::client::conn::Protocol::Future: core::future::future::Future<Output = core::result::Result<Self::Connection, <Self as hyperdriver::client::conn::protocol::Protocol<IO, B>>::Error>> + core::marker::Send + 'static
pub fn hyperdriver::client::conn::Protocol::connect(&mut self, transport: IO, version: hyperdriver::client::conn::protocol::HttpProtocol) -> <Self as hyperdriver::client::conn::protocol::Protocol<IO, B>>::Future
pub fn hyperdriver::client::conn::Protocol::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <Self as hyperdriver::client::conn::protocol::Protocol<IO, B>>::Error>>
impl<T, C, IO, B> hyperdriver::client::conn::protocol::Protocol<IO, B> for T where IO: hyperdriver::info::HasConnectionInfo, T: tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>, Response = C> + core::marker::Send + 'static, <T as tower_service::Service>::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static, <T as tower_service::Service>::Future: core::marker::Send + 'static, C: hyperdriver::client::conn::connection::Connection<B>
pub type T::Connection = C
pub type T::Error = <T as tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>>>::Error
pub type T::Future = <T as tower_service::Service<hyperdriver::client::conn::protocol::ProtocolRequest<IO, B>>>::Future
pub fn T::connect(&mut self, transport: IO, version: hyperdriver::client::conn::protocol::HttpProtocol) -> <Self as hyperdriver::client::conn::protocol::Protocol<IO, B>>::Future
pub fn T::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <Self as hyperdriver::client::conn::protocol::Protocol<IO, B>>::Error>>
pub trait hyperdriver::client::conn::Transport: core::clone::Clone + core::marker::Send
pub type hyperdriver::client::conn::Transport::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::client::conn::Transport::Future: core::future::future::Future<Output = core::result::Result<Self::IO, <Self as hyperdriver::client::conn::transport::Transport>::Error>> + core::marker::Send + 'static
pub type hyperdriver::client::conn::Transport::IO: hyperdriver::info::HasConnectionInfo + core::marker::Send + 'static
pub fn hyperdriver::client::conn::Transport::connect(&mut self, uri: http::uri::Uri) -> <Self as hyperdriver::client::conn::transport::Transport>::Future
pub fn hyperdriver::client::conn::Transport::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <Self as hyperdriver::client::conn::transport::Transport>::Error>>
impl<T, IO> hyperdriver::client::conn::transport::Transport for T where T: tower_service::Service<http::uri::Uri, Response = IO> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, <T as tower_service::Service>::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static, <T as tower_service::Service>::Future: core::marker::Send + 'static, IO: hyperdriver::info::HasConnectionInfo + core::marker::Send + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send
pub type T::Error = <T as tower_service::Service<http::uri::Uri>>::Error
pub type T::Future = <T as tower_service::Service<http::uri::Uri>>::Future
pub type T::IO = IO
pub fn T::connect(&mut self, uri: http::uri::Uri) -> <Self as tower_service::Service<http::uri::Uri>>::Future
pub fn T::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <Self as hyperdriver::client::conn::transport::Transport>::Error>>
pub trait hyperdriver::client::conn::_: hyperdriver::client::conn::transport::Transport
pub fn hyperdriver::client::conn::_::into_stream(self) -> hyperdriver::client::conn::transport::IntoStream<Self> where Self::IO: core::convert::Into<hyperdriver::client::conn::stream::Stream> + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin + core::marker::Send + 'static, <<Self as hyperdriver::client::conn::transport::Transport>::IO as hyperdriver::info::HasConnectionInfo>::Addr: core::convert::Into<hyperdriver::info::BraidAddr>
pub fn hyperdriver::client::conn::_::with_default_tls(self) -> hyperdriver::client::conn::transport::TlsTransport<Self> where Self: core::marker::Sized
pub fn hyperdriver::client::conn::_::with_optional_tls(self, config: core::option::Option<alloc::sync::Arc<rustls::client::client_conn::ClientConfig>>) -> hyperdriver::client::conn::transport::TlsTransport<Self> where Self: core::marker::Sized
pub fn hyperdriver::client::conn::_::with_tls(self, config: alloc::sync::Arc<rustls::client::client_conn::ClientConfig>) -> hyperdriver::client::conn::transport::TlsTransport<Self> where Self: core::marker::Sized
pub fn hyperdriver::client::conn::_::without_tls(self) -> hyperdriver::client::conn::transport::TlsTransport<Self> where Self: core::marker::Sized
impl<T> hyperdriver::client::conn::transport::TransportExt for T where T: hyperdriver::client::conn::transport::Transport
pub mod hyperdriver::client::pool
#[non_exhaustive] pub enum hyperdriver::client::pool::UriError
pub hyperdriver::client::pool::UriError::InvalidUri(http::uri::InvalidUri)
pub hyperdriver::client::pool::UriError::MissingScheme(http::uri::Uri)
impl core::convert::From<http::uri::InvalidUri> for hyperdriver::client::pool::UriError
pub fn hyperdriver::client::pool::UriError::from(source: http::uri::InvalidUri) -> Self
impl core::convert::From<hyperdriver::client::pool::UriError> for hyperdriver::client::conn::connection::ConnectionError
pub fn hyperdriver::client::conn::connection::ConnectionError::from(source: hyperdriver::client::pool::UriError) -> Self
impl core::error::Error for hyperdriver::client::pool::UriError
pub fn hyperdriver::client::pool::UriError::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl core::fmt::Debug for hyperdriver::client::pool::UriError
pub fn hyperdriver::client::pool::UriError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::client::pool::UriError
pub fn hyperdriver::client::pool::UriError::fmt(&self, __formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl !core::marker::Freeze for hyperdriver::client::pool::UriError
impl core::marker::Send for hyperdriver::client::pool::UriError
impl core::marker::Sync for hyperdriver::client::pool::UriError
impl core::marker::Unpin for hyperdriver::client::pool::UriError
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::pool::UriError
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::pool::UriError
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::pool::UriError where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::pool::UriError where U: core::convert::From<T>
pub fn hyperdriver::client::pool::UriError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::pool::UriError where U: core::convert::Into<T>
pub type hyperdriver::client::pool::UriError::Error = core::convert::Infallible
pub fn hyperdriver::client::pool::UriError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::pool::UriError where U: core::convert::TryFrom<T>
pub type hyperdriver::client::pool::UriError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::pool::UriError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for hyperdriver::client::pool::UriError where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::client::pool::UriError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for hyperdriver::client::pool::UriError where T: 'static + core::marker::Sized
pub fn hyperdriver::client::pool::UriError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::pool::UriError where T: core::marker::Sized
pub fn hyperdriver::client::pool::UriError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::pool::UriError where T: core::marker::Sized
pub fn hyperdriver::client::pool::UriError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::pool::UriError
pub fn hyperdriver::client::pool::UriError::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::client::pool::UriError where T: core::fmt::Display
pub fn hyperdriver::client::pool::UriError::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::pool::UriError where T: core::marker::Sized
pub fn hyperdriver::client::pool::UriError::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::pool::UriError::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::pool::UriError
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::pool::UriError
#[non_exhaustive] pub struct hyperdriver::client::pool::Config
pub hyperdriver::client::pool::Config::continue_after_preemption: bool
pub hyperdriver::client::pool::Config::idle_timeout: core::option::Option<core::time::Duration>
pub hyperdriver::client::pool::Config::max_idle_per_host: usize
impl core::clone::Clone for hyperdriver::client::pool::Config
pub fn hyperdriver::client::pool::Config::clone(&self) -> hyperdriver::client::pool::Config
impl core::default::Default for hyperdriver::client::pool::Config
pub fn hyperdriver::client::pool::Config::default() -> Self
impl core::fmt::Debug for hyperdriver::client::pool::Config
pub fn hyperdriver::client::pool::Config::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Freeze for hyperdriver::client::pool::Config
impl core::marker::Send for hyperdriver::client::pool::Config
impl core::marker::Sync for hyperdriver::client::pool::Config
impl core::marker::Unpin for hyperdriver::client::pool::Config
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::pool::Config
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::pool::Config
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::pool::Config where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::pool::Config where U: core::convert::From<T>
pub fn hyperdriver::client::pool::Config::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::pool::Config where U: core::convert::Into<T>
pub type hyperdriver::client::pool::Config::Error = core::convert::Infallible
pub fn hyperdriver::client::pool::Config::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::pool::Config where U: core::convert::TryFrom<T>
pub type hyperdriver::client::pool::Config::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::pool::Config::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::pool::Config where T: core::clone::Clone
pub type hyperdriver::client::pool::Config::Owned = T
pub fn hyperdriver::client::pool::Config::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::pool::Config::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::pool::Config where T: core::clone::Clone
pub fn hyperdriver::client::pool::Config::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::pool::Config where T: 'static + core::marker::Sized
pub fn hyperdriver::client::pool::Config::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::pool::Config where T: core::marker::Sized
pub fn hyperdriver::client::pool::Config::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::pool::Config where T: core::marker::Sized
pub fn hyperdriver::client::pool::Config::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::pool::Config where T: core::clone::Clone
pub unsafe fn hyperdriver::client::pool::Config::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::pool::Config
pub fn hyperdriver::client::pool::Config::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::pool::Config where T: core::marker::Sized
pub fn hyperdriver::client::pool::Config::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::pool::Config::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::pool::Config
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::pool::Config
pub struct hyperdriver::client::pool::Pooled<C, K> where C: hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
impl<C, K> core::fmt::Debug for hyperdriver::client::pool::Pooled<C, K> where C: core::fmt::Debug + hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub fn hyperdriver::client::pool::Pooled<C, K>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<C, K> core::ops::deref::Deref for hyperdriver::client::pool::Pooled<C, K> where C: hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub type hyperdriver::client::pool::Pooled<C, K>::Target = C
pub fn hyperdriver::client::pool::Pooled<C, K>::deref(&self) -> &Self::Target
impl<C, K> core::ops::deref::DerefMut for hyperdriver::client::pool::Pooled<C, K> where C: hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub fn hyperdriver::client::pool::Pooled<C, K>::deref_mut(&mut self) -> &mut Self::Target
impl<C, K> core::ops::drop::Drop for hyperdriver::client::pool::Pooled<C, K> where C: hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub fn hyperdriver::client::pool::Pooled<C, K>::drop(&mut self)
impl<C, K> core::marker::Freeze for hyperdriver::client::pool::Pooled<C, K> where K: core::marker::Freeze, C: core::marker::Freeze
impl<C, K> core::marker::Send for hyperdriver::client::pool::Pooled<C, K>
impl<C, K> core::marker::Sync for hyperdriver::client::pool::Pooled<C, K> where K: core::marker::Sync, C: core::marker::Sync
impl<C, K> core::marker::Unpin for hyperdriver::client::pool::Pooled<C, K>
impl<C, K> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::pool::Pooled<C, K>
impl<C, K> !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::pool::Pooled<C, K>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::pool::Pooled<C, K> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::pool::Pooled<C, K> where U: core::convert::From<T>
pub fn hyperdriver::client::pool::Pooled<C, K>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::pool::Pooled<C, K> where U: core::convert::Into<T>
pub type hyperdriver::client::pool::Pooled<C, K>::Error = core::convert::Infallible
pub fn hyperdriver::client::pool::Pooled<C, K>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::pool::Pooled<C, K> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::pool::Pooled<C, K>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::pool::Pooled<C, K>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::client::pool::Pooled<C, K> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::pool::Pooled<C, K>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::pool::Pooled<C, K> where T: core::marker::Sized
pub fn hyperdriver::client::pool::Pooled<C, K>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::pool::Pooled<C, K> where T: core::marker::Sized
pub fn hyperdriver::client::pool::Pooled<C, K>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::pool::Pooled<C, K>
pub fn hyperdriver::client::pool::Pooled<C, K>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::pool::Pooled<C, K> where T: core::marker::Sized
pub fn hyperdriver::client::pool::Pooled<C, K>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::pool::Pooled<C, K>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::pool::Pooled<C, K>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::pool::Pooled<C, K>
pub struct hyperdriver::client::pool::UriKey(_, _)
impl core::clone::Clone for hyperdriver::client::pool::UriKey
pub fn hyperdriver::client::pool::UriKey::clone(&self) -> hyperdriver::client::pool::UriKey
impl core::cmp::Eq for hyperdriver::client::pool::UriKey
impl core::cmp::PartialEq for hyperdriver::client::pool::UriKey
pub fn hyperdriver::client::pool::UriKey::eq(&self, other: &hyperdriver::client::pool::UriKey) -> bool
impl core::convert::From<(http::uri::scheme::Scheme, http::uri::authority::Authority)> for hyperdriver::client::pool::UriKey
pub fn hyperdriver::client::pool::UriKey::from(value: (http::uri::scheme::Scheme, http::uri::authority::Authority)) -> Self
impl core::convert::TryFrom<http::uri::Uri> for hyperdriver::client::pool::UriKey
pub type hyperdriver::client::pool::UriKey::Error = hyperdriver::client::pool::UriError
pub fn hyperdriver::client::pool::UriKey::try_from(value: http::uri::Uri) -> core::result::Result<Self, Self::Error>
impl core::fmt::Debug for hyperdriver::client::pool::UriKey
pub fn hyperdriver::client::pool::UriKey::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::client::pool::UriKey
pub fn hyperdriver::client::pool::UriKey::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for hyperdriver::client::pool::UriKey
pub fn hyperdriver::client::pool::UriKey::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::StructuralPartialEq for hyperdriver::client::pool::UriKey
impl core::str::traits::FromStr for hyperdriver::client::pool::UriKey
pub type hyperdriver::client::pool::UriKey::Err = hyperdriver::client::pool::UriError
pub fn hyperdriver::client::pool::UriKey::from_str(s: &str) -> core::result::Result<Self, Self::Err>
impl !core::marker::Freeze for hyperdriver::client::pool::UriKey
impl core::marker::Send for hyperdriver::client::pool::UriKey
impl core::marker::Sync for hyperdriver::client::pool::UriKey
impl core::marker::Unpin for hyperdriver::client::pool::UriKey
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::pool::UriKey
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::pool::UriKey
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::pool::UriKey where B: http_body::Body
impl<K> hyperdriver::client::pool::Key for hyperdriver::client::pool::UriKey where K: core::clone::Clone + core::cmp::Eq + core::hash::Hash + core::fmt::Debug + core::convert::TryFrom<http::uri::Uri, Error = hyperdriver::client::pool::UriError> + core::marker::Unpin + core::marker::Send + 'static
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::client::pool::UriKey where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::pool::UriKey::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::client::pool::UriKey where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::client::pool::UriKey::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::client::pool::UriKey where U: core::convert::From<T>
pub fn hyperdriver::client::pool::UriKey::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::pool::UriKey where U: core::convert::Into<T>
pub type hyperdriver::client::pool::UriKey::Error = core::convert::Infallible
pub fn hyperdriver::client::pool::UriKey::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::pool::UriKey where U: core::convert::TryFrom<T>
pub type hyperdriver::client::pool::UriKey::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::pool::UriKey::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::pool::UriKey where T: core::clone::Clone
pub type hyperdriver::client::pool::UriKey::Owned = T
pub fn hyperdriver::client::pool::UriKey::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::pool::UriKey::to_owned(&self) -> T
impl<T> alloc::string::ToString for hyperdriver::client::pool::UriKey where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::client::pool::UriKey::to_string(&self) -> alloc::string::String
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::pool::UriKey where T: core::clone::Clone
pub fn hyperdriver::client::pool::UriKey::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::pool::UriKey where T: 'static + core::marker::Sized
pub fn hyperdriver::client::pool::UriKey::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::pool::UriKey where T: core::marker::Sized
pub fn hyperdriver::client::pool::UriKey::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::pool::UriKey where T: core::marker::Sized
pub fn hyperdriver::client::pool::UriKey::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::pool::UriKey where T: core::clone::Clone
pub unsafe fn hyperdriver::client::pool::UriKey::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::pool::UriKey
pub fn hyperdriver::client::pool::UriKey::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::client::pool::UriKey where T: core::fmt::Display
pub fn hyperdriver::client::pool::UriKey::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::pool::UriKey where T: core::marker::Sized
pub fn hyperdriver::client::pool::UriKey::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::pool::UriKey::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::pool::UriKey
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::pool::UriKey
pub trait hyperdriver::client::pool::Key: core::clone::Clone + core::cmp::Eq + core::hash::Hash + core::fmt::Debug + core::convert::TryFrom<http::uri::Uri, Error = hyperdriver::client::pool::UriError> + core::marker::Unpin + core::marker::Send + 'static
impl<K> hyperdriver::client::pool::Key for K where K: core::clone::Clone + core::cmp::Eq + core::hash::Hash + core::fmt::Debug + core::convert::TryFrom<http::uri::Uri, Error = hyperdriver::client::pool::UriError> + core::marker::Unpin + core::marker::Send + 'static
pub trait hyperdriver::client::pool::PoolableConnection: core::marker::Unpin + core::marker::Send + core::marker::Sized + 'static
pub fn hyperdriver::client::pool::PoolableConnection::can_share(&self) -> bool
pub fn hyperdriver::client::pool::PoolableConnection::is_open(&self) -> bool
pub fn hyperdriver::client::pool::PoolableConnection::reuse(&mut self) -> core::option::Option<Self>
impl hyperdriver::client::pool::PoolableConnection for hyperdriver::client::conn::protocol::mock::MockSender
pub fn hyperdriver::client::conn::protocol::mock::MockSender::can_share(&self) -> bool
pub fn hyperdriver::client::conn::protocol::mock::MockSender::is_open(&self) -> bool
pub fn hyperdriver::client::conn::protocol::mock::MockSender::reuse(&mut self) -> core::option::Option<Self>
impl<B> hyperdriver::client::pool::PoolableConnection for hyperdriver::client::conn::connection::HttpConnection<B> where B: core::marker::Send + 'static
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::can_share(&self) -> bool
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::is_open(&self) -> bool
pub fn hyperdriver::client::conn::connection::HttpConnection<B>::reuse(&mut self) -> core::option::Option<Self>
pub trait hyperdriver::client::pool::PoolableStream: core::marker::Unpin + core::marker::Send + core::marker::Sized + 'static
pub fn hyperdriver::client::pool::PoolableStream::can_share(&self) -> bool
impl hyperdriver::client::pool::PoolableStream for hyperdriver::client::conn::stream::mock::MockStream
pub fn hyperdriver::client::conn::stream::mock::MockStream::can_share(&self) -> bool
impl hyperdriver::client::pool::PoolableStream for hyperdriver::stream::duplex::DuplexStream
pub fn hyperdriver::stream::duplex::DuplexStream::can_share(&self) -> bool
impl hyperdriver::client::pool::PoolableStream for hyperdriver::stream::tcp::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::can_share(&self) -> bool
impl hyperdriver::client::pool::PoolableStream for hyperdriver::stream::unix::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::can_share(&self) -> bool
impl<IO> hyperdriver::client::pool::PoolableStream for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + core::marker::Unpin + core::marker::Send + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send + core::marker::Unpin + core::clone::Clone
pub fn hyperdriver::client::conn::stream::Stream<IO>::can_share(&self) -> bool
impl<IO> hyperdriver::client::pool::PoolableStream for hyperdriver::client::conn::stream::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo + core::marker::Unpin + core::marker::Send + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Unpin + core::marker::Send
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::can_share(&self) -> bool
impl<Tls, NoTls> hyperdriver::client::pool::PoolableStream for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where Tls: hyperdriver::stream::tls::TlsHandshakeStream + core::marker::Send + core::marker::Unpin + 'static, NoTls: tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::can_share(&self) -> bool
#[non_exhaustive] pub enum hyperdriver::client::Error
pub hyperdriver::client::Error::Connection(alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>)
pub hyperdriver::client::Error::InvalidMethod(http::method::Method)
pub hyperdriver::client::Error::Protocol(alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>)
pub hyperdriver::client::Error::RequestTimeout
pub hyperdriver::client::Error::Service(alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>)
pub hyperdriver::client::Error::Transport(alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>)
pub hyperdriver::client::Error::UnsupportedProtocol
pub hyperdriver::client::Error::User(hyper::error::Error)
impl core::error::Error for hyperdriver::client::Error
pub fn hyperdriver::client::Error::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl core::fmt::Debug for hyperdriver::client::Error
pub fn hyperdriver::client::Error::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::client::Error
pub fn hyperdriver::client::Error::fmt(&self, __formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Freeze for hyperdriver::client::Error
impl core::marker::Send for hyperdriver::client::Error
impl core::marker::Sync for hyperdriver::client::Error
impl core::marker::Unpin for hyperdriver::client::Error
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::Error
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::Error
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::Error where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::Error where U: core::convert::From<T>
pub fn hyperdriver::client::Error::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::Error where U: core::convert::Into<T>
pub type hyperdriver::client::Error::Error = core::convert::Infallible
pub fn hyperdriver::client::Error::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::Error where U: core::convert::TryFrom<T>
pub type hyperdriver::client::Error::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::Error::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for hyperdriver::client::Error where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::client::Error::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for hyperdriver::client::Error where T: 'static + core::marker::Sized
pub fn hyperdriver::client::Error::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::Error where T: core::marker::Sized
pub fn hyperdriver::client::Error::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::Error where T: core::marker::Sized
pub fn hyperdriver::client::Error::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::Error
pub fn hyperdriver::client::Error::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::client::Error where T: core::fmt::Display
pub fn hyperdriver::client::Error::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::Error where T: core::marker::Sized
pub fn hyperdriver::client::Error::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::Error::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::Error
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::Error
pub struct hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>
impl hyperdriver::client::Builder<(), (), tower_http::follow_redirect::policy::Standard>
pub fn hyperdriver::client::Builder<(), (), tower_http::follow_redirect::policy::Standard>::new() -> Self
impl<T, P, RP, S, BIn, BOut> hyperdriver::client::Builder<T, P, RP, S, BIn, BOut> where T: BuildTransport, <T as BuildTransport>::Target: hyperdriver::client::conn::transport::Transport + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, <<T as BuildTransport>::Target as hyperdriver::client::conn::transport::Transport>::IO: hyperdriver::client::pool::PoolableStream + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <<<T as BuildTransport>::Target as hyperdriver::client::conn::transport::Transport>::IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin + core::clone::Clone + core::marker::Send, P: BuildProtocol<hyperdriver::client::conn::stream::Stream<<<T as BuildTransport>::Target as hyperdriver::client::conn::transport::Transport>::IO>, BIn>, <P as BuildProtocol<hyperdriver::client::conn::stream::Stream<<<T as BuildTransport>::Target as hyperdriver::client::conn::transport::Transport>::IO>, BIn>>::Target: hyperdriver::client::conn::protocol::Protocol<hyperdriver::client::conn::stream::Stream<<<T as BuildTransport>::Target as hyperdriver::client::conn::transport::Transport>::IO>, BIn, Error = hyperdriver::client::conn::connection::ConnectionError> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, <<P as BuildProtocol<hyperdriver::client::conn::stream::Stream<<<T as BuildTransport>::Target as hyperdriver::client::conn::transport::Transport>::IO>, BIn>>::Target as hyperdriver::client::conn::protocol::Protocol<hyperdriver::client::conn::stream::Stream<<<T as BuildTransport>::Target as hyperdriver::client::conn::transport::Transport>::IO>, BIn>>::Connection: hyperdriver::client::conn::connection::Connection<BIn, ResBody = hyper::body::incoming::Incoming> + hyperdriver::client::pool::PoolableConnection, RP: tower_http::follow_redirect::policy::Policy<BIn, hyperdriver::client::Error> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, S: tower_layer::Layer<hyperdriver::service::SharedService<http::request::Request<BIn>, http::response::Response<BOut>, hyperdriver::client::Error>>, <S as tower_layer::Layer>::Service: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>, Error = hyperdriver::client::Error> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, <<S as tower_layer::Layer>::Service as tower_service::Service<http::request::Request<BIn>>>::Future: core::marker::Send + 'static, BIn: core::default::Default + http_body::Body + core::marker::Unpin + core::marker::Send + 'static, <BIn as http_body::Body>::Data: core::marker::Send, <BIn as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, BOut: core::convert::From<hyper::body::incoming::Incoming> + http_body::Body + core::marker::Unpin + core::marker::Send + 'static
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::build_service(self) -> hyperdriver::service::SharedService<http::request::Request<BIn>, http::response::Response<BOut>, hyperdriver::client::Error>
impl<T, P, RP, S, BIn, BOut> hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::layer<L>(self, layer: L) -> hyperdriver::client::Builder<T, P, RP, tower_layer::stack::Stack<L, S>, BIn, BOut>
impl<T, P, RP, S, BIn, BOut> hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::pool(&mut self) -> core::option::Option<&mut hyperdriver::client::pool::Config>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::with_default_pool(self) -> Self
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::with_pool(self, pool: hyperdriver::client::pool::Config) -> Self
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::without_pool(self) -> Self
impl<T, P, RP, S, BIn, BOut> hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::protocol(&mut self) -> &mut P
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::with_auto_http(self) -> hyperdriver::client::Builder<T, hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<BIn>, RP, S, BIn, BOut>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::with_protocol<P2>(self, protocol: P2) -> hyperdriver::client::Builder<T, P2, RP, S, BIn, BOut>
impl<T, P, RP, S, BIn, BOut> hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::redirect_policy(&mut self) -> core::option::Option<&mut RP>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::with_redirect_policy<RP2>(self, policy: RP2) -> hyperdriver::client::Builder<T, P, RP2, S, BIn, BOut>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::with_standard_redirect_policy(self) -> hyperdriver::client::Builder<T, P, tower_http::follow_redirect::policy::Standard, S, BIn, BOut>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::without_redirects(self) -> hyperdriver::client::Builder<T, P, tower_http::follow_redirect::policy::Standard, S, BIn, BOut>
impl<T, P, RP, S, BIn, BOut> hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::timeout(&self) -> core::option::Option<core::time::Duration>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::with_optional_timeout(self, timeout: core::option::Option<core::time::Duration>) -> Self
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::with_timeout(self, timeout: core::time::Duration) -> Self
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::without_timeout(self) -> Self
impl<T, P, RP, S, BIn, BOut> hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::tls(&mut self) -> &mut core::option::Option<rustls::client::client_conn::ClientConfig>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::with_default_tls(self) -> Self
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::with_tls(self, config: rustls::client::client_conn::ClientConfig) -> Self
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::without_tls(self) -> Self
impl<T, P, RP, S, BIn, BOut> hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::transport(&mut self) -> &mut T
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::with_tcp(self, config: hyperdriver::client::conn::transport::tcp::TcpTransportConfig) -> hyperdriver::client::Builder<hyperdriver::client::conn::transport::tcp::TcpTransportConfig, P, RP, S, BIn, BOut>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::with_transport<T2>(self, transport: T2) -> hyperdriver::client::Builder<T2, P, RP, S, BIn, BOut>
impl<T, P, RP, S, BIn, BOut> hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::user_agent(&self) -> core::option::Option<&str>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::with_user_agent(self, user_agent: alloc::string::String) -> Self
impl<T, P, RP, S> hyperdriver::client::Builder<T, P, RP, S, hyperdriver::body::Body, hyperdriver::body::Body> where T: BuildTransport, <T as BuildTransport>::Target: hyperdriver::client::conn::transport::Transport + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, <<T as BuildTransport>::Target as hyperdriver::client::conn::transport::Transport>::IO: hyperdriver::client::pool::PoolableStream + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <<<T as BuildTransport>::Target as hyperdriver::client::conn::transport::Transport>::IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin + core::clone::Clone + core::marker::Send, P: BuildProtocol<hyperdriver::client::conn::stream::Stream<<<T as BuildTransport>::Target as hyperdriver::client::conn::transport::Transport>::IO>, hyperdriver::body::Body>, <P as BuildProtocol<hyperdriver::client::conn::stream::Stream<<<T as BuildTransport>::Target as hyperdriver::client::conn::transport::Transport>::IO>, hyperdriver::body::Body>>::Target: hyperdriver::client::conn::protocol::Protocol<hyperdriver::client::conn::stream::Stream<<<T as BuildTransport>::Target as hyperdriver::client::conn::transport::Transport>::IO>, hyperdriver::body::Body, Error = hyperdriver::client::conn::connection::ConnectionError> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, <<P as BuildProtocol<hyperdriver::client::conn::stream::Stream<<<T as BuildTransport>::Target as hyperdriver::client::conn::transport::Transport>::IO>, hyperdriver::body::Body>>::Target as hyperdriver::client::conn::protocol::Protocol<hyperdriver::client::conn::stream::Stream<<<T as BuildTransport>::Target as hyperdriver::client::conn::transport::Transport>::IO>, hyperdriver::body::Body>>::Connection: hyperdriver::client::conn::connection::Connection<hyperdriver::body::Body, ResBody = hyper::body::incoming::Incoming> + hyperdriver::client::pool::PoolableConnection, RP: tower_http::follow_redirect::policy::Policy<hyperdriver::body::Body, hyperdriver::client::Error> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, S: tower_layer::Layer<hyperdriver::service::SharedService<http::request::Request<hyperdriver::body::Body>, http::response::Response<hyperdriver::body::Body>, hyperdriver::client::Error>>, <S as tower_layer::Layer>::Service: tower_service::Service<http::request::Request<hyperdriver::body::Body>, Response = http::response::Response<hyperdriver::body::Body>, Error = hyperdriver::client::Error> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, <<S as tower_layer::Layer>::Service as tower_service::Service<http::request::Request<hyperdriver::body::Body>>>::Future: core::marker::Send + 'static
pub fn hyperdriver::client::Builder<T, P, RP, S, hyperdriver::body::Body, hyperdriver::body::Body>::build(self) -> hyperdriver::client::Client
impl core::default::Default for hyperdriver::client::Builder<hyperdriver::client::conn::transport::tcp::TcpTransportConfig, hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<hyperdriver::body::Body>, tower_http::follow_redirect::policy::Standard, tower_layer::identity::Identity, hyperdriver::body::Body, hyperdriver::body::Body>
pub fn hyperdriver::client::Builder<hyperdriver::client::conn::transport::tcp::TcpTransportConfig, hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<hyperdriver::body::Body>, tower_http::follow_redirect::policy::Standard, tower_layer::identity::Identity, hyperdriver::body::Body, hyperdriver::body::Body>::default() -> Self
impl<T: core::fmt::Debug, P: core::fmt::Debug, RP: core::fmt::Debug, S: core::fmt::Debug, BIn: core::fmt::Debug, BOut: core::fmt::Debug> core::fmt::Debug for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T, P, RP, S, BIn, BOut> core::marker::Freeze for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut> where T: core::marker::Freeze, P: core::marker::Freeze, S: core::marker::Freeze, RP: core::marker::Freeze
impl<T, P, RP, S, BIn, BOut> core::marker::Send for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut> where T: core::marker::Send, P: core::marker::Send, S: core::marker::Send, RP: core::marker::Send
impl<T, P, RP, S, BIn, BOut> core::marker::Sync for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut> where T: core::marker::Sync, P: core::marker::Sync, S: core::marker::Sync, RP: core::marker::Sync
impl<T, P, RP, S, BIn, BOut> core::marker::Unpin for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut> where T: core::marker::Unpin, P: core::marker::Unpin, S: core::marker::Unpin, RP: core::marker::Unpin
impl<T, P, RP, S, BIn, BOut> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>
impl<T, P, RP, S, BIn, BOut> !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut> where U: core::convert::From<T>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut> where U: core::convert::Into<T>
pub type hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::Error = core::convert::Infallible
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::Builder<T, P, RP, S, BIn, BOut>
pub struct hyperdriver::client::Client
impl hyperdriver::client::Client
pub fn hyperdriver::client::Client::build_tcp_http() -> hyperdriver::client::Builder<hyperdriver::client::conn::transport::tcp::TcpTransportConfig, hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<hyperdriver::body::Body>>
pub fn hyperdriver::client::Client::builder() -> hyperdriver::client::Builder<(), ()>
pub fn hyperdriver::client::Client::into_inner(self) -> hyperdriver::client::SharedClientService<hyperdriver::body::Body, hyperdriver::body::Body>
pub fn hyperdriver::client::Client::new_from_service<S>(service: S) -> Self where S: core::convert::Into<hyperdriver::client::SharedClientService<hyperdriver::body::Body, hyperdriver::body::Body>>
pub fn hyperdriver::client::Client::new_tcp_http() -> Self
impl hyperdriver::client::Client
pub async fn hyperdriver::client::Client::get(&mut self, uri: http::uri::Uri) -> core::result::Result<http::response::Response<hyperdriver::body::Body>, alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub fn hyperdriver::client::Client::request(&mut self, request: http::request::Request<hyperdriver::body::Body>) -> tower::util::oneshot::Oneshot<hyperdriver::client::SharedClientService<hyperdriver::body::Body, hyperdriver::body::Body>, http::request::Request<hyperdriver::body::Body>>
impl core::clone::Clone for hyperdriver::client::Client
pub fn hyperdriver::client::Client::clone(&self) -> hyperdriver::client::Client
impl core::default::Default for hyperdriver::client::Client
pub fn hyperdriver::client::Client::default() -> Self
impl core::fmt::Debug for hyperdriver::client::Client
pub fn hyperdriver::client::Client::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl tower_service::Service<http::request::Request<hyperdriver::body::Body>> for hyperdriver::client::Client
pub type hyperdriver::client::Client::Error = hyperdriver::client::Error
pub type hyperdriver::client::Client::Future = tower::util::oneshot::Oneshot<hyperdriver::service::SharedService<http::request::Request<hyperdriver::body::Body>, http::response::Response<hyperdriver::body::Body>, hyperdriver::client::Error>, http::request::Request<hyperdriver::body::Body>>
pub type hyperdriver::client::Client::Response = http::response::Response<hyperdriver::body::Body>
pub fn hyperdriver::client::Client::call(&mut self, request: http::request::Request<hyperdriver::body::Body>) -> Self::Future
pub fn hyperdriver::client::Client::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl core::marker::Freeze for hyperdriver::client::Client
impl core::marker::Send for hyperdriver::client::Client
impl core::marker::Sync for hyperdriver::client::Client
impl core::marker::Unpin for hyperdriver::client::Client
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::Client
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::Client
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::Client where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::client::Client where S: tower_service::Service<R>
pub fn hyperdriver::client::Client::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::client::Client::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::client::Client where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::client::Client::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::client::Client::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::client::Client::ResBody = BOut
pub fn hyperdriver::client::Client::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::client::Client::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::Client where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::Client where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::Client where U: core::convert::From<T>
pub fn hyperdriver::client::Client::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::Client where U: core::convert::Into<T>
pub type hyperdriver::client::Client::Error = core::convert::Infallible
pub fn hyperdriver::client::Client::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::Client where U: core::convert::TryFrom<T>
pub type hyperdriver::client::Client::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::Client::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::Client where T: core::clone::Clone
pub type hyperdriver::client::Client::Owned = T
pub fn hyperdriver::client::Client::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::Client::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::Client where T: core::clone::Clone
pub fn hyperdriver::client::Client::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::Client where T: 'static + core::marker::Sized
pub fn hyperdriver::client::Client::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::Client where T: core::marker::Sized
pub fn hyperdriver::client::Client::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::Client where T: core::marker::Sized
pub fn hyperdriver::client::Client::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::Client where T: core::clone::Clone
pub unsafe fn hyperdriver::client::Client::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::Client
pub fn hyperdriver::client::Client::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::Client where T: core::marker::Sized
pub fn hyperdriver::client::Client::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::Client::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::Client
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::Client
pub struct hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>
impl<T, P, BIn, K> hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::new(transport: T, protocol: P) -> Self
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::with_optional_pool(self, pool: core::option::Option<hyperdriver::client::pool::Config>) -> Self
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::with_pool(self, pool: hyperdriver::client::pool::Config) -> Self
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::without_pool(self) -> Self
impl<T, P, BIn, K> core::clone::Clone for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where T: core::clone::Clone, P: core::clone::Clone
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::clone(&self) -> Self
impl<T, P, S, BIn, K> tower_layer::Layer<S> for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where T: hyperdriver::client::conn::transport::Transport + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, P: hyperdriver::client::conn::protocol::Protocol<<T as hyperdriver::client::conn::transport::Transport>::IO, BIn> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, <P as hyperdriver::client::conn::protocol::Protocol>::Connection: hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub type hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::Service = hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::layer(&self, service: S) -> Self::Service
impl<T: core::fmt::Debug, P: core::fmt::Debug, BIn, K> core::fmt::Debug for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T, P, BIn, K> core::marker::Freeze for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where T: core::marker::Freeze, P: core::marker::Freeze
impl<T, P, BIn, K> core::marker::Send for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where T: core::marker::Send, P: core::marker::Send
impl<T, P, BIn, K> core::marker::Sync for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where T: core::marker::Sync, P: core::marker::Sync
impl<T, P, BIn, K> core::marker::Unpin for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where T: core::marker::Unpin, P: core::marker::Unpin
impl<T, P, BIn, K> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where T: core::panic::unwind_safe::RefUnwindSafe, P: core::panic::unwind_safe::RefUnwindSafe
impl<T, P, BIn, K> core::panic::unwind_safe::UnwindSafe for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where T: core::panic::unwind_safe::UnwindSafe, P: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where U: core::convert::From<T>
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where U: core::convert::Into<T>
pub type hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::Error = core::convert::Infallible
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where T: core::clone::Clone
pub type hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::Owned = T
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where T: core::clone::Clone
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where T: core::marker::Sized
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where T: core::marker::Sized
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where T: core::clone::Clone
pub unsafe fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K> where T: core::marker::Sized
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::ConnectionPoolLayer<T, P, BIn, K>
pub struct hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where T: hyperdriver::client::conn::transport::Transport, P: hyperdriver::client::conn::protocol::Protocol<<T as hyperdriver::client::conn::transport::Transport>::IO, BIn>, <P as hyperdriver::client::conn::protocol::Protocol>::Connection: hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
impl hyperdriver::client::ConnectionPoolService<hyperdriver::client::conn::transport::TlsTransport<hyperdriver::client::conn::transport::tcp::TcpTransport>, hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<hyperdriver::body::Body>, hyperdriver::service::RequestExecutor<hyperdriver::client::conn::connection::HttpConnection<hyperdriver::body::Body>, hyperdriver::body::Body, hyperdriver::client::pool::UriKey>, hyperdriver::body::Body>
pub fn hyperdriver::client::ConnectionPoolService<hyperdriver::client::conn::transport::TlsTransport<hyperdriver::client::conn::transport::tcp::TcpTransport>, hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<hyperdriver::body::Body>, hyperdriver::service::RequestExecutor<hyperdriver::client::conn::connection::HttpConnection<hyperdriver::body::Body>, hyperdriver::body::Body, hyperdriver::client::pool::UriKey>, hyperdriver::body::Body>::new_tcp_http() -> Self
impl<P, C, T, S, K, BIn, BOut> hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where C: hyperdriver::client::conn::connection::Connection<BIn, ResBody = BOut> + hyperdriver::client::pool::PoolableConnection, P: hyperdriver::client::conn::protocol::Protocol<<T as hyperdriver::client::conn::transport::Transport>::IO, BIn, Connection = C, Error = hyperdriver::client::conn::connection::ConnectionError> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, T: hyperdriver::client::conn::transport::Transport + 'static, <T as hyperdriver::client::conn::transport::Transport>::IO: hyperdriver::client::pool::PoolableStream + core::marker::Unpin, S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, BIn, K>, Response = http::response::Response<BOut>> + core::clone::Clone + core::marker::Send + 'static, <S as tower_service::Service>::Error: core::convert::Into<hyperdriver::client::Error>, BIn: http_body::Body + core::marker::Unpin + core::marker::Send + 'static, <BIn as http_body::Body>::Data: core::marker::Send, <BIn as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, BOut: http_body::Body + core::marker::Unpin + 'static, <<T as hyperdriver::client::conn::transport::Transport>::IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send, K: hyperdriver::client::pool::Key
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::request(&self, request: http::request::Request<BIn>) -> tower::util::oneshot::Oneshot<Self, http::request::Request<BIn>>
impl<T, P, S, BIn, K> hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where T: hyperdriver::client::conn::transport::Transport, P: hyperdriver::client::conn::protocol::Protocol<<T as hyperdriver::client::conn::transport::Transport>::IO, BIn>, <P as hyperdriver::client::conn::protocol::Protocol>::Connection: hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::new(transport: T, protocol: P, service: S, pool: hyperdriver::client::pool::Config) -> Self
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::without_pool(self) -> Self
impl<P, C, T, S, BIn, BOut, K> tower_service::Service<http::request::Request<BIn>> for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where C: hyperdriver::client::conn::connection::Connection<BIn, ResBody = BOut> + hyperdriver::client::pool::PoolableConnection, P: hyperdriver::client::conn::protocol::Protocol<<T as hyperdriver::client::conn::transport::Transport>::IO, BIn, Connection = C, Error = hyperdriver::client::conn::connection::ConnectionError> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, T: hyperdriver::client::conn::transport::Transport + core::marker::Send + 'static, <T as hyperdriver::client::conn::transport::Transport>::IO: hyperdriver::client::pool::PoolableStream + core::marker::Unpin, <<T as hyperdriver::client::conn::transport::Transport>::IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send, S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, BIn, K>, Response = http::response::Response<BOut>> + core::clone::Clone + core::marker::Send + 'static, <S as tower_service::Service>::Error: core::convert::Into<hyperdriver::client::Error>, BOut: http_body::Body + core::marker::Unpin + 'static, BIn: http_body::Body + core::marker::Unpin + core::marker::Send + 'static, <BIn as http_body::Body>::Data: core::marker::Send, <BIn as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, K: hyperdriver::client::pool::Key
pub type hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::Error = hyperdriver::client::Error
pub type hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::Future = ResponseFuture<T, P, C, S, K, BIn, BOut>
pub type hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::Response = http::response::Response<BOut>
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::call(&mut self, request: http::request::Request<BIn>) -> Self::Future
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::poll_ready(&mut self, &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<P, T, S, BIn, K> core::clone::Clone for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where P: hyperdriver::client::conn::protocol::Protocol<<T as hyperdriver::client::conn::transport::Transport>::IO, BIn> + core::clone::Clone, <P as hyperdriver::client::conn::protocol::Protocol>::Connection: hyperdriver::client::pool::PoolableConnection, T: hyperdriver::client::conn::transport::Transport + core::clone::Clone, S: core::clone::Clone, K: hyperdriver::client::pool::Key
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::clone(&self) -> Self
impl<T, P, S: core::fmt::Debug, BIn: core::fmt::Debug, K> core::fmt::Debug for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where T: hyperdriver::client::conn::transport::Transport + core::fmt::Debug, P: hyperdriver::client::conn::protocol::Protocol<<T as hyperdriver::client::conn::transport::Transport>::IO, BIn> + core::fmt::Debug, <P as hyperdriver::client::conn::protocol::Protocol>::Connection: hyperdriver::client::pool::PoolableConnection + core::fmt::Debug, K: hyperdriver::client::pool::Key + core::fmt::Debug
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T, P, S, BIn, K> core::marker::Freeze for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where <P as hyperdriver::client::conn::protocol::Protocol<<T as hyperdriver::client::conn::transport::Transport>::IO, BIn>>::Connection: core::marker::Sized, T: core::marker::Freeze, P: core::marker::Freeze, S: core::marker::Freeze
impl<T, P, S, BIn, K> core::marker::Send for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where <P as hyperdriver::client::conn::protocol::Protocol<<T as hyperdriver::client::conn::transport::Transport>::IO, BIn>>::Connection: core::marker::Sized, P: core::marker::Send, S: core::marker::Send
impl<T, P, S, BIn, K> core::marker::Sync for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where <P as hyperdriver::client::conn::protocol::Protocol<<T as hyperdriver::client::conn::transport::Transport>::IO, BIn>>::Connection: core::marker::Sized, T: core::marker::Sync, P: core::marker::Sync, S: core::marker::Sync
impl<T, P, S, BIn, K> core::marker::Unpin for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where <P as hyperdriver::client::conn::protocol::Protocol<<T as hyperdriver::client::conn::transport::Transport>::IO, BIn>>::Connection: core::marker::Sized, T: core::marker::Unpin, P: core::marker::Unpin, S: core::marker::Unpin
impl<T, P, S, BIn, K> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>
impl<T, P, S, BIn, K> !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where S: tower_service::Service<R>
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::ResBody = BOut
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where U: core::convert::From<T>
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where U: core::convert::Into<T>
pub type hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::Error = core::convert::Infallible
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where U: core::convert::TryFrom<T>
pub type hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where T: core::clone::Clone
pub type hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::Owned = T
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where T: core::clone::Clone
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where T: 'static + core::marker::Sized
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where T: core::marker::Sized
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where T: core::marker::Sized
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where T: core::clone::Clone
pub unsafe fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K> where T: core::marker::Sized
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::ConnectionPoolService<T, P, S, BIn, K>
#[non_exhaustive] pub struct hyperdriver::client::PoolConfig
pub hyperdriver::client::PoolConfig::continue_after_preemption: bool
pub hyperdriver::client::PoolConfig::idle_timeout: core::option::Option<core::time::Duration>
pub hyperdriver::client::PoolConfig::max_idle_per_host: usize
impl core::clone::Clone for hyperdriver::client::pool::Config
pub fn hyperdriver::client::pool::Config::clone(&self) -> hyperdriver::client::pool::Config
impl core::default::Default for hyperdriver::client::pool::Config
pub fn hyperdriver::client::pool::Config::default() -> Self
impl core::fmt::Debug for hyperdriver::client::pool::Config
pub fn hyperdriver::client::pool::Config::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Freeze for hyperdriver::client::pool::Config
impl core::marker::Send for hyperdriver::client::pool::Config
impl core::marker::Sync for hyperdriver::client::pool::Config
impl core::marker::Unpin for hyperdriver::client::pool::Config
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::pool::Config
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::client::pool::Config
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::pool::Config where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::client::pool::Config where U: core::convert::From<T>
pub fn hyperdriver::client::pool::Config::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::pool::Config where U: core::convert::Into<T>
pub type hyperdriver::client::pool::Config::Error = core::convert::Infallible
pub fn hyperdriver::client::pool::Config::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::pool::Config where U: core::convert::TryFrom<T>
pub type hyperdriver::client::pool::Config::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::pool::Config::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::pool::Config where T: core::clone::Clone
pub type hyperdriver::client::pool::Config::Owned = T
pub fn hyperdriver::client::pool::Config::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::pool::Config::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::pool::Config where T: core::clone::Clone
pub fn hyperdriver::client::pool::Config::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::pool::Config where T: 'static + core::marker::Sized
pub fn hyperdriver::client::pool::Config::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::pool::Config where T: core::marker::Sized
pub fn hyperdriver::client::pool::Config::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::pool::Config where T: core::marker::Sized
pub fn hyperdriver::client::pool::Config::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::pool::Config where T: core::clone::Clone
pub unsafe fn hyperdriver::client::pool::Config::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::pool::Config
pub fn hyperdriver::client::pool::Config::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::pool::Config where T: core::marker::Sized
pub fn hyperdriver::client::pool::Config::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::pool::Config::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::pool::Config
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::pool::Config
pub fn hyperdriver::client::default_tls_config() -> rustls::client::client_conn::ClientConfig
pub type hyperdriver::client::SharedClientService<BIn, BOut> = hyperdriver::service::SharedService<http::request::Request<BIn>, http::response::Response<BOut>, hyperdriver::client::Error>
pub mod hyperdriver::info
pub mod hyperdriver::info::tls
pub struct hyperdriver::info::tls::TlsConnectionInfo
pub hyperdriver::info::tls::TlsConnectionInfo::alpn: core::option::Option<hyperdriver::info::Protocol>
pub hyperdriver::info::tls::TlsConnectionInfo::server_name: core::option::Option<alloc::string::String>
pub hyperdriver::info::tls::TlsConnectionInfo::validated_server_name: bool
impl core::clone::Clone for hyperdriver::info::tls::TlsConnectionInfo
pub fn hyperdriver::info::tls::TlsConnectionInfo::clone(&self) -> hyperdriver::info::tls::TlsConnectionInfo
impl core::cmp::Eq for hyperdriver::info::tls::TlsConnectionInfo
impl core::cmp::PartialEq for hyperdriver::info::tls::TlsConnectionInfo
pub fn hyperdriver::info::tls::TlsConnectionInfo::eq(&self, other: &hyperdriver::info::tls::TlsConnectionInfo) -> bool
impl core::default::Default for hyperdriver::info::tls::TlsConnectionInfo
pub fn hyperdriver::info::tls::TlsConnectionInfo::default() -> hyperdriver::info::tls::TlsConnectionInfo
impl core::fmt::Debug for hyperdriver::info::tls::TlsConnectionInfo
pub fn hyperdriver::info::tls::TlsConnectionInfo::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::StructuralPartialEq for hyperdriver::info::tls::TlsConnectionInfo
impl core::marker::Freeze for hyperdriver::info::tls::TlsConnectionInfo
impl core::marker::Send for hyperdriver::info::tls::TlsConnectionInfo
impl core::marker::Sync for hyperdriver::info::tls::TlsConnectionInfo
impl core::marker::Unpin for hyperdriver::info::tls::TlsConnectionInfo
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::info::tls::TlsConnectionInfo
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::info::tls::TlsConnectionInfo
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::info::tls::TlsConnectionInfo where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::info::tls::TlsConnectionInfo where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::info::tls::TlsConnectionInfo where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::info::tls::TlsConnectionInfo where U: core::convert::From<T>
pub fn hyperdriver::info::tls::TlsConnectionInfo::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::info::tls::TlsConnectionInfo where U: core::convert::Into<T>
pub type hyperdriver::info::tls::TlsConnectionInfo::Error = core::convert::Infallible
pub fn hyperdriver::info::tls::TlsConnectionInfo::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::info::tls::TlsConnectionInfo where U: core::convert::TryFrom<T>
pub type hyperdriver::info::tls::TlsConnectionInfo::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::info::tls::TlsConnectionInfo::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::info::tls::TlsConnectionInfo where T: core::clone::Clone
pub type hyperdriver::info::tls::TlsConnectionInfo::Owned = T
pub fn hyperdriver::info::tls::TlsConnectionInfo::clone_into(&self, target: &mut T)
pub fn hyperdriver::info::tls::TlsConnectionInfo::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::info::tls::TlsConnectionInfo where T: core::clone::Clone
pub fn hyperdriver::info::tls::TlsConnectionInfo::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::info::tls::TlsConnectionInfo where T: 'static + core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::info::tls::TlsConnectionInfo where T: core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::info::tls::TlsConnectionInfo where T: core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::info::tls::TlsConnectionInfo where T: core::clone::Clone
pub unsafe fn hyperdriver::info::tls::TlsConnectionInfo::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::info::tls::TlsConnectionInfo
pub fn hyperdriver::info::tls::TlsConnectionInfo::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::info::tls::TlsConnectionInfo where T: core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::info::tls::TlsConnectionInfo::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::info::tls::TlsConnectionInfo
impl<T> tracing::instrument::WithSubscriber for hyperdriver::info::tls::TlsConnectionInfo
pub trait hyperdriver::info::tls::HasTlsConnectionInfo: hyperdriver::info::HasConnectionInfo
pub fn hyperdriver::info::tls::HasTlsConnectionInfo::tls_info(&self) -> core::option::Option<&hyperdriver::info::tls::TlsConnectionInfo>
impl<IO> hyperdriver::info::tls::HasTlsConnectionInfo for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin + core::clone::Clone
pub fn hyperdriver::client::conn::stream::Stream<IO>::tls_info(&self) -> core::option::Option<&hyperdriver::info::tls::TlsConnectionInfo>
impl<IO> hyperdriver::info::tls::HasTlsConnectionInfo for hyperdriver::client::conn::stream::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::tls_info(&self) -> core::option::Option<&hyperdriver::info::tls::TlsConnectionInfo>
impl<IO> hyperdriver::info::tls::HasTlsConnectionInfo for hyperdriver::client::conn::stream::mock::MockTls<IO> where IO: hyperdriver::info::HasConnectionInfo
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::tls_info(&self) -> core::option::Option<&hyperdriver::info::tls::TlsConnectionInfo>
pub enum hyperdriver::info::BraidAddr
pub hyperdriver::info::BraidAddr::Duplex
pub hyperdriver::info::BraidAddr::Tcp(core::net::socket_addr::SocketAddr)
pub hyperdriver::info::BraidAddr::Unix(hyperdriver::stream::unix::UnixAddr)
impl hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::canonical(self) -> Self
pub fn hyperdriver::info::BraidAddr::path(&self) -> core::option::Option<&camino::Utf8Path>
pub fn hyperdriver::info::BraidAddr::tcp(&self) -> core::option::Option<core::net::socket_addr::SocketAddr>
impl core::clone::Clone for hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::clone(&self) -> hyperdriver::info::BraidAddr
impl core::cmp::Eq for hyperdriver::info::BraidAddr
impl core::cmp::PartialEq for hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::eq(&self, other: &hyperdriver::info::BraidAddr) -> bool
impl core::convert::From<(core::net::ip_addr::IpAddr, u16)> for hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::from(addr: (core::net::ip_addr::IpAddr, u16)) -> Self
impl core::convert::From<(core::net::ip_addr::Ipv4Addr, u16)> for hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::from(addr: (core::net::ip_addr::Ipv4Addr, u16)) -> Self
impl core::convert::From<(core::net::ip_addr::Ipv6Addr, u16)> for hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::from(addr: (core::net::ip_addr::Ipv6Addr, u16)) -> Self
impl core::convert::From<camino::Utf8PathBuf> for hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::from(addr: camino::Utf8PathBuf) -> Self
impl core::convert::From<core::net::socket_addr::SocketAddr> for hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::from(addr: core::net::socket_addr::SocketAddr) -> Self
impl core::convert::From<hyperdriver::stream::duplex::DuplexAddr> for hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::from(hyperdriver::stream::duplex::DuplexAddr) -> Self
impl core::convert::From<hyperdriver::stream::unix::UnixAddr> for hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::from(addr: hyperdriver::stream::unix::UnixAddr) -> Self
impl core::convert::TryFrom<tokio::net::unix::socketaddr::SocketAddr> for hyperdriver::info::BraidAddr
pub type hyperdriver::info::BraidAddr::Error = std::io::error::Error
pub fn hyperdriver::info::BraidAddr::try_from(addr: tokio::net::unix::socketaddr::SocketAddr) -> core::result::Result<Self, Self::Error>
impl core::fmt::Debug for hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::StructuralPartialEq for hyperdriver::info::BraidAddr
impl core::marker::Freeze for hyperdriver::info::BraidAddr
impl core::marker::Send for hyperdriver::info::BraidAddr
impl core::marker::Sync for hyperdriver::info::BraidAddr
impl core::marker::Unpin for hyperdriver::info::BraidAddr
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::info::BraidAddr
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::info::BraidAddr
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::info::BraidAddr where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::info::BraidAddr where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::info::BraidAddr::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::info::BraidAddr where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::info::BraidAddr::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::info::BraidAddr where U: core::convert::From<T>
pub fn hyperdriver::info::BraidAddr::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::info::BraidAddr where U: core::convert::Into<T>
pub type hyperdriver::info::BraidAddr::Error = core::convert::Infallible
pub fn hyperdriver::info::BraidAddr::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::info::BraidAddr where U: core::convert::TryFrom<T>
pub type hyperdriver::info::BraidAddr::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::info::BraidAddr::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::info::BraidAddr where T: core::clone::Clone
pub type hyperdriver::info::BraidAddr::Owned = T
pub fn hyperdriver::info::BraidAddr::clone_into(&self, target: &mut T)
pub fn hyperdriver::info::BraidAddr::to_owned(&self) -> T
impl<T> alloc::string::ToString for hyperdriver::info::BraidAddr where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::info::BraidAddr::to_string(&self) -> alloc::string::String
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::info::BraidAddr where T: core::clone::Clone
pub fn hyperdriver::info::BraidAddr::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::info::BraidAddr where T: 'static + core::marker::Sized
pub fn hyperdriver::info::BraidAddr::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::info::BraidAddr where T: core::marker::Sized
pub fn hyperdriver::info::BraidAddr::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::info::BraidAddr where T: core::marker::Sized
pub fn hyperdriver::info::BraidAddr::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::info::BraidAddr where T: core::clone::Clone
pub unsafe fn hyperdriver::info::BraidAddr::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::info::BraidAddr where T: core::fmt::Display
pub fn hyperdriver::info::BraidAddr::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::info::BraidAddr where T: core::marker::Sized
pub fn hyperdriver::info::BraidAddr::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::info::BraidAddr::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::info::BraidAddr
impl<T> tracing::instrument::WithSubscriber for hyperdriver::info::BraidAddr
#[non_exhaustive] pub enum hyperdriver::info::Protocol
pub hyperdriver::info::Protocol::Grpc
pub hyperdriver::info::Protocol::Http(http::version::Version)
pub hyperdriver::info::Protocol::Other(alloc::string::String)
pub hyperdriver::info::Protocol::WebSocket
impl hyperdriver::info::Protocol
pub fn hyperdriver::info::Protocol::grpc() -> Self
pub fn hyperdriver::info::Protocol::http(version: http::version::Version) -> Self
pub fn hyperdriver::info::Protocol::web_socket() -> Self
impl core::clone::Clone for hyperdriver::info::Protocol
pub fn hyperdriver::info::Protocol::clone(&self) -> hyperdriver::info::Protocol
impl core::cmp::Eq for hyperdriver::info::Protocol
impl core::cmp::PartialEq for hyperdriver::info::Protocol
pub fn hyperdriver::info::Protocol::eq(&self, other: &hyperdriver::info::Protocol) -> bool
impl core::convert::From<http::version::Version> for hyperdriver::info::Protocol
pub fn hyperdriver::info::Protocol::from(version: http::version::Version) -> Self
impl core::fmt::Debug for hyperdriver::info::Protocol
pub fn hyperdriver::info::Protocol::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::info::Protocol
pub fn hyperdriver::info::Protocol::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for hyperdriver::info::Protocol
pub fn hyperdriver::info::Protocol::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::StructuralPartialEq for hyperdriver::info::Protocol
impl core::str::traits::FromStr for hyperdriver::info::Protocol
pub type hyperdriver::info::Protocol::Err = core::convert::Infallible
pub fn hyperdriver::info::Protocol::from_str(s: &str) -> core::result::Result<Self, Self::Err>
impl core::marker::Freeze for hyperdriver::info::Protocol
impl core::marker::Send for hyperdriver::info::Protocol
impl core::marker::Sync for hyperdriver::info::Protocol
impl core::marker::Unpin for hyperdriver::info::Protocol
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::info::Protocol
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::info::Protocol
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::info::Protocol where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::info::Protocol where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::info::Protocol::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::info::Protocol where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::info::Protocol::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::info::Protocol where U: core::convert::From<T>
pub fn hyperdriver::info::Protocol::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::info::Protocol where U: core::convert::Into<T>
pub type hyperdriver::info::Protocol::Error = core::convert::Infallible
pub fn hyperdriver::info::Protocol::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::info::Protocol where U: core::convert::TryFrom<T>
pub type hyperdriver::info::Protocol::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::info::Protocol::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::info::Protocol where T: core::clone::Clone
pub type hyperdriver::info::Protocol::Owned = T
pub fn hyperdriver::info::Protocol::clone_into(&self, target: &mut T)
pub fn hyperdriver::info::Protocol::to_owned(&self) -> T
impl<T> alloc::string::ToString for hyperdriver::info::Protocol where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::info::Protocol::to_string(&self) -> alloc::string::String
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::info::Protocol where T: core::clone::Clone
pub fn hyperdriver::info::Protocol::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::info::Protocol where T: 'static + core::marker::Sized
pub fn hyperdriver::info::Protocol::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::info::Protocol where T: core::marker::Sized
pub fn hyperdriver::info::Protocol::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::info::Protocol where T: core::marker::Sized
pub fn hyperdriver::info::Protocol::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::info::Protocol where T: core::clone::Clone
pub unsafe fn hyperdriver::info::Protocol::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::info::Protocol
pub fn hyperdriver::info::Protocol::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::info::Protocol where T: core::fmt::Display
pub fn hyperdriver::info::Protocol::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::info::Protocol where T: core::marker::Sized
pub fn hyperdriver::info::Protocol::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::info::Protocol::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::info::Protocol
impl<T> tracing::instrument::WithSubscriber for hyperdriver::info::Protocol
pub struct hyperdriver::info::ConnectionInfo<Addr>
pub hyperdriver::info::ConnectionInfo::local_addr: Addr
pub hyperdriver::info::ConnectionInfo::remote_addr: Addr
impl<Addr> hyperdriver::info::ConnectionInfo<Addr>
pub fn hyperdriver::info::ConnectionInfo<Addr>::local_addr(&self) -> &Addr
pub fn hyperdriver::info::ConnectionInfo<Addr>::map<T, F>(self, f: F) -> hyperdriver::info::ConnectionInfo<T> where F: core::ops::function::Fn(Addr) -> T
pub fn hyperdriver::info::ConnectionInfo<Addr>::remote_addr(&self) -> &Addr
impl<Addr: core::clone::Clone> core::clone::Clone for hyperdriver::info::ConnectionInfo<Addr>
pub fn hyperdriver::info::ConnectionInfo<Addr>::clone(&self) -> hyperdriver::info::ConnectionInfo<Addr>
impl<Addr: core::cmp::Eq> core::cmp::Eq for hyperdriver::info::ConnectionInfo<Addr>
impl<Addr: core::cmp::PartialEq> core::cmp::PartialEq for hyperdriver::info::ConnectionInfo<Addr>
pub fn hyperdriver::info::ConnectionInfo<Addr>::eq(&self, other: &hyperdriver::info::ConnectionInfo<Addr>) -> bool
impl<Addr: core::fmt::Debug> core::fmt::Debug for hyperdriver::info::ConnectionInfo<Addr>
pub fn hyperdriver::info::ConnectionInfo<Addr>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<Addr> core::default::Default for hyperdriver::info::ConnectionInfo<Addr> where Addr: core::default::Default
pub fn hyperdriver::info::ConnectionInfo<Addr>::default() -> Self
impl<Addr> core::marker::StructuralPartialEq for hyperdriver::info::ConnectionInfo<Addr>
impl<Addr> core::marker::Freeze for hyperdriver::info::ConnectionInfo<Addr> where Addr: core::marker::Freeze
impl<Addr> core::marker::Send for hyperdriver::info::ConnectionInfo<Addr> where Addr: core::marker::Send
impl<Addr> core::marker::Sync for hyperdriver::info::ConnectionInfo<Addr> where Addr: core::marker::Sync
impl<Addr> core::marker::Unpin for hyperdriver::info::ConnectionInfo<Addr> where Addr: core::marker::Unpin
impl<Addr> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::info::ConnectionInfo<Addr> where Addr: core::panic::unwind_safe::RefUnwindSafe
impl<Addr> core::panic::unwind_safe::UnwindSafe for hyperdriver::info::ConnectionInfo<Addr> where Addr: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::info::ConnectionInfo<Addr> where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::info::ConnectionInfo<Addr> where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::info::ConnectionInfo<Addr>::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::info::ConnectionInfo<Addr> where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::info::ConnectionInfo<Addr>::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::info::ConnectionInfo<Addr> where U: core::convert::From<T>
pub fn hyperdriver::info::ConnectionInfo<Addr>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::info::ConnectionInfo<Addr> where U: core::convert::Into<T>
pub type hyperdriver::info::ConnectionInfo<Addr>::Error = core::convert::Infallible
pub fn hyperdriver::info::ConnectionInfo<Addr>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::info::ConnectionInfo<Addr> where U: core::convert::TryFrom<T>
pub type hyperdriver::info::ConnectionInfo<Addr>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::info::ConnectionInfo<Addr>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::info::ConnectionInfo<Addr> where T: core::clone::Clone
pub type hyperdriver::info::ConnectionInfo<Addr>::Owned = T
pub fn hyperdriver::info::ConnectionInfo<Addr>::clone_into(&self, target: &mut T)
pub fn hyperdriver::info::ConnectionInfo<Addr>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::info::ConnectionInfo<Addr> where T: core::clone::Clone
pub fn hyperdriver::info::ConnectionInfo<Addr>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::info::ConnectionInfo<Addr> where T: 'static + core::marker::Sized
pub fn hyperdriver::info::ConnectionInfo<Addr>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::info::ConnectionInfo<Addr> where T: core::marker::Sized
pub fn hyperdriver::info::ConnectionInfo<Addr>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::info::ConnectionInfo<Addr> where T: core::marker::Sized
pub fn hyperdriver::info::ConnectionInfo<Addr>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::info::ConnectionInfo<Addr> where T: core::clone::Clone
pub unsafe fn hyperdriver::info::ConnectionInfo<Addr>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::info::ConnectionInfo<Addr>
pub fn hyperdriver::info::ConnectionInfo<Addr>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::info::ConnectionInfo<Addr> where T: core::marker::Sized
pub fn hyperdriver::info::ConnectionInfo<Addr>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::info::ConnectionInfo<Addr>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::info::ConnectionInfo<Addr>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::info::ConnectionInfo<Addr>
pub struct hyperdriver::info::TlsConnectionInfo
pub hyperdriver::info::TlsConnectionInfo::alpn: core::option::Option<hyperdriver::info::Protocol>
pub hyperdriver::info::TlsConnectionInfo::server_name: core::option::Option<alloc::string::String>
pub hyperdriver::info::TlsConnectionInfo::validated_server_name: bool
impl core::clone::Clone for hyperdriver::info::tls::TlsConnectionInfo
pub fn hyperdriver::info::tls::TlsConnectionInfo::clone(&self) -> hyperdriver::info::tls::TlsConnectionInfo
impl core::cmp::Eq for hyperdriver::info::tls::TlsConnectionInfo
impl core::cmp::PartialEq for hyperdriver::info::tls::TlsConnectionInfo
pub fn hyperdriver::info::tls::TlsConnectionInfo::eq(&self, other: &hyperdriver::info::tls::TlsConnectionInfo) -> bool
impl core::default::Default for hyperdriver::info::tls::TlsConnectionInfo
pub fn hyperdriver::info::tls::TlsConnectionInfo::default() -> hyperdriver::info::tls::TlsConnectionInfo
impl core::fmt::Debug for hyperdriver::info::tls::TlsConnectionInfo
pub fn hyperdriver::info::tls::TlsConnectionInfo::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::StructuralPartialEq for hyperdriver::info::tls::TlsConnectionInfo
impl core::marker::Freeze for hyperdriver::info::tls::TlsConnectionInfo
impl core::marker::Send for hyperdriver::info::tls::TlsConnectionInfo
impl core::marker::Sync for hyperdriver::info::tls::TlsConnectionInfo
impl core::marker::Unpin for hyperdriver::info::tls::TlsConnectionInfo
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::info::tls::TlsConnectionInfo
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::info::tls::TlsConnectionInfo
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::info::tls::TlsConnectionInfo where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::info::tls::TlsConnectionInfo where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::info::tls::TlsConnectionInfo where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::info::tls::TlsConnectionInfo where U: core::convert::From<T>
pub fn hyperdriver::info::tls::TlsConnectionInfo::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::info::tls::TlsConnectionInfo where U: core::convert::Into<T>
pub type hyperdriver::info::tls::TlsConnectionInfo::Error = core::convert::Infallible
pub fn hyperdriver::info::tls::TlsConnectionInfo::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::info::tls::TlsConnectionInfo where U: core::convert::TryFrom<T>
pub type hyperdriver::info::tls::TlsConnectionInfo::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::info::tls::TlsConnectionInfo::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::info::tls::TlsConnectionInfo where T: core::clone::Clone
pub type hyperdriver::info::tls::TlsConnectionInfo::Owned = T
pub fn hyperdriver::info::tls::TlsConnectionInfo::clone_into(&self, target: &mut T)
pub fn hyperdriver::info::tls::TlsConnectionInfo::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::info::tls::TlsConnectionInfo where T: core::clone::Clone
pub fn hyperdriver::info::tls::TlsConnectionInfo::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::info::tls::TlsConnectionInfo where T: 'static + core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::info::tls::TlsConnectionInfo where T: core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::info::tls::TlsConnectionInfo where T: core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::info::tls::TlsConnectionInfo where T: core::clone::Clone
pub unsafe fn hyperdriver::info::tls::TlsConnectionInfo::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::info::tls::TlsConnectionInfo
pub fn hyperdriver::info::tls::TlsConnectionInfo::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::info::tls::TlsConnectionInfo where T: core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::info::tls::TlsConnectionInfo::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::info::tls::TlsConnectionInfo
impl<T> tracing::instrument::WithSubscriber for hyperdriver::info::tls::TlsConnectionInfo
pub trait hyperdriver::info::HasConnectionInfo
pub type hyperdriver::info::HasConnectionInfo::Addr: core::fmt::Display + core::fmt::Debug + core::marker::Send
pub fn hyperdriver::info::HasConnectionInfo::info(&self) -> hyperdriver::info::ConnectionInfo<Self::Addr>
impl hyperdriver::info::HasConnectionInfo for hyperdriver::client::conn::stream::mock::MockStream
pub type hyperdriver::client::conn::stream::mock::MockStream::Addr = hyperdriver::client::conn::stream::mock::MockAddress
pub fn hyperdriver::client::conn::stream::mock::MockStream::info(&self) -> hyperdriver::info::ConnectionInfo<Self::Addr>
impl hyperdriver::info::HasConnectionInfo for hyperdriver::stream::Braid
pub type hyperdriver::stream::Braid::Addr = hyperdriver::info::BraidAddr
pub fn hyperdriver::stream::Braid::info(&self) -> hyperdriver::info::ConnectionInfo<hyperdriver::info::BraidAddr>
impl hyperdriver::info::HasConnectionInfo for hyperdriver::stream::duplex::DuplexStream
pub type hyperdriver::stream::duplex::DuplexStream::Addr = hyperdriver::stream::duplex::DuplexAddr
pub fn hyperdriver::stream::duplex::DuplexStream::info(&self) -> hyperdriver::info::ConnectionInfo<hyperdriver::stream::duplex::DuplexAddr>
impl hyperdriver::info::HasConnectionInfo for hyperdriver::stream::tcp::TcpStream
pub type hyperdriver::stream::tcp::TcpStream::Addr = core::net::socket_addr::SocketAddr
pub fn hyperdriver::stream::tcp::TcpStream::info(&self) -> hyperdriver::info::ConnectionInfo<Self::Addr>
impl hyperdriver::info::HasConnectionInfo for hyperdriver::stream::unix::UnixStream
pub type hyperdriver::stream::unix::UnixStream::Addr = hyperdriver::stream::unix::UnixAddr
pub fn hyperdriver::stream::unix::UnixStream::info(&self) -> hyperdriver::info::ConnectionInfo<Self::Addr>
impl<IO> hyperdriver::info::HasConnectionInfo for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin + core::clone::Clone
pub type hyperdriver::client::conn::stream::Stream<IO>::Addr = <IO as hyperdriver::info::HasConnectionInfo>::Addr
pub fn hyperdriver::client::conn::stream::Stream<IO>::info(&self) -> hyperdriver::info::ConnectionInfo<<IO as hyperdriver::info::HasConnectionInfo>::Addr>
impl<IO> hyperdriver::info::HasConnectionInfo for hyperdriver::client::conn::stream::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub type hyperdriver::client::conn::stream::TlsStream<IO>::Addr = <IO as hyperdriver::info::HasConnectionInfo>::Addr
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::info(&self) -> hyperdriver::info::ConnectionInfo<Self::Addr>
impl<IO> hyperdriver::info::HasConnectionInfo for hyperdriver::client::conn::stream::mock::MockTls<IO> where IO: hyperdriver::info::HasConnectionInfo
pub type hyperdriver::client::conn::stream::mock::MockTls<IO>::Addr = <IO as hyperdriver::info::HasConnectionInfo>::Addr
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::info(&self) -> hyperdriver::info::ConnectionInfo<Self::Addr>
impl<IO> hyperdriver::info::HasConnectionInfo for hyperdriver::server::conn::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub type hyperdriver::server::conn::Stream<IO>::Addr = <IO as hyperdriver::info::HasConnectionInfo>::Addr
pub fn hyperdriver::server::conn::Stream<IO>::info(&self) -> hyperdriver::info::ConnectionInfo<<IO as hyperdriver::info::HasConnectionInfo>::Addr>
impl<IO> hyperdriver::info::HasConnectionInfo for hyperdriver::server::conn::tls::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub type hyperdriver::server::conn::tls::TlsStream<IO>::Addr = <IO as hyperdriver::info::HasConnectionInfo>::Addr
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::info(&self) -> hyperdriver::info::ConnectionInfo<Self::Addr>
pub trait hyperdriver::info::HasTlsConnectionInfo: hyperdriver::info::HasConnectionInfo
pub fn hyperdriver::info::HasTlsConnectionInfo::tls_info(&self) -> core::option::Option<&hyperdriver::info::tls::TlsConnectionInfo>
impl<IO> hyperdriver::info::tls::HasTlsConnectionInfo for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin + core::clone::Clone
pub fn hyperdriver::client::conn::stream::Stream<IO>::tls_info(&self) -> core::option::Option<&hyperdriver::info::tls::TlsConnectionInfo>
impl<IO> hyperdriver::info::tls::HasTlsConnectionInfo for hyperdriver::client::conn::stream::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::tls_info(&self) -> core::option::Option<&hyperdriver::info::tls::TlsConnectionInfo>
impl<IO> hyperdriver::info::tls::HasTlsConnectionInfo for hyperdriver::client::conn::stream::mock::MockTls<IO> where IO: hyperdriver::info::HasConnectionInfo
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::tls_info(&self) -> core::option::Option<&hyperdriver::info::tls::TlsConnectionInfo>
pub mod hyperdriver::server
pub mod hyperdriver::server::conn
pub use hyperdriver::server::conn::http1
pub use hyperdriver::server::conn::http2
pub mod hyperdriver::server::conn::auto
pub struct hyperdriver::server::conn::auto::Builder<E>
impl<E> hyperdriver::server::conn::auto::Builder<E>
pub fn hyperdriver::server::conn::auto::Builder<E>::http1(&mut self) -> &mut hyper::server::conn::http1::Builder
pub fn hyperdriver::server::conn::auto::Builder<E>::http2(&mut self) -> &mut hyper::server::conn::http2::Builder<E>
pub fn hyperdriver::server::conn::auto::Builder<E>::new(executor: E) -> Self
pub fn hyperdriver::server::conn::auto::Builder<E>::serve_connection_with_upgrades<I, S, B>(&self, io: I, service: S) -> hyperdriver::server::conn::auto::UpgradableConnection<'_, I, S, E> where S: hyper::service::http::HttpService<hyper::body::incoming::Incoming, ResBody = B> + core::clone::Clone, <S as hyper::service::http::HttpService>::Future: 'static, <S as hyper::service::http::HttpService>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, B: http_body::Body + 'static, I: hyper::rt::io::Read + hyper::rt::io::Write + core::marker::Unpin + core::marker::Send + 'static
impl core::default::Default for hyperdriver::server::conn::auto::Builder
pub fn hyperdriver::server::conn::auto::Builder::default() -> Self
impl<E: core::clone::Clone> core::clone::Clone for hyperdriver::server::conn::auto::Builder<E>
pub fn hyperdriver::server::conn::auto::Builder<E>::clone(&self) -> hyperdriver::server::conn::auto::Builder<E>
impl<E: core::fmt::Debug> core::fmt::Debug for hyperdriver::server::conn::auto::Builder<E>
pub fn hyperdriver::server::conn::auto::Builder<E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S, IO, BIn, BOut, E> hyperdriver::server::Protocol<S, IO, BIn> for hyperdriver::server::conn::auto::Builder<E> where S: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>> + core::clone::Clone + core::marker::Send + 'static, <S as tower_service::Service>::Future: core::marker::Send + 'static, <S as tower_service::Service>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, BIn: http_body::Body + core::convert::From<hyper::body::incoming::Incoming> + 'static, BOut: http_body::Body + core::marker::Send + 'static, <BOut as http_body::Body>::Data: core::marker::Send + 'static, <BOut as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, IO: tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, E: hyper::rt::bounds::h2::Http2ServerConnExec<<hyperdriver::bridge::service::TowerHyperService<hyperdriver::body::AdaptIncomingService<S, BIn, BOut>> as hyper::service::http::HttpService<hyper::body::incoming::Incoming>>::Future, BOut> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::server::conn::auto::Builder<E>::Connection = Connecting<S, IO, BIn, BOut, E>
pub type hyperdriver::server::conn::auto::Builder<E>::Error = hyperdriver::server::conn::ConnectionError
pub type hyperdriver::server::conn::auto::Builder<E>::ResponseBody = BOut
pub fn hyperdriver::server::conn::auto::Builder<E>::serve_connection_with_upgrades(&self, stream: IO, service: S) -> Self::Connection
impl<E> core::marker::Freeze for hyperdriver::server::conn::auto::Builder<E> where E: core::marker::Freeze
impl<E> core::marker::Send for hyperdriver::server::conn::auto::Builder<E> where E: core::marker::Send
impl<E> core::marker::Sync for hyperdriver::server::conn::auto::Builder<E> where E: core::marker::Sync
impl<E> core::marker::Unpin for hyperdriver::server::conn::auto::Builder<E> where E: core::marker::Unpin
impl<E> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::auto::Builder<E>
impl<E> !core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::auto::Builder<E>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::auto::Builder<E> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::auto::Builder<E> where U: core::convert::From<T>
pub fn hyperdriver::server::conn::auto::Builder<E>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::auto::Builder<E> where U: core::convert::Into<T>
pub type hyperdriver::server::conn::auto::Builder<E>::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::auto::Builder<E>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::auto::Builder<E> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::auto::Builder<E>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::auto::Builder<E>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::server::conn::auto::Builder<E> where T: core::clone::Clone
pub type hyperdriver::server::conn::auto::Builder<E>::Owned = T
pub fn hyperdriver::server::conn::auto::Builder<E>::clone_into(&self, target: &mut T)
pub fn hyperdriver::server::conn::auto::Builder<E>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::server::conn::auto::Builder<E> where T: core::clone::Clone
pub fn hyperdriver::server::conn::auto::Builder<E>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::server::conn::auto::Builder<E> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::auto::Builder<E>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::auto::Builder<E> where T: core::marker::Sized
pub fn hyperdriver::server::conn::auto::Builder<E>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::auto::Builder<E> where T: core::marker::Sized
pub fn hyperdriver::server::conn::auto::Builder<E>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::server::conn::auto::Builder<E> where T: core::clone::Clone
pub unsafe fn hyperdriver::server::conn::auto::Builder<E>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::server::conn::auto::Builder<E>
pub fn hyperdriver::server::conn::auto::Builder<E>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::auto::Builder<E> where T: core::marker::Sized
pub fn hyperdriver::server::conn::auto::Builder<E>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::auto::Builder<E>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::auto::Builder<E>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::auto::Builder<E>
pub struct hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where S: hyper::service::http::HttpService<hyper::body::incoming::Incoming>
impl<'b, I, S, E, B> core::future::future::Future for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where S: hyper::service::http::HttpService<hyper::body::incoming::Incoming, ResBody = B> + core::clone::Clone, <S as hyper::service::http::HttpService>::Future: 'static, <S as hyper::service::http::HttpService>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, B: http_body::Body + 'static, <B as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, I: hyper::rt::io::Read + hyper::rt::io::Write + core::marker::Unpin + core::marker::Send + 'static, E: hyper::rt::bounds::h2::Http2ServerConnExec<<S as hyper::service::http::HttpService>::Future, B>
pub type hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::Output = core::result::Result<(), hyperdriver::server::conn::ConnectionError>
pub fn hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::poll(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<Self::Output>
impl<'b, I, S, Executor, B> hyperdriver::server::conn::Connection for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, Executor> where S: hyper::service::http::HttpService<hyper::body::incoming::Incoming, ResBody = B> + core::clone::Clone, <S as hyper::service::http::HttpService>::Future: 'static, <S as hyper::service::http::HttpService>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, B: http_body::Body + 'static, <B as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, I: hyper::rt::io::Read + hyper::rt::io::Write + core::marker::Unpin + core::marker::Send + 'static, Executor: hyper::rt::bounds::h2::Http2ServerConnExec<<S as hyper::service::http::HttpService>::Future, B>
pub fn hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, Executor>::graceful_shutdown(self: core::pin::Pin<&mut Self>)
impl<'b, I: core::fmt::Debug, S, E: core::fmt::Debug> core::fmt::Debug for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where S: hyper::service::http::HttpService<hyper::body::incoming::Incoming> + core::fmt::Debug
pub fn hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'pin, 'b, I, S, E> core::marker::Unpin for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where S: hyper::service::http::HttpService<hyper::body::incoming::Incoming>, __UpgradableConnection<'pin, 'b, I, S, E>: core::marker::Unpin
impl<'b, I, S, E> !core::marker::Freeze for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>
impl<'b, I, S, E> core::marker::Send for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where S: core::marker::Send, I: core::marker::Send, E: core::marker::Send + core::marker::Sync, <S as hyper::service::http::HttpService<hyper::body::incoming::Incoming>>::ResBody: core::marker::Send, <S as hyper::service::http::HttpService<hyper::body::incoming::Incoming>>::Future: core::marker::Send, <<S as hyper::service::http::HttpService<hyper::body::incoming::Incoming>>::ResBody as http_body::Body>::Data: core::marker::Send
impl<'b, I, S, E> core::marker::Sync for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where S: core::marker::Sync, I: core::marker::Sync, E: core::marker::Sync, <S as hyper::service::http::HttpService<hyper::body::incoming::Incoming>>::ResBody: core::marker::Sync, <S as hyper::service::http::HttpService<hyper::body::incoming::Incoming>>::Future: core::marker::Sync, <<S as hyper::service::http::HttpService<hyper::body::incoming::Incoming>>::ResBody as http_body::Body>::Data: core::marker::Sync + core::marker::Send
impl<'b, I, S, E> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>
impl<'b, I, S, E> !core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where B: http_body::Body
impl<F, T, E> futures_core::future::TryFuture for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where F: core::future::future::Future<Output = core::result::Result<T, E>> + core::marker::Sized
pub type hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::Error = E
pub type hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::Ok = T
pub fn hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::try_poll(self: core::pin::Pin<&mut F>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<<F as core::future::future::Future>::Output>
impl<F> core::future::into_future::IntoFuture for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where F: core::future::future::Future
pub type hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::IntoFuture = F
pub type hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::Output = <F as core::future::future::Future>::Output
pub fn hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::into_future(self) -> <F as core::future::into_future::IntoFuture>::IntoFuture
impl<Fut> futures_util::future::try_future::TryFutureExt for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where Fut: futures_core::future::TryFuture + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where U: core::convert::From<T>
pub fn hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where U: core::convert::Into<T>
pub type hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where T: core::marker::Sized
pub fn hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where T: core::marker::Sized
pub fn hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>
pub fn hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::from(t: T) -> T
impl<T> futures_util::future::future::FutureExt for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where T: core::future::future::Future + core::marker::Sized
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E> where T: core::marker::Sized
pub fn hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, E>
pub mod hyperdriver::server::conn::tls
pub mod hyperdriver::server::conn::tls::acceptor
pub struct hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>
impl<A> hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::new(config: alloc::sync::Arc<rustls::server::server_conn::ServerConfig>, incoming: A) -> Self
impl<'pin, A> core::marker::Unpin for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where __TlsAcceptor<'pin, A>: core::marker::Unpin
impl<A: core::fmt::Debug> core::fmt::Debug for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<A> hyperdriver::server::Accept for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where A: hyperdriver::server::Accept, <A as hyperdriver::server::Accept>::Conn: hyperdriver::info::HasConnectionInfo, <<A as hyperdriver::server::Accept>::Conn as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Unpin + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::Conn = hyperdriver::server::conn::tls::TlsStream<<A as hyperdriver::server::Accept>::Conn>
pub type hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::Error = <A as hyperdriver::server::Accept>::Error
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<Self::Conn, Self::Error>>
impl<A> core::marker::Freeze for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where A: core::marker::Freeze
impl<A> core::marker::Send for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where A: core::marker::Send
impl<A> core::marker::Sync for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where A: core::marker::Sync
impl<A> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>
impl<A> !core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where B: http_body::Body
impl<A> hyperdriver::server::conn::AcceptExt for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where A: hyperdriver::server::Accept
impl<A> hyperdriver::server::conn::tls::acceptor::TlsAcceptExt for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where A: hyperdriver::server::Accept
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where U: core::convert::From<T>
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where U: core::convert::Into<T>
pub type hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>
pub trait hyperdriver::server::conn::tls::acceptor::TlsAcceptExt: hyperdriver::server::Accept
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptExt::tls(self, config: alloc::sync::Arc<rustls::server::server_conn::ServerConfig>) -> hyperdriver::server::conn::tls::acceptor::TlsAcceptor<Self> where Self: core::marker::Sized
impl<A> hyperdriver::server::conn::tls::acceptor::TlsAcceptExt for A where A: hyperdriver::server::Accept
pub mod hyperdriver::server::conn::tls::info
pub struct hyperdriver::server::conn::tls::info::TlsConnection<S>
impl<S, BIn, BOut> tower_service::Service<http::request::Request<BIn>> for hyperdriver::server::conn::tls::info::TlsConnection<S> where S: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>> + core::clone::Clone + core::marker::Send + 'static, <S as tower_service::Service>::Future: core::marker::Send, <S as tower_service::Service>::Error: core::fmt::Display, BIn: core::marker::Send + 'static
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Error = <S as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Future = core::pin::Pin<alloc::boxed::Box<(dyn core::future::future::Future<Output = core::result::Result<<hyperdriver::server::conn::tls::info::TlsConnection<S> as tower_service::Service<http::request::Request<BIn>>>::Response, <hyperdriver::server::conn::tls::info::TlsConnection<S> as tower_service::Service<http::request::Request<BIn>>>::Error>> + core::marker::Send)>>
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Response = <S as tower_service::Service<http::request::Request<BIn>>>::Response
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::call(&mut self, req: http::request::Request<BIn>) -> Self::Future
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S: core::clone::Clone> core::clone::Clone for hyperdriver::server::conn::tls::info::TlsConnection<S>
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::clone(&self) -> hyperdriver::server::conn::tls::info::TlsConnection<S>
impl<S: core::fmt::Debug> core::fmt::Debug for hyperdriver::server::conn::tls::info::TlsConnection<S>
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S> core::marker::Freeze for hyperdriver::server::conn::tls::info::TlsConnection<S> where S: core::marker::Freeze
impl<S> core::marker::Send for hyperdriver::server::conn::tls::info::TlsConnection<S> where S: core::marker::Send
impl<S> core::marker::Sync for hyperdriver::server::conn::tls::info::TlsConnection<S> where S: core::marker::Sync
impl<S> core::marker::Unpin for hyperdriver::server::conn::tls::info::TlsConnection<S> where S: core::marker::Unpin
impl<S> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::tls::info::TlsConnection<S>
impl<S> !core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::tls::info::TlsConnection<S>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::tls::info::TlsConnection<S> where B: http_body::Body
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::server::conn::tls::info::TlsConnection<S> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::server::conn::tls::info::TlsConnection<S> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Service = S
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Service = S
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::server::conn::tls::info::TlsConnection<S> where S: tower_service::Service<R>
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::server::conn::tls::info::TlsConnection<S> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::ResBody = BOut
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::server::conn::tls::info::TlsConnection<S> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::server::conn::tls::info::TlsConnection<S> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::tls::info::TlsConnection<S> where U: core::convert::From<T>
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::tls::info::TlsConnection<S> where U: core::convert::Into<T>
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::tls::info::TlsConnection<S> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::server::conn::tls::info::TlsConnection<S> where T: core::clone::Clone
pub type hyperdriver::server::conn::tls::info::TlsConnection<S>::Owned = T
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::clone_into(&self, target: &mut T)
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::server::conn::tls::info::TlsConnection<S> where T: core::clone::Clone
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::server::conn::tls::info::TlsConnection<S> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::tls::info::TlsConnection<S> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::tls::info::TlsConnection<S> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::server::conn::tls::info::TlsConnection<S> where T: core::clone::Clone
pub unsafe fn hyperdriver::server::conn::tls::info::TlsConnection<S>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::server::conn::tls::info::TlsConnection<S>
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::tls::info::TlsConnection<S> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::tls::info::TlsConnection<S>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::tls::info::TlsConnection<S>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::tls::info::TlsConnection<S>
pub struct hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::new() -> Self
impl core::clone::Clone for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::clone(&self) -> hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl core::default::Default for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::default() -> hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl core::fmt::Debug for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S> tower_layer::Layer<S> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::Service = hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::layer(&self, inner: S) -> Self::Service
impl core::marker::Freeze for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl core::marker::Send for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl core::marker::Sync for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl core::marker::Unpin for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where U: core::convert::From<T>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where U: core::convert::Into<T>
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where T: core::clone::Clone
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::Owned = T
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::clone_into(&self, target: &mut T)
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where T: core::clone::Clone
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where T: core::clone::Clone
pub unsafe fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
pub struct hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>
impl<S> hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::new(inner: S) -> Self
impl<S, IO> tower_service::Service<&IO> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where S: hyperdriver::service::ServiceRef<IO> + core::clone::Clone + core::marker::Send + 'static, IO: TlsHandshakeInfo
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Error = <S as hyperdriver::service::ServiceRef<IO>>::Error
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Future = TlsConnectionFuture<S, IO>
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Response = hyperdriver::server::conn::tls::info::TlsConnection<<S as hyperdriver::service::ServiceRef<IO>>::Response>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::call(&mut self, stream: &IO) -> Self::Future
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S: core::clone::Clone> core::clone::Clone for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::clone(&self) -> hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>
impl<S: core::fmt::Debug> core::fmt::Debug for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S> core::marker::Freeze for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where S: core::marker::Freeze
impl<S> core::marker::Send for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where S: core::marker::Send
impl<S> core::marker::Sync for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where S: core::marker::Sync
impl<S> core::marker::Unpin for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where S: core::marker::Unpin
impl<S> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where S: core::panic::unwind_safe::RefUnwindSafe
impl<S> core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where S: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where B: http_body::Body
impl<IO, T, F, R, E> hyperdriver::service::ServiceRef<IO> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where T: for<'a> tower_service::Service<&'a IO, Future = F, Response = R, Error = E>, F: core::future::future::Future<Output = core::result::Result<R, E>>
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Error = E
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Future = F
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Response = R
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::call(&mut self, stream: &IO) -> <T as hyperdriver::service::ServiceRef<IO>>::Future
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::ServiceRef<IO>>::Error>>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Service = S
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Service = S
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where S: tower_service::Service<R>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Target, E, ME, S, F, IB, OB> hyperdriver::service::MakeServiceRef<Target, IB> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where T: for<'a> tower_service::Service<&'a Target, Error = ME, Response = S, Future = F>, E: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>, ME: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>, S: hyperdriver::service::HttpService<IB, ResBody = OB, Error = E>, F: core::future::future::Future<Output = core::result::Result<S, ME>>, IB: http_body::Body, OB: http_body::Body
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Error = E
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Future = F
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::MakeError = ME
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::ResBody = OB
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Service = S
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::make_service_ref(&mut self, target: &Target) -> <T as hyperdriver::service::MakeServiceRef<Target, IB>>::Future
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::poll_ready_ref(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::MakeServiceRef<Target, IB>>::MakeError>>
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where U: core::convert::From<T>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where U: core::convert::Into<T>
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where T: core::clone::Clone
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::Owned = T
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::clone_into(&self, target: &mut T)
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where T: core::clone::Clone
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where T: core::clone::Clone
pub unsafe fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>
pub mod hyperdriver::server::conn::tls::sni
#[non_exhaustive] pub enum hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where E: core::error::Error
pub hyperdriver::server::conn::tls::sni::SNIMiddlewareError::Inner(E)
pub hyperdriver::server::conn::tls::sni::SNIMiddlewareError::SNI(hyperdriver::server::conn::tls::sni::ValidateSNIError)
impl<E> core::convert::From<hyperdriver::server::conn::tls::sni::ValidateSNIError> for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where E: core::error::Error
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::from(source: hyperdriver::server::conn::tls::sni::ValidateSNIError) -> Self
impl<E> core::error::Error for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where E: core::error::Error, Self: core::fmt::Debug + core::fmt::Display
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl<E> core::fmt::Debug for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where E: core::error::Error + core::fmt::Debug
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<E> core::fmt::Display for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where E: core::error::Error + core::fmt::Display
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::fmt(&self, __formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<E> core::marker::Freeze for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where E: core::marker::Freeze
impl<E> core::marker::Send for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where E: core::marker::Send
impl<E> core::marker::Sync for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where E: core::marker::Sync
impl<E> core::marker::Unpin for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where E: core::marker::Unpin
impl<E> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where E: core::panic::unwind_safe::RefUnwindSafe
impl<E> core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where E: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where U: core::convert::From<T>
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where U: core::convert::Into<T>
pub type hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where T: core::fmt::Display
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>
#[non_exhaustive] pub enum hyperdriver::server::conn::tls::sni::ValidateSNIError
pub hyperdriver::server::conn::tls::sni::ValidateSNIError::InvalidSNI
pub hyperdriver::server::conn::tls::sni::ValidateSNIError::InvalidSNI::host: alloc::string::String
pub hyperdriver::server::conn::tls::sni::ValidateSNIError::InvalidSNI::sni: alloc::string::String
pub hyperdriver::server::conn::tls::sni::ValidateSNIError::MissingSNI
pub hyperdriver::server::conn::tls::sni::ValidateSNIError::MissingSNI::host: alloc::string::String
impl core::cmp::Eq for hyperdriver::server::conn::tls::sni::ValidateSNIError
impl core::cmp::PartialEq for hyperdriver::server::conn::tls::sni::ValidateSNIError
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::eq(&self, other: &hyperdriver::server::conn::tls::sni::ValidateSNIError) -> bool
impl core::error::Error for hyperdriver::server::conn::tls::sni::ValidateSNIError
impl core::fmt::Debug for hyperdriver::server::conn::tls::sni::ValidateSNIError
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::server::conn::tls::sni::ValidateSNIError
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::fmt(&self, __formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::StructuralPartialEq for hyperdriver::server::conn::tls::sni::ValidateSNIError
impl<E> core::convert::From<hyperdriver::server::conn::tls::sni::ValidateSNIError> for hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E> where E: core::error::Error
pub fn hyperdriver::server::conn::tls::sni::SNIMiddlewareError<E>::from(source: hyperdriver::server::conn::tls::sni::ValidateSNIError) -> Self
impl core::marker::Freeze for hyperdriver::server::conn::tls::sni::ValidateSNIError
impl core::marker::Send for hyperdriver::server::conn::tls::sni::ValidateSNIError
impl core::marker::Sync for hyperdriver::server::conn::tls::sni::ValidateSNIError
impl core::marker::Unpin for hyperdriver::server::conn::tls::sni::ValidateSNIError
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::tls::sni::ValidateSNIError
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::tls::sni::ValidateSNIError
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::tls::sni::ValidateSNIError where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::server::conn::tls::sni::ValidateSNIError where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::server::conn::tls::sni::ValidateSNIError where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::tls::sni::ValidateSNIError where U: core::convert::From<T>
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::tls::sni::ValidateSNIError where U: core::convert::Into<T>
pub type hyperdriver::server::conn::tls::sni::ValidateSNIError::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::tls::sni::ValidateSNIError where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::tls::sni::ValidateSNIError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for hyperdriver::server::conn::tls::sni::ValidateSNIError where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for hyperdriver::server::conn::tls::sni::ValidateSNIError where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::tls::sni::ValidateSNIError where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::tls::sni::ValidateSNIError where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::conn::tls::sni::ValidateSNIError
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::server::conn::tls::sni::ValidateSNIError where T: core::fmt::Display
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::tls::sni::ValidateSNIError where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIError::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::tls::sni::ValidateSNIError
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::tls::sni::ValidateSNIError
pub struct hyperdriver::server::conn::tls::sni::ValidateSNI
impl core::clone::Clone for hyperdriver::server::conn::tls::sni::ValidateSNI
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::clone(&self) -> hyperdriver::server::conn::tls::sni::ValidateSNI
impl core::default::Default for hyperdriver::server::conn::tls::sni::ValidateSNI
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::default() -> hyperdriver::server::conn::tls::sni::ValidateSNI
impl core::fmt::Debug for hyperdriver::server::conn::tls::sni::ValidateSNI
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S> tower_layer::Layer<S> for hyperdriver::server::conn::tls::sni::ValidateSNI
pub type hyperdriver::server::conn::tls::sni::ValidateSNI::Service = hyperdriver::server::conn::tls::sni::ValidateSNIService<S>
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::layer(&self, inner: S) -> Self::Service
impl core::marker::Freeze for hyperdriver::server::conn::tls::sni::ValidateSNI
impl core::marker::Send for hyperdriver::server::conn::tls::sni::ValidateSNI
impl core::marker::Sync for hyperdriver::server::conn::tls::sni::ValidateSNI
impl core::marker::Unpin for hyperdriver::server::conn::tls::sni::ValidateSNI
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::tls::sni::ValidateSNI
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::tls::sni::ValidateSNI
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::tls::sni::ValidateSNI where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::tls::sni::ValidateSNI where U: core::convert::From<T>
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::tls::sni::ValidateSNI where U: core::convert::Into<T>
pub type hyperdriver::server::conn::tls::sni::ValidateSNI::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::tls::sni::ValidateSNI where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::tls::sni::ValidateSNI::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::server::conn::tls::sni::ValidateSNI where T: core::clone::Clone
pub type hyperdriver::server::conn::tls::sni::ValidateSNI::Owned = T
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::clone_into(&self, target: &mut T)
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::server::conn::tls::sni::ValidateSNI where T: core::clone::Clone
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::server::conn::tls::sni::ValidateSNI where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::tls::sni::ValidateSNI where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::tls::sni::ValidateSNI where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::server::conn::tls::sni::ValidateSNI where T: core::clone::Clone
pub unsafe fn hyperdriver::server::conn::tls::sni::ValidateSNI::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::server::conn::tls::sni::ValidateSNI
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::tls::sni::ValidateSNI where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::tls::sni::ValidateSNI::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::tls::sni::ValidateSNI
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::tls::sni::ValidateSNI
pub struct hyperdriver::server::conn::tls::sni::ValidateSNIService<S>
impl<S> hyperdriver::server::conn::tls::sni::ValidateSNIService<S>
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::new(inner: S) -> Self
impl<S, BIn, BOut> tower_service::Service<http::request::Request<BIn>> for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where S: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, <S as tower_service::Service>::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::Error = hyperdriver::server::conn::tls::sni::SNIMiddlewareError<<S as tower_service::Service<http::request::Request<BIn>>>::Error>
pub type hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::Future = futures_util::future::either::Either<core::future::ready::Ready<core::result::Result<<hyperdriver::server::conn::tls::sni::ValidateSNIService<S> as tower_service::Service<http::request::Request<BIn>>>::Response, <hyperdriver::server::conn::tls::sni::ValidateSNIService<S> as tower_service::Service<http::request::Request<BIn>>>::Error>>, futures_util::future::try_future::MapErr<<S as tower_service::Service<http::request::Request<BIn>>>::Future, fn(<S as tower_service::Service<http::request::Request<BIn>>>::Error) -> <hyperdriver::server::conn::tls::sni::ValidateSNIService<S> as tower_service::Service<http::request::Request<BIn>>>::Error>>
pub type hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::Response = http::response::Response<BOut>
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::call(&mut self, req: http::request::Request<BIn>) -> Self::Future
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S: core::fmt::Debug> core::fmt::Debug for hyperdriver::server::conn::tls::sni::ValidateSNIService<S>
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S> core::clone::Clone for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where S: core::clone::Clone
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::clone(&self) -> Self
impl<S> core::marker::Freeze for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where S: core::marker::Freeze
impl<S> core::marker::Send for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where S: core::marker::Send
impl<S> core::marker::Sync for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where S: core::marker::Sync
impl<S> core::marker::Unpin for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where S: core::marker::Unpin
impl<S> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where S: core::panic::unwind_safe::RefUnwindSafe
impl<S> core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where S: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where S: tower_service::Service<R>
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::ResBody = BOut
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where U: core::convert::From<T>
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where U: core::convert::Into<T>
pub type hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where T: core::clone::Clone
pub type hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::Owned = T
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::clone_into(&self, target: &mut T)
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where T: core::clone::Clone
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where T: core::clone::Clone
pub unsafe fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::server::conn::tls::sni::ValidateSNIService<S>
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::tls::sni::ValidateSNIService<S> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::tls::sni::ValidateSNIService<S>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::tls::sni::ValidateSNIService<S>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::tls::sni::ValidateSNIService<S>
pub struct hyperdriver::server::conn::tls::TlsAcceptor<A>
impl<A> hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::new(config: alloc::sync::Arc<rustls::server::server_conn::ServerConfig>, incoming: A) -> Self
impl<'pin, A> core::marker::Unpin for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where __TlsAcceptor<'pin, A>: core::marker::Unpin
impl<A: core::fmt::Debug> core::fmt::Debug for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<A> hyperdriver::server::Accept for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where A: hyperdriver::server::Accept, <A as hyperdriver::server::Accept>::Conn: hyperdriver::info::HasConnectionInfo, <<A as hyperdriver::server::Accept>::Conn as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Unpin + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::Conn = hyperdriver::server::conn::tls::TlsStream<<A as hyperdriver::server::Accept>::Conn>
pub type hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::Error = <A as hyperdriver::server::Accept>::Error
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<Self::Conn, Self::Error>>
impl<A> core::marker::Freeze for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where A: core::marker::Freeze
impl<A> core::marker::Send for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where A: core::marker::Send
impl<A> core::marker::Sync for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where A: core::marker::Sync
impl<A> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>
impl<A> !core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where B: http_body::Body
impl<A> hyperdriver::server::conn::AcceptExt for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where A: hyperdriver::server::Accept
impl<A> hyperdriver::server::conn::tls::acceptor::TlsAcceptExt for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where A: hyperdriver::server::Accept
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where U: core::convert::From<T>
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where U: core::convert::Into<T>
pub type hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>
pub struct hyperdriver::server::conn::tls::TlsConnectionInfoLayer
impl hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::new() -> Self
impl core::clone::Clone for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::clone(&self) -> hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl core::default::Default for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::default() -> hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl core::fmt::Debug for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S> tower_layer::Layer<S> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::Service = hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::layer(&self, inner: S) -> Self::Service
impl core::marker::Freeze for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl core::marker::Send for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl core::marker::Sync for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl core::marker::Unpin for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where U: core::convert::From<T>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where U: core::convert::Into<T>
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where T: core::clone::Clone
pub type hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::Owned = T
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::clone_into(&self, target: &mut T)
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where T: core::clone::Clone
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where T: core::clone::Clone
pub unsafe fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::tls::info::TlsConnectionInfoLayer
pub struct hyperdriver::server::conn::tls::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo
impl<IO> hyperdriver::server::conn::tls::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::new(accept: tokio_rustls::Accept<IO>) -> Self
impl<IO> core::convert::From<hyperdriver::server::conn::tls::TlsStream<IO>> for hyperdriver::server::conn::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub fn hyperdriver::server::conn::Stream<IO>::from(stream: hyperdriver::server::conn::tls::TlsStream<IO>) -> Self
impl<IO> core::fmt::Debug for hyperdriver::server::conn::tls::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo + core::fmt::Debug
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<IO> hyperdriver::info::HasConnectionInfo for hyperdriver::server::conn::tls::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub type hyperdriver::server::conn::tls::TlsStream<IO>::Addr = <IO as hyperdriver::info::HasConnectionInfo>::Addr
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::info(&self) -> hyperdriver::info::ConnectionInfo<Self::Addr>
impl<IO> hyperdriver::stream::tls::TlsHandshakeStream for hyperdriver::server::conn::tls::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::poll_handshake(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
impl<IO> tokio::io::async_read::AsyncRead for hyperdriver::server::conn::tls::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &mut tokio::io::read_buf::ReadBuf<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
impl<IO> tokio::io::async_write::AsyncWrite for hyperdriver::server::conn::tls::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<std::io::error::Result<usize>>
impl<IO> core::marker::Freeze for hyperdriver::server::conn::tls::TlsStream<IO> where IO: core::marker::Freeze
impl<IO> core::marker::Send for hyperdriver::server::conn::tls::TlsStream<IO> where IO: core::marker::Send
impl<IO> core::marker::Sync for hyperdriver::server::conn::tls::TlsStream<IO> where IO: core::marker::Sync
impl<IO> core::marker::Unpin for hyperdriver::server::conn::tls::TlsStream<IO> where IO: core::marker::Unpin
impl<IO> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::tls::TlsStream<IO>
impl<IO> !core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::tls::TlsStream<IO>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::tls::TlsStream<IO> where B: http_body::Body
impl<R> tokio::io::util::async_read_ext::AsyncReadExt for hyperdriver::server::conn::tls::TlsStream<IO> where R: tokio::io::async_read::AsyncRead + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::tls::TlsStream<IO> where U: core::convert::From<T>
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::tls::TlsStream<IO> where U: core::convert::Into<T>
pub type hyperdriver::server::conn::tls::TlsStream<IO>::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::tls::TlsStream<IO> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::tls::TlsStream<IO>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::server::conn::tls::TlsStream<IO> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::tls::TlsStream<IO> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::tls::TlsStream<IO> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::conn::tls::TlsStream<IO>
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::from(t: T) -> T
impl<T> hyperdriver::stream::tls::TlsHandshakeExt for hyperdriver::server::conn::tls::TlsStream<IO> where T: hyperdriver::stream::tls::TlsHandshakeStream
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::tls::TlsStream<IO> where T: core::marker::Sized
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::tls::TlsStream<IO>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::tls::TlsStream<IO>
impl<W> tokio::io::util::async_write_ext::AsyncWriteExt for hyperdriver::server::conn::tls::TlsStream<IO> where W: tokio::io::async_write::AsyncWrite + core::marker::Sized
#[non_exhaustive] pub enum hyperdriver::server::conn::ConnectionError
pub hyperdriver::server::conn::ConnectionError::Hyper(hyper::error::Error)
pub hyperdriver::server::conn::ConnectionError::Protocol(std::io::error::Error)
pub hyperdriver::server::conn::ConnectionError::Service(alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>)
impl core::convert::From<hyper::error::Error> for hyperdriver::server::conn::ConnectionError
pub fn hyperdriver::server::conn::ConnectionError::from(source: hyper::error::Error) -> Self
impl core::error::Error for hyperdriver::server::conn::ConnectionError
pub fn hyperdriver::server::conn::ConnectionError::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl core::fmt::Debug for hyperdriver::server::conn::ConnectionError
pub fn hyperdriver::server::conn::ConnectionError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::server::conn::ConnectionError
pub fn hyperdriver::server::conn::ConnectionError::fmt(&self, __formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Freeze for hyperdriver::server::conn::ConnectionError
impl core::marker::Send for hyperdriver::server::conn::ConnectionError
impl core::marker::Sync for hyperdriver::server::conn::ConnectionError
impl core::marker::Unpin for hyperdriver::server::conn::ConnectionError
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::ConnectionError
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::ConnectionError
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::ConnectionError where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::ConnectionError where U: core::convert::From<T>
pub fn hyperdriver::server::conn::ConnectionError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::ConnectionError where U: core::convert::Into<T>
pub type hyperdriver::server::conn::ConnectionError::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::ConnectionError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::ConnectionError where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::ConnectionError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::ConnectionError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for hyperdriver::server::conn::ConnectionError where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::server::conn::ConnectionError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for hyperdriver::server::conn::ConnectionError where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::ConnectionError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::ConnectionError where T: core::marker::Sized
pub fn hyperdriver::server::conn::ConnectionError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::ConnectionError where T: core::marker::Sized
pub fn hyperdriver::server::conn::ConnectionError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::conn::ConnectionError
pub fn hyperdriver::server::conn::ConnectionError::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::server::conn::ConnectionError where T: core::fmt::Display
pub fn hyperdriver::server::conn::ConnectionError::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::ConnectionError where T: core::marker::Sized
pub fn hyperdriver::server::conn::ConnectionError::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::ConnectionError::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::ConnectionError
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::ConnectionError
pub struct hyperdriver::server::conn::AcceptOne<A>
impl<'pin, A> core::marker::Unpin for hyperdriver::server::conn::AcceptOne<A> where __AcceptOne<'pin, A>: core::marker::Unpin
impl<A: core::fmt::Debug> core::fmt::Debug for hyperdriver::server::conn::AcceptOne<A>
pub fn hyperdriver::server::conn::AcceptOne<A>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<A> core::future::future::Future for hyperdriver::server::conn::AcceptOne<A> where A: hyperdriver::server::Accept, <A as hyperdriver::server::Accept>::Conn: hyperdriver::info::HasConnectionInfo, <<A as hyperdriver::server::Accept>::Conn as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Unpin + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::server::conn::AcceptOne<A>::Output = core::result::Result<<A as hyperdriver::server::Accept>::Conn, <A as hyperdriver::server::Accept>::Error>
pub fn hyperdriver::server::conn::AcceptOne<A>::poll(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<Self::Output>
impl<A> core::marker::Freeze for hyperdriver::server::conn::AcceptOne<A> where A: core::marker::Freeze
impl<A> core::marker::Send for hyperdriver::server::conn::AcceptOne<A> where A: core::marker::Send
impl<A> core::marker::Sync for hyperdriver::server::conn::AcceptOne<A> where A: core::marker::Sync
impl<A> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::AcceptOne<A> where A: core::panic::unwind_safe::RefUnwindSafe
impl<A> core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::AcceptOne<A> where A: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::AcceptOne<A> where B: http_body::Body
impl<F, T, E> futures_core::future::TryFuture for hyperdriver::server::conn::AcceptOne<A> where F: core::future::future::Future<Output = core::result::Result<T, E>> + core::marker::Sized
pub type hyperdriver::server::conn::AcceptOne<A>::Error = E
pub type hyperdriver::server::conn::AcceptOne<A>::Ok = T
pub fn hyperdriver::server::conn::AcceptOne<A>::try_poll(self: core::pin::Pin<&mut F>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<<F as core::future::future::Future>::Output>
impl<F> core::future::into_future::IntoFuture for hyperdriver::server::conn::AcceptOne<A> where F: core::future::future::Future
pub type hyperdriver::server::conn::AcceptOne<A>::IntoFuture = F
pub type hyperdriver::server::conn::AcceptOne<A>::Output = <F as core::future::future::Future>::Output
pub fn hyperdriver::server::conn::AcceptOne<A>::into_future(self) -> <F as core::future::into_future::IntoFuture>::IntoFuture
impl<Fut> futures_util::future::try_future::TryFutureExt for hyperdriver::server::conn::AcceptOne<A> where Fut: futures_core::future::TryFuture + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::AcceptOne<A> where U: core::convert::From<T>
pub fn hyperdriver::server::conn::AcceptOne<A>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::AcceptOne<A> where U: core::convert::Into<T>
pub type hyperdriver::server::conn::AcceptOne<A>::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::AcceptOne<A>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::AcceptOne<A> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::AcceptOne<A>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::AcceptOne<A>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::server::conn::AcceptOne<A> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::AcceptOne<A>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::AcceptOne<A> where T: core::marker::Sized
pub fn hyperdriver::server::conn::AcceptOne<A>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::AcceptOne<A> where T: core::marker::Sized
pub fn hyperdriver::server::conn::AcceptOne<A>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::conn::AcceptOne<A>
pub fn hyperdriver::server::conn::AcceptOne<A>::from(t: T) -> T
impl<T> futures_util::future::future::FutureExt for hyperdriver::server::conn::AcceptOne<A> where T: core::future::future::Future + core::marker::Sized
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::AcceptOne<A> where T: core::marker::Sized
pub fn hyperdriver::server::conn::AcceptOne<A>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::AcceptOne<A>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::AcceptOne<A>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::AcceptOne<A>
pub struct hyperdriver::server::conn::Acceptor<A>
impl hyperdriver::server::conn::Acceptor
pub async fn hyperdriver::server::conn::Acceptor::bind(addr: &core::net::socket_addr::SocketAddr) -> core::result::Result<Self, std::io::error::Error>
impl<A> hyperdriver::server::conn::Acceptor<A>
pub fn hyperdriver::server::conn::Acceptor<A>::new(accept: A) -> Self
impl<A> hyperdriver::server::conn::Acceptor<A>
pub fn hyperdriver::server::conn::Acceptor<A>::with_tls(self, config: alloc::sync::Arc<rustls::server::server_conn::ServerConfig>) -> Self
impl<'pin, A> core::marker::Unpin for hyperdriver::server::conn::Acceptor<A> where __Acceptor<'pin, A>: core::marker::Unpin
impl<A: core::fmt::Debug> core::fmt::Debug for hyperdriver::server::conn::Acceptor<A>
pub fn hyperdriver::server::conn::Acceptor<A>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<A> futures_core::stream::Stream for hyperdriver::server::conn::Acceptor<A> where A: hyperdriver::server::Accept, <A as hyperdriver::server::Accept>::Conn: hyperdriver::info::HasConnectionInfo, <<A as hyperdriver::server::Accept>::Conn as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Unpin + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::server::conn::Acceptor<A>::Item = core::result::Result<hyperdriver::server::conn::Stream<<A as hyperdriver::server::Accept>::Conn>, <A as hyperdriver::server::Accept>::Error>
pub fn hyperdriver::server::conn::Acceptor<A>::poll_next(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::option::Option<Self::Item>>
impl<A> hyperdriver::server::Accept for hyperdriver::server::conn::Acceptor<A> where A: hyperdriver::server::Accept, <A as hyperdriver::server::Accept>::Conn: hyperdriver::info::HasConnectionInfo, <<A as hyperdriver::server::Accept>::Conn as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Unpin + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::server::conn::Acceptor<A>::Conn = hyperdriver::server::conn::Stream<<A as hyperdriver::server::Accept>::Conn>
pub type hyperdriver::server::conn::Acceptor<A>::Error = <A as hyperdriver::server::Accept>::Error
pub fn hyperdriver::server::conn::Acceptor<A>::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<Self::Conn, Self::Error>>
impl<T> core::convert::From<T> for hyperdriver::server::conn::Acceptor where T: core::convert::Into<hyperdriver::server::conn::AcceptorCore>
pub fn hyperdriver::server::conn::Acceptor::from(value: T) -> Self
impl<A> core::marker::Freeze for hyperdriver::server::conn::Acceptor<A> where A: core::marker::Freeze
impl<A> core::marker::Send for hyperdriver::server::conn::Acceptor<A> where A: core::marker::Send
impl<A> core::marker::Sync for hyperdriver::server::conn::Acceptor<A> where A: core::marker::Sync
impl<A> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::Acceptor<A>
impl<A> !core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::Acceptor<A>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::Acceptor<A> where B: http_body::Body
impl<A> hyperdriver::server::conn::AcceptExt for hyperdriver::server::conn::Acceptor<A> where A: hyperdriver::server::Accept
impl<A> hyperdriver::server::conn::tls::acceptor::TlsAcceptExt for hyperdriver::server::conn::Acceptor<A> where A: hyperdriver::server::Accept
impl<S, T, E> futures_core::stream::TryStream for hyperdriver::server::conn::Acceptor<A> where S: futures_core::stream::Stream<Item = core::result::Result<T, E>> + core::marker::Sized
pub type hyperdriver::server::conn::Acceptor<A>::Error = E
pub type hyperdriver::server::conn::Acceptor<A>::Ok = T
pub fn hyperdriver::server::conn::Acceptor<A>::try_poll_next(self: core::pin::Pin<&mut S>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::option::Option<core::result::Result<<S as futures_core::stream::TryStream>::Ok, <S as futures_core::stream::TryStream>::Error>>>
impl<S> futures_util::stream::try_stream::TryStreamExt for hyperdriver::server::conn::Acceptor<A> where S: futures_core::stream::TryStream + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::Acceptor<A> where U: core::convert::From<T>
pub fn hyperdriver::server::conn::Acceptor<A>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::Acceptor<A> where U: core::convert::Into<T>
pub type hyperdriver::server::conn::Acceptor<A>::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::Acceptor<A>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::Acceptor<A> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::Acceptor<A>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::Acceptor<A>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::server::conn::Acceptor<A> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::Acceptor<A>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::Acceptor<A> where T: core::marker::Sized
pub fn hyperdriver::server::conn::Acceptor<A>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::Acceptor<A> where T: core::marker::Sized
pub fn hyperdriver::server::conn::Acceptor<A>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::conn::Acceptor<A>
pub fn hyperdriver::server::conn::Acceptor<A>::from(t: T) -> T
impl<T> futures_util::stream::stream::StreamExt for hyperdriver::server::conn::Acceptor<A> where T: futures_core::stream::Stream + core::marker::Sized
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::Acceptor<A> where T: core::marker::Sized
pub fn hyperdriver::server::conn::Acceptor<A>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::Acceptor<A>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::Acceptor<A>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::Acceptor<A>
pub struct hyperdriver::server::conn::AcceptorCore
impl core::convert::From<hyperdriver::stream::duplex::DuplexIncoming> for hyperdriver::server::conn::AcceptorCore
pub fn hyperdriver::server::conn::AcceptorCore::from(value: hyperdriver::stream::duplex::DuplexIncoming) -> Self
impl core::convert::From<tokio::net::tcp::listener::TcpListener> for hyperdriver::server::conn::AcceptorCore
pub fn hyperdriver::server::conn::AcceptorCore::from(value: tokio::net::tcp::listener::TcpListener) -> Self
impl core::convert::From<tokio::net::unix::listener::UnixListener> for hyperdriver::server::conn::AcceptorCore
pub fn hyperdriver::server::conn::AcceptorCore::from(value: tokio::net::unix::listener::UnixListener) -> Self
impl core::fmt::Debug for hyperdriver::server::conn::AcceptorCore
pub fn hyperdriver::server::conn::AcceptorCore::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl hyperdriver::server::Accept for hyperdriver::server::conn::AcceptorCore
pub type hyperdriver::server::conn::AcceptorCore::Conn = hyperdriver::stream::Braid
pub type hyperdriver::server::conn::AcceptorCore::Error = std::io::error::Error
pub fn hyperdriver::server::conn::AcceptorCore::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<Self::Conn, Self::Error>>
impl<'pin> core::marker::Unpin for hyperdriver::server::conn::AcceptorCore where __AcceptorCore<'pin>: core::marker::Unpin
impl !core::marker::Freeze for hyperdriver::server::conn::AcceptorCore
impl core::marker::Send for hyperdriver::server::conn::AcceptorCore
impl core::marker::Sync for hyperdriver::server::conn::AcceptorCore
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::AcceptorCore
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::AcceptorCore
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::AcceptorCore where B: http_body::Body
impl<A> hyperdriver::server::conn::AcceptExt for hyperdriver::server::conn::AcceptorCore where A: hyperdriver::server::Accept
impl<A> hyperdriver::server::conn::tls::acceptor::TlsAcceptExt for hyperdriver::server::conn::AcceptorCore where A: hyperdriver::server::Accept
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::AcceptorCore where U: core::convert::From<T>
pub fn hyperdriver::server::conn::AcceptorCore::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::AcceptorCore where U: core::convert::Into<T>
pub type hyperdriver::server::conn::AcceptorCore::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::AcceptorCore::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::AcceptorCore where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::AcceptorCore::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::AcceptorCore::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::server::conn::AcceptorCore where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::AcceptorCore::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::AcceptorCore where T: core::marker::Sized
pub fn hyperdriver::server::conn::AcceptorCore::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::AcceptorCore where T: core::marker::Sized
pub fn hyperdriver::server::conn::AcceptorCore::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::conn::AcceptorCore
pub fn hyperdriver::server::conn::AcceptorCore::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::AcceptorCore where T: core::marker::Sized
pub fn hyperdriver::server::conn::AcceptorCore::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::AcceptorCore::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::AcceptorCore
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::AcceptorCore
pub struct hyperdriver::server::conn::ConnectionWithInfo<S, A>
impl<S, A, BIn, BOut> tower_service::Service<http::request::Request<BIn>> for hyperdriver::server::conn::ConnectionWithInfo<S, A> where S: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>> + core::clone::Clone + core::marker::Send + 'static, <S as tower_service::Service>::Future: core::marker::Send, <S as tower_service::Service>::Error: core::fmt::Display, BIn: core::marker::Send + 'static, A: core::clone::Clone + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Error = <S as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Future = <S as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Response = <S as tower_service::Service<http::request::Request<BIn>>>::Response
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::call(&mut self, req: http::request::Request<BIn>) -> Self::Future
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S: core::clone::Clone, A: core::clone::Clone> core::clone::Clone for hyperdriver::server::conn::ConnectionWithInfo<S, A>
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::clone(&self) -> hyperdriver::server::conn::ConnectionWithInfo<S, A>
impl<S: core::fmt::Debug, A: core::fmt::Debug> core::fmt::Debug for hyperdriver::server::conn::ConnectionWithInfo<S, A>
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S, A> core::marker::Freeze for hyperdriver::server::conn::ConnectionWithInfo<S, A> where S: core::marker::Freeze, A: core::marker::Freeze
impl<S, A> core::marker::Send for hyperdriver::server::conn::ConnectionWithInfo<S, A> where S: core::marker::Send, A: core::marker::Send
impl<S, A> core::marker::Sync for hyperdriver::server::conn::ConnectionWithInfo<S, A> where S: core::marker::Sync, A: core::marker::Sync
impl<S, A> core::marker::Unpin for hyperdriver::server::conn::ConnectionWithInfo<S, A> where S: core::marker::Unpin, A: core::marker::Unpin
impl<S, A> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::ConnectionWithInfo<S, A> where S: core::panic::unwind_safe::RefUnwindSafe, A: core::panic::unwind_safe::RefUnwindSafe
impl<S, A> core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::ConnectionWithInfo<S, A> where S: core::panic::unwind_safe::UnwindSafe, A: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::ConnectionWithInfo<S, A> where B: http_body::Body
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::server::conn::ConnectionWithInfo<S, A> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::server::conn::ConnectionWithInfo<S, A> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Service = S
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Service = S
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::server::conn::ConnectionWithInfo<S, A> where S: tower_service::Service<R>
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::server::conn::ConnectionWithInfo<S, A> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::ResBody = BOut
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::server::conn::ConnectionWithInfo<S, A> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::server::conn::ConnectionWithInfo<S, A> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::ConnectionWithInfo<S, A> where U: core::convert::From<T>
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::ConnectionWithInfo<S, A> where U: core::convert::Into<T>
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::ConnectionWithInfo<S, A> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::server::conn::ConnectionWithInfo<S, A> where T: core::clone::Clone
pub type hyperdriver::server::conn::ConnectionWithInfo<S, A>::Owned = T
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::clone_into(&self, target: &mut T)
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::server::conn::ConnectionWithInfo<S, A> where T: core::clone::Clone
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::server::conn::ConnectionWithInfo<S, A> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::ConnectionWithInfo<S, A> where T: core::marker::Sized
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::ConnectionWithInfo<S, A> where T: core::marker::Sized
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::server::conn::ConnectionWithInfo<S, A> where T: core::clone::Clone
pub unsafe fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::server::conn::ConnectionWithInfo<S, A>
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::ConnectionWithInfo<S, A> where T: core::marker::Sized
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::ConnectionWithInfo<S, A>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::ConnectionWithInfo<S, A>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::ConnectionWithInfo<S, A>
pub struct hyperdriver::server::conn::MakeServiceConnectionInfoLayer
impl hyperdriver::server::conn::MakeServiceConnectionInfoLayer
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::new() -> Self
impl core::clone::Clone for hyperdriver::server::conn::MakeServiceConnectionInfoLayer
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::clone(&self) -> hyperdriver::server::conn::MakeServiceConnectionInfoLayer
impl core::default::Default for hyperdriver::server::conn::MakeServiceConnectionInfoLayer
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::default() -> hyperdriver::server::conn::MakeServiceConnectionInfoLayer
impl core::fmt::Debug for hyperdriver::server::conn::MakeServiceConnectionInfoLayer
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S> tower_layer::Layer<S> for hyperdriver::server::conn::MakeServiceConnectionInfoLayer
pub type hyperdriver::server::conn::MakeServiceConnectionInfoLayer::Service = hyperdriver::server::conn::MakeServiceConnectionInfoService<S>
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::layer(&self, inner: S) -> Self::Service
impl core::marker::Freeze for hyperdriver::server::conn::MakeServiceConnectionInfoLayer
impl core::marker::Send for hyperdriver::server::conn::MakeServiceConnectionInfoLayer
impl core::marker::Sync for hyperdriver::server::conn::MakeServiceConnectionInfoLayer
impl core::marker::Unpin for hyperdriver::server::conn::MakeServiceConnectionInfoLayer
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::MakeServiceConnectionInfoLayer
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::MakeServiceConnectionInfoLayer
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::MakeServiceConnectionInfoLayer where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::MakeServiceConnectionInfoLayer where U: core::convert::From<T>
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::MakeServiceConnectionInfoLayer where U: core::convert::Into<T>
pub type hyperdriver::server::conn::MakeServiceConnectionInfoLayer::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::MakeServiceConnectionInfoLayer where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::MakeServiceConnectionInfoLayer::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::server::conn::MakeServiceConnectionInfoLayer where T: core::clone::Clone
pub type hyperdriver::server::conn::MakeServiceConnectionInfoLayer::Owned = T
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::clone_into(&self, target: &mut T)
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::server::conn::MakeServiceConnectionInfoLayer where T: core::clone::Clone
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::server::conn::MakeServiceConnectionInfoLayer where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::MakeServiceConnectionInfoLayer where T: core::marker::Sized
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::MakeServiceConnectionInfoLayer where T: core::marker::Sized
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::server::conn::MakeServiceConnectionInfoLayer where T: core::clone::Clone
pub unsafe fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::server::conn::MakeServiceConnectionInfoLayer
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::MakeServiceConnectionInfoLayer where T: core::marker::Sized
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoLayer::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::MakeServiceConnectionInfoLayer
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::MakeServiceConnectionInfoLayer
pub struct hyperdriver::server::conn::MakeServiceConnectionInfoService<C>
impl<C> hyperdriver::server::conn::MakeServiceConnectionInfoService<C>
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::new(inner: C) -> Self
impl<C, IO> tower_service::Service<&IO> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where C: hyperdriver::service::ServiceRef<IO> + core::clone::Clone + core::marker::Send + 'static, IO: hyperdriver::info::HasConnectionInfo + core::marker::Send + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Error = <C as hyperdriver::service::ServiceRef<IO>>::Error
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Future = MakeServiceConnectionInfoFuture<C, IO>
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Response = hyperdriver::server::conn::ConnectionWithInfo<<C as hyperdriver::service::ServiceRef<IO>>::Response, <IO as hyperdriver::info::HasConnectionInfo>::Addr>
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::call(&mut self, stream: &IO) -> Self::Future
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<C: core::clone::Clone> core::clone::Clone for hyperdriver::server::conn::MakeServiceConnectionInfoService<C>
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::clone(&self) -> hyperdriver::server::conn::MakeServiceConnectionInfoService<C>
impl<C: core::fmt::Debug> core::fmt::Debug for hyperdriver::server::conn::MakeServiceConnectionInfoService<C>
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<C> core::marker::Freeze for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where C: core::marker::Freeze
impl<C> core::marker::Send for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where C: core::marker::Send
impl<C> core::marker::Sync for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where C: core::marker::Sync
impl<C> core::marker::Unpin for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where C: core::marker::Unpin
impl<C> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where C: core::panic::unwind_safe::RefUnwindSafe
impl<C> core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where C: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where B: http_body::Body
impl<IO, T, F, R, E> hyperdriver::service::ServiceRef<IO> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where T: for<'a> tower_service::Service<&'a IO, Future = F, Response = R, Error = E>, F: core::future::future::Future<Output = core::result::Result<R, E>>
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Error = E
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Future = F
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Response = R
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::call(&mut self, stream: &IO) -> <T as hyperdriver::service::ServiceRef<IO>>::Future
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::ServiceRef<IO>>::Error>>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Service = S
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Service = S
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where S: tower_service::Service<R>
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Target, E, ME, S, F, IB, OB> hyperdriver::service::MakeServiceRef<Target, IB> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where T: for<'a> tower_service::Service<&'a Target, Error = ME, Response = S, Future = F>, E: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>, ME: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>, S: hyperdriver::service::HttpService<IB, ResBody = OB, Error = E>, F: core::future::future::Future<Output = core::result::Result<S, ME>>, IB: http_body::Body, OB: http_body::Body
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Error = E
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Future = F
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::MakeError = ME
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::ResBody = OB
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Service = S
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::make_service_ref(&mut self, target: &Target) -> <T as hyperdriver::service::MakeServiceRef<Target, IB>>::Future
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::poll_ready_ref(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::MakeServiceRef<Target, IB>>::MakeError>>
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where U: core::convert::From<T>
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where U: core::convert::Into<T>
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where T: core::clone::Clone
pub type hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::Owned = T
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::clone_into(&self, target: &mut T)
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where T: core::clone::Clone
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where T: core::marker::Sized
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where T: core::marker::Sized
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where T: core::clone::Clone
pub unsafe fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::server::conn::MakeServiceConnectionInfoService<C>
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::MakeServiceConnectionInfoService<C> where T: core::marker::Sized
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::MakeServiceConnectionInfoService<C>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::MakeServiceConnectionInfoService<C>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::MakeServiceConnectionInfoService<C>
pub struct hyperdriver::server::conn::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo
impl<IO> hyperdriver::server::conn::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo
pub fn hyperdriver::server::conn::Stream<IO>::new(inner: IO) -> Self
impl core::convert::From<hyperdriver::stream::Braid> for hyperdriver::server::conn::Stream
pub fn hyperdriver::server::conn::Stream::from(stream: hyperdriver::stream::Braid) -> Self
impl core::convert::From<hyperdriver::stream::duplex::DuplexStream> for hyperdriver::server::conn::Stream
pub fn hyperdriver::server::conn::Stream::from(stream: hyperdriver::stream::duplex::DuplexStream) -> Self
impl<'pin, IO> core::marker::Unpin for hyperdriver::server::conn::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo, __Stream<'pin, IO>: core::marker::Unpin
impl<IO> core::convert::From<hyperdriver::server::conn::tls::TlsStream<IO>> for hyperdriver::server::conn::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub fn hyperdriver::server::conn::Stream<IO>::from(stream: hyperdriver::server::conn::tls::TlsStream<IO>) -> Self
impl<IO> core::fmt::Debug for hyperdriver::server::conn::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + core::fmt::Debug, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::fmt::Debug
pub fn hyperdriver::server::conn::Stream<IO>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<IO> hyperdriver::info::HasConnectionInfo for hyperdriver::server::conn::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone
pub type hyperdriver::server::conn::Stream<IO>::Addr = <IO as hyperdriver::info::HasConnectionInfo>::Addr
pub fn hyperdriver::server::conn::Stream<IO>::info(&self) -> hyperdriver::info::ConnectionInfo<<IO as hyperdriver::info::HasConnectionInfo>::Addr>
impl<IO> hyperdriver::stream::tls::TlsHandshakeStream for hyperdriver::server::conn::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send + core::marker::Unpin
pub fn hyperdriver::server::conn::Stream<IO>::poll_handshake(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
impl<IO> tokio::io::async_read::AsyncRead for hyperdriver::server::conn::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin
pub fn hyperdriver::server::conn::Stream<IO>::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &mut tokio::io::read_buf::ReadBuf<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
impl<IO> tokio::io::async_write::AsyncWrite for hyperdriver::server::conn::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin
pub fn hyperdriver::server::conn::Stream<IO>::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::server::conn::Stream<IO>::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::server::conn::Stream<IO>::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
impl<IO> core::marker::Freeze for hyperdriver::server::conn::Stream<IO> where <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Freeze, IO: core::marker::Freeze
impl<IO> core::marker::Send for hyperdriver::server::conn::Stream<IO> where IO: core::marker::Send
impl<IO> core::marker::Sync for hyperdriver::server::conn::Stream<IO> where <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Sync, IO: core::marker::Sync
impl<IO> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::Stream<IO>
impl<IO> !core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::Stream<IO>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::Stream<IO> where B: http_body::Body
impl<R> tokio::io::util::async_read_ext::AsyncReadExt for hyperdriver::server::conn::Stream<IO> where R: tokio::io::async_read::AsyncRead + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::Stream<IO> where U: core::convert::From<T>
pub fn hyperdriver::server::conn::Stream<IO>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::Stream<IO> where U: core::convert::Into<T>
pub type hyperdriver::server::conn::Stream<IO>::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::Stream<IO>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::Stream<IO> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::Stream<IO>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::Stream<IO>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::server::conn::Stream<IO> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::Stream<IO>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::Stream<IO> where T: core::marker::Sized
pub fn hyperdriver::server::conn::Stream<IO>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::Stream<IO> where T: core::marker::Sized
pub fn hyperdriver::server::conn::Stream<IO>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::conn::Stream<IO>
pub fn hyperdriver::server::conn::Stream<IO>::from(t: T) -> T
impl<T> hyperdriver::stream::tls::TlsHandshakeExt for hyperdriver::server::conn::Stream<IO> where T: hyperdriver::stream::tls::TlsHandshakeStream
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::Stream<IO> where T: core::marker::Sized
pub fn hyperdriver::server::conn::Stream<IO>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::Stream<IO>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::Stream<IO>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::Stream<IO>
impl<W> tokio::io::util::async_write_ext::AsyncWriteExt for hyperdriver::server::conn::Stream<IO> where W: tokio::io::async_write::AsyncWrite + core::marker::Sized
pub trait hyperdriver::server::conn::Accept
pub type hyperdriver::server::conn::Accept::Conn: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin + 'static
pub type hyperdriver::server::conn::Accept::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub fn hyperdriver::server::conn::Accept::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<Self::Conn, Self::Error>>
impl hyperdriver::server::Accept for hyperdriver::server::conn::AcceptorCore
pub type hyperdriver::server::conn::AcceptorCore::Conn = hyperdriver::stream::Braid
pub type hyperdriver::server::conn::AcceptorCore::Error = std::io::error::Error
pub fn hyperdriver::server::conn::AcceptorCore::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<Self::Conn, Self::Error>>
impl hyperdriver::server::Accept for hyperdriver::stream::duplex::DuplexIncoming
pub type hyperdriver::stream::duplex::DuplexIncoming::Conn = hyperdriver::stream::duplex::DuplexStream
pub type hyperdriver::stream::duplex::DuplexIncoming::Error = std::io::error::Error
pub fn hyperdriver::stream::duplex::DuplexIncoming::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<Self::Conn, Self::Error>>
impl hyperdriver::server::Accept for tokio::net::tcp::listener::TcpListener
pub type tokio::net::tcp::listener::TcpListener::Conn = hyperdriver::stream::tcp::TcpStream
pub type tokio::net::tcp::listener::TcpListener::Error = std::io::error::Error
pub fn tokio::net::tcp::listener::TcpListener::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<std::io::error::Result<Self::Conn>>
impl hyperdriver::server::Accept for tokio::net::unix::listener::UnixListener
pub type tokio::net::unix::listener::UnixListener::Conn = hyperdriver::stream::unix::UnixStream
pub type tokio::net::unix::listener::UnixListener::Error = std::io::error::Error
pub fn tokio::net::unix::listener::UnixListener::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<std::io::error::Result<Self::Conn>>
impl<A> hyperdriver::server::Accept for hyperdriver::server::conn::Acceptor<A> where A: hyperdriver::server::Accept, <A as hyperdriver::server::Accept>::Conn: hyperdriver::info::HasConnectionInfo, <<A as hyperdriver::server::Accept>::Conn as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Unpin + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::server::conn::Acceptor<A>::Conn = hyperdriver::server::conn::Stream<<A as hyperdriver::server::Accept>::Conn>
pub type hyperdriver::server::conn::Acceptor<A>::Error = <A as hyperdriver::server::Accept>::Error
pub fn hyperdriver::server::conn::Acceptor<A>::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<Self::Conn, Self::Error>>
impl<A> hyperdriver::server::Accept for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where A: hyperdriver::server::Accept, <A as hyperdriver::server::Accept>::Conn: hyperdriver::info::HasConnectionInfo, <<A as hyperdriver::server::Accept>::Conn as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Unpin + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::Conn = hyperdriver::server::conn::tls::TlsStream<<A as hyperdriver::server::Accept>::Conn>
pub type hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::Error = <A as hyperdriver::server::Accept>::Error
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<Self::Conn, Self::Error>>
pub trait hyperdriver::server::conn::AcceptExt: hyperdriver::server::Accept
pub fn hyperdriver::server::conn::AcceptExt::accept(self) -> hyperdriver::server::conn::AcceptOne<Self> where Self: core::marker::Sized
impl<A> hyperdriver::server::conn::AcceptExt for A where A: hyperdriver::server::Accept
pub trait hyperdriver::server::conn::Connection
pub fn hyperdriver::server::conn::Connection::graceful_shutdown(self: core::pin::Pin<&mut Self>)
impl<'b, I, S, Executor, B> hyperdriver::server::conn::Connection for hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, Executor> where S: hyper::service::http::HttpService<hyper::body::incoming::Incoming, ResBody = B> + core::clone::Clone, <S as hyper::service::http::HttpService>::Future: 'static, <S as hyper::service::http::HttpService>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, B: http_body::Body + 'static, <B as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, I: hyper::rt::io::Read + hyper::rt::io::Write + core::marker::Unpin + core::marker::Send + 'static, Executor: hyper::rt::bounds::h2::Http2ServerConnExec<<S as hyper::service::http::HttpService>::Future, B>
pub fn hyperdriver::server::conn::auto::UpgradableConnection<'b, I, S, Executor>::graceful_shutdown(self: core::pin::Pin<&mut Self>)
impl<S, IO, BIn, BOut, E> hyperdriver::server::conn::Connection for hyper::server::conn::http2::Connection<hyperdriver::bridge::io::TokioIo<IO>, hyperdriver::bridge::service::TowerHyperService<hyperdriver::body::AdaptIncomingService<S, BIn, BOut>>, E> where S: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>> + core::clone::Clone + 'static, <S as tower_service::Service>::Future: 'static, <S as tower_service::Service>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, BIn: core::convert::From<hyper::body::incoming::Incoming> + 'static, BOut: http_body::Body + core::marker::Send + 'static, <BOut as http_body::Body>::Data: core::marker::Send + 'static, <BOut as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, IO: tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin + 'static, E: hyper::rt::bounds::h2::Http2ServerConnExec<hyperdriver::bridge::service::TowerHyperFuture<hyperdriver::body::AdaptIncomingService<S, BIn, BOut>, http::request::Request<hyper::body::incoming::Incoming>>, BOut> + core::clone::Clone + core::marker::Send + 'static
pub fn hyper::server::conn::http2::Connection<hyperdriver::bridge::io::TokioIo<IO>, hyperdriver::bridge::service::TowerHyperService<hyperdriver::body::AdaptIncomingService<S, BIn, BOut>>, E>::graceful_shutdown(self: core::pin::Pin<&mut Self>)
impl<S, IO, BIn, BOut> hyperdriver::server::conn::Connection for hyper::server::conn::http1::UpgradeableConnection<hyperdriver::bridge::io::TokioIo<IO>, hyperdriver::bridge::service::TowerHyperService<hyperdriver::body::AdaptIncomingService<S, BIn, BOut>>> where S: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>> + core::clone::Clone + core::marker::Send + 'static, <S as tower_service::Service>::Future: core::marker::Send + 'static, <S as tower_service::Service>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, BIn: core::convert::From<hyper::body::incoming::Incoming>, BOut: http_body::Body + core::marker::Send + 'static, <BOut as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, IO: tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin + 'static
pub fn hyper::server::conn::http1::UpgradeableConnection<hyperdriver::bridge::io::TokioIo<IO>, hyperdriver::bridge::service::TowerHyperService<hyperdriver::body::AdaptIncomingService<S, BIn, BOut>>>::graceful_shutdown(self: core::pin::Pin<&mut Self>)
#[non_exhaustive] pub enum hyperdriver::server::ServerError
pub hyperdriver::server::ServerError::Accept(alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>)
pub hyperdriver::server::ServerError::Io(std::io::error::Error)
pub hyperdriver::server::ServerError::MakeService(alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>)
impl core::convert::From<std::io::error::Error> for hyperdriver::server::ServerError
pub fn hyperdriver::server::ServerError::from(source: std::io::error::Error) -> Self
impl core::error::Error for hyperdriver::server::ServerError
pub fn hyperdriver::server::ServerError::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl core::fmt::Debug for hyperdriver::server::ServerError
pub fn hyperdriver::server::ServerError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::server::ServerError
pub fn hyperdriver::server::ServerError::fmt(&self, __formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Freeze for hyperdriver::server::ServerError
impl core::marker::Send for hyperdriver::server::ServerError
impl core::marker::Sync for hyperdriver::server::ServerError
impl core::marker::Unpin for hyperdriver::server::ServerError
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::ServerError
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::server::ServerError
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::ServerError where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::server::ServerError where U: core::convert::From<T>
pub fn hyperdriver::server::ServerError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::ServerError where U: core::convert::Into<T>
pub type hyperdriver::server::ServerError::Error = core::convert::Infallible
pub fn hyperdriver::server::ServerError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::ServerError where U: core::convert::TryFrom<T>
pub type hyperdriver::server::ServerError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::ServerError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for hyperdriver::server::ServerError where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::server::ServerError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for hyperdriver::server::ServerError where T: 'static + core::marker::Sized
pub fn hyperdriver::server::ServerError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::ServerError where T: core::marker::Sized
pub fn hyperdriver::server::ServerError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::ServerError where T: core::marker::Sized
pub fn hyperdriver::server::ServerError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::ServerError
pub fn hyperdriver::server::ServerError::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::server::ServerError where T: core::fmt::Display
pub fn hyperdriver::server::ServerError::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::ServerError where T: core::marker::Sized
pub fn hyperdriver::server::ServerError::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::ServerError::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::ServerError
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::ServerError
pub struct hyperdriver::server::AutoBuilder<E>
impl<E> hyperdriver::server::conn::auto::Builder<E>
pub fn hyperdriver::server::conn::auto::Builder<E>::http1(&mut self) -> &mut hyper::server::conn::http1::Builder
pub fn hyperdriver::server::conn::auto::Builder<E>::http2(&mut self) -> &mut hyper::server::conn::http2::Builder<E>
pub fn hyperdriver::server::conn::auto::Builder<E>::new(executor: E) -> Self
pub fn hyperdriver::server::conn::auto::Builder<E>::serve_connection_with_upgrades<I, S, B>(&self, io: I, service: S) -> hyperdriver::server::conn::auto::UpgradableConnection<'_, I, S, E> where S: hyper::service::http::HttpService<hyper::body::incoming::Incoming, ResBody = B> + core::clone::Clone, <S as hyper::service::http::HttpService>::Future: 'static, <S as hyper::service::http::HttpService>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, B: http_body::Body + 'static, I: hyper::rt::io::Read + hyper::rt::io::Write + core::marker::Unpin + core::marker::Send + 'static
impl core::default::Default for hyperdriver::server::conn::auto::Builder
pub fn hyperdriver::server::conn::auto::Builder::default() -> Self
impl<E: core::clone::Clone> core::clone::Clone for hyperdriver::server::conn::auto::Builder<E>
pub fn hyperdriver::server::conn::auto::Builder<E>::clone(&self) -> hyperdriver::server::conn::auto::Builder<E>
impl<E: core::fmt::Debug> core::fmt::Debug for hyperdriver::server::conn::auto::Builder<E>
pub fn hyperdriver::server::conn::auto::Builder<E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S, IO, BIn, BOut, E> hyperdriver::server::Protocol<S, IO, BIn> for hyperdriver::server::conn::auto::Builder<E> where S: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>> + core::clone::Clone + core::marker::Send + 'static, <S as tower_service::Service>::Future: core::marker::Send + 'static, <S as tower_service::Service>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, BIn: http_body::Body + core::convert::From<hyper::body::incoming::Incoming> + 'static, BOut: http_body::Body + core::marker::Send + 'static, <BOut as http_body::Body>::Data: core::marker::Send + 'static, <BOut as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, IO: tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, E: hyper::rt::bounds::h2::Http2ServerConnExec<<hyperdriver::bridge::service::TowerHyperService<hyperdriver::body::AdaptIncomingService<S, BIn, BOut>> as hyper::service::http::HttpService<hyper::body::incoming::Incoming>>::Future, BOut> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::server::conn::auto::Builder<E>::Connection = Connecting<S, IO, BIn, BOut, E>
pub type hyperdriver::server::conn::auto::Builder<E>::Error = hyperdriver::server::conn::ConnectionError
pub type hyperdriver::server::conn::auto::Builder<E>::ResponseBody = BOut
pub fn hyperdriver::server::conn::auto::Builder<E>::serve_connection_with_upgrades(&self, stream: IO, service: S) -> Self::Connection
impl<E> core::marker::Freeze for hyperdriver::server::conn::auto::Builder<E> where E: core::marker::Freeze
impl<E> core::marker::Send for hyperdriver::server::conn::auto::Builder<E> where E: core::marker::Send
impl<E> core::marker::Sync for hyperdriver::server::conn::auto::Builder<E> where E: core::marker::Sync
impl<E> core::marker::Unpin for hyperdriver::server::conn::auto::Builder<E> where E: core::marker::Unpin
impl<E> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::conn::auto::Builder<E>
impl<E> !core::panic::unwind_safe::UnwindSafe for hyperdriver::server::conn::auto::Builder<E>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::conn::auto::Builder<E> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::server::conn::auto::Builder<E> where U: core::convert::From<T>
pub fn hyperdriver::server::conn::auto::Builder<E>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::conn::auto::Builder<E> where U: core::convert::Into<T>
pub type hyperdriver::server::conn::auto::Builder<E>::Error = core::convert::Infallible
pub fn hyperdriver::server::conn::auto::Builder<E>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::conn::auto::Builder<E> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::conn::auto::Builder<E>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::conn::auto::Builder<E>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::server::conn::auto::Builder<E> where T: core::clone::Clone
pub type hyperdriver::server::conn::auto::Builder<E>::Owned = T
pub fn hyperdriver::server::conn::auto::Builder<E>::clone_into(&self, target: &mut T)
pub fn hyperdriver::server::conn::auto::Builder<E>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::server::conn::auto::Builder<E> where T: core::clone::Clone
pub fn hyperdriver::server::conn::auto::Builder<E>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::server::conn::auto::Builder<E> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::conn::auto::Builder<E>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::conn::auto::Builder<E> where T: core::marker::Sized
pub fn hyperdriver::server::conn::auto::Builder<E>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::conn::auto::Builder<E> where T: core::marker::Sized
pub fn hyperdriver::server::conn::auto::Builder<E>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::server::conn::auto::Builder<E> where T: core::clone::Clone
pub unsafe fn hyperdriver::server::conn::auto::Builder<E>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::server::conn::auto::Builder<E>
pub fn hyperdriver::server::conn::auto::Builder<E>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::conn::auto::Builder<E> where T: core::marker::Sized
pub fn hyperdriver::server::conn::auto::Builder<E>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::conn::auto::Builder<E>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::conn::auto::Builder<E>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::conn::auto::Builder<E>
pub struct hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept
impl<'pin, A, P, S, B, E, F> core::marker::Unpin for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept, __GracefulShutdown<'pin, A, P, S, B, E, F>: core::marker::Unpin
impl<A, P, S, B, E, F> core::fmt::Debug for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept
pub fn hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<A, P, S, Body, E, F> core::future::future::Future for hyperdriver::server::GracefulShutdown<A, P, S, Body, E, F> where S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, Body>, P: hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef>::Service, <A as hyperdriver::server::Accept>::Conn, Body>, A: hyperdriver::server::Accept + core::marker::Unpin, <A as hyperdriver::server::Accept>::Conn: hyperdriver::info::HasConnectionInfo, F: core::future::future::Future<Output = ()>, E: hyperdriver::server::GracefulServerExecutor<P, S, A, Body>
pub type hyperdriver::server::GracefulShutdown<A, P, S, Body, E, F>::Output = core::result::Result<(), hyperdriver::server::ServerError>
pub fn hyperdriver::server::GracefulShutdown<A, P, S, Body, E, F>::poll(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<Self::Output>
impl<A, P, S, B, E, F> core::marker::Freeze for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where F: core::marker::Freeze, A: core::marker::Freeze, P: core::marker::Freeze, S: core::marker::Freeze, E: core::marker::Freeze, <S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Future: core::marker::Freeze, <A as hyperdriver::server::Accept>::Conn: core::marker::Freeze
impl<A, P, S, B, E, F> core::marker::Send for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where F: core::marker::Send, A: core::marker::Send, P: core::marker::Send, S: core::marker::Send, E: core::marker::Send, <S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Future: core::marker::Send, <A as hyperdriver::server::Accept>::Conn: core::marker::Send
impl<A, P, S, B, E, F> !core::marker::Sync for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>
impl<A, P, S, B, E, F> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>
impl<A, P, S, B, E, F> !core::panic::unwind_safe::UnwindSafe for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where B: http_body::Body
impl<F, T, E> futures_core::future::TryFuture for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where F: core::future::future::Future<Output = core::result::Result<T, E>> + core::marker::Sized
pub type hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::Error = E
pub type hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::Ok = T
pub fn hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::try_poll(self: core::pin::Pin<&mut F>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<<F as core::future::future::Future>::Output>
impl<F> core::future::into_future::IntoFuture for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where F: core::future::future::Future
pub type hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::IntoFuture = F
pub type hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::Output = <F as core::future::future::Future>::Output
pub fn hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::into_future(self) -> <F as core::future::into_future::IntoFuture>::IntoFuture
impl<Fut> futures_util::future::try_future::TryFutureExt for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where Fut: futures_core::future::TryFuture + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where U: core::convert::From<T>
pub fn hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where U: core::convert::Into<T>
pub type hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::Error = core::convert::Infallible
pub fn hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where T: core::marker::Sized
pub fn hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where T: core::marker::Sized
pub fn hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>
pub fn hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::from(t: T) -> T
impl<T> futures_util::future::future::FutureExt for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where T: core::future::future::Future + core::marker::Sized
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where T: core::marker::Sized
pub fn hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::GracefulShutdown<A, P, S, B, E, F>
pub struct hyperdriver::server::Server<A, P, S, B, E>
impl hyperdriver::server::Server<(), (), (), (), ()>
pub fn hyperdriver::server::Server<(), (), (), (), ()>::builder<B>() -> hyperdriver::server::Server<NeedsAcceptor, NeedsProtocol, NeedsService, B, NeedsExecutor>
impl<A, P, B, E> hyperdriver::server::Server<A, P, NeedsService, B, E>
pub fn hyperdriver::server::Server<A, P, NeedsService, B, E>::with_make_service<S>(self, make_service: S) -> hyperdriver::server::Server<A, P, S, B, E>
pub fn hyperdriver::server::Server<A, P, NeedsService, B, E>::with_shared_service<S>(self, service: S) -> hyperdriver::server::Server<A, P, tower::make::make_service::shared::Shared<S>, B, E>
impl<A, P, S, B, E> hyperdriver::server::Server<A, P, S, B, E> where S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept
pub fn hyperdriver::server::Server<A, P, S, B, E>::with_connection_info(self) -> hyperdriver::server::Server<A, P, hyperdriver::server::conn::MakeServiceConnectionInfoService<S>, B, E>
pub fn hyperdriver::server::Server<A, P, S, B, E>::with_tls_connection_info(self) -> hyperdriver::server::Server<A, P, hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>, B, E>
impl<A, P, S, B, E> hyperdriver::server::Server<A, P, S, B, E>
pub fn hyperdriver::server::Server<A, P, S, B, E>::new(acceptor: A, protocol: P, make_service: S, executor: E) -> Self
pub fn hyperdriver::server::Server<A, P, S, B, E>::with_graceful_shutdown<F>(self, signal: F) -> hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, P: hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef>::Service, <A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept + core::marker::Unpin, B: http_body::Body, F: core::future::future::Future<Output = ()> + core::marker::Send + 'static, E: hyperdriver::server::ServerExecutor<P, S, A, B>
impl<A, P, S, B, E> hyperdriver::server::Server<A, P, S, B, E>
pub fn hyperdriver::server::Server<A, P, S, B, E>::with_body<B2>(self) -> hyperdriver::server::Server<A, P, S, B2, E>
impl<A, P, S, B> hyperdriver::server::Server<A, P, S, B, NeedsExecutor>
pub fn hyperdriver::server::Server<A, P, S, B, NeedsExecutor>::with_executor<E>(self, executor: E) -> hyperdriver::server::Server<A, P, S, B, E>
pub fn hyperdriver::server::Server<A, P, S, B, NeedsExecutor>::with_tokio(self) -> hyperdriver::server::Server<A, P, S, B, hyperdriver::bridge::rt::TokioExecutor>
impl<A, S, B, E> hyperdriver::server::Server<A, NeedsProtocol, S, B, E>
pub fn hyperdriver::server::Server<A, NeedsProtocol, S, B, E>::with_auto_http(self) -> hyperdriver::server::Server<A, hyperdriver::server::conn::auto::Builder, S, B, E>
pub fn hyperdriver::server::Server<A, NeedsProtocol, S, B, E>::with_http1(self) -> hyperdriver::server::Server<A, hyper::server::conn::http1::Builder, S, B, E>
pub fn hyperdriver::server::Server<A, NeedsProtocol, S, B, E>::with_http2(self) -> hyperdriver::server::Server<A, hyper::server::conn::http2::Builder<hyperdriver::bridge::rt::TokioExecutor>, S, B, E>
pub fn hyperdriver::server::Server<A, NeedsProtocol, S, B, E>::with_protocol<P>(self, protocol: P) -> hyperdriver::server::Server<A, P, S, B, E>
impl<P, S, B, E> hyperdriver::server::Server<NeedsAcceptor, P, S, B, E>
pub fn hyperdriver::server::Server<NeedsAcceptor, P, S, B, E>::with_acceptor<A>(self, acceptor: A) -> hyperdriver::server::Server<A, P, S, B, E> where A: hyperdriver::server::Accept
pub async fn hyperdriver::server::Server<NeedsAcceptor, P, S, B, E>::with_bind(self, addr: &core::net::socket_addr::SocketAddr) -> core::result::Result<hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, P, S, B, E>, std::io::error::Error>
pub fn hyperdriver::server::Server<NeedsAcceptor, P, S, B, E>::with_incoming<I>(self, incoming: I) -> hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, P, S, B, E> where I: core::convert::Into<hyperdriver::server::conn::Acceptor> + core::convert::Into<hyperdriver::server::conn::AcceptorCore>
pub async fn hyperdriver::server::Server<NeedsAcceptor, P, S, B, E>::with_listener(self, listener: tokio::net::tcp::listener::TcpListener) -> hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, P, S, B, E>
impl<P, S, B, E> hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, P, S, B, E>
pub fn hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, P, S, B, E>::with_tls<C>(self, config: C) -> hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, P, S, B, E> where C: core::convert::Into<alloc::sync::Arc<rustls::server::server_conn::ServerConfig>>
impl<S, B> hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, hyperdriver::server::conn::auto::Builder<hyperdriver::bridge::rt::TokioExecutor>, S, B, hyperdriver::bridge::rt::TokioExecutor>
pub async fn hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, hyperdriver::server::conn::auto::Builder<hyperdriver::bridge::rt::TokioExecutor>, S, B, hyperdriver::bridge::rt::TokioExecutor>::bind<A: tokio::net::addr::ToSocketAddrs>(addr: A, make_service: S) -> std::io::error::Result<Self>
impl<A, P, S, B, E> core::fmt::Debug for hyperdriver::server::Server<A, P, S, B, E>
pub fn hyperdriver::server::Server<A, P, S, B, E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<A, P, S, B, E> core::future::into_future::IntoFuture for hyperdriver::server::Server<A, P, S, B, E> where S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, P: hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef>::Service, <A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept + core::marker::Unpin, B: http_body::Body, E: hyperdriver::server::ServerExecutor<P, S, A, B>
pub type hyperdriver::server::Server<A, P, S, B, E>::IntoFuture = hyperdriver::server::Serving<A, P, S, B, E>
pub type hyperdriver::server::Server<A, P, S, B, E>::Output = core::result::Result<(), hyperdriver::server::ServerError>
pub fn hyperdriver::server::Server<A, P, S, B, E>::into_future(self) -> Self::IntoFuture
impl<A, P, S, B, E> core::marker::Freeze for hyperdriver::server::Server<A, P, S, B, E> where A: core::marker::Freeze, P: core::marker::Freeze, S: core::marker::Freeze, E: core::marker::Freeze
impl<A, P, S, B, E> core::marker::Send for hyperdriver::server::Server<A, P, S, B, E> where A: core::marker::Send, P: core::marker::Send, S: core::marker::Send, E: core::marker::Send
impl<A, P, S, B, E> core::marker::Sync for hyperdriver::server::Server<A, P, S, B, E> where A: core::marker::Sync, P: core::marker::Sync, S: core::marker::Sync, E: core::marker::Sync
impl<A, P, S, B, E> core::marker::Unpin for hyperdriver::server::Server<A, P, S, B, E> where A: core::marker::Unpin, P: core::marker::Unpin, S: core::marker::Unpin, E: core::marker::Unpin
impl<A, P, S, B, E> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::Server<A, P, S, B, E> where A: core::panic::unwind_safe::RefUnwindSafe, P: core::panic::unwind_safe::RefUnwindSafe, S: core::panic::unwind_safe::RefUnwindSafe, E: core::panic::unwind_safe::RefUnwindSafe
impl<A, P, S, B, E> core::panic::unwind_safe::UnwindSafe for hyperdriver::server::Server<A, P, S, B, E> where A: core::panic::unwind_safe::UnwindSafe, P: core::panic::unwind_safe::UnwindSafe, S: core::panic::unwind_safe::UnwindSafe, E: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::Server<A, P, S, B, E> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::server::Server<A, P, S, B, E> where U: core::convert::From<T>
pub fn hyperdriver::server::Server<A, P, S, B, E>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::Server<A, P, S, B, E> where U: core::convert::Into<T>
pub type hyperdriver::server::Server<A, P, S, B, E>::Error = core::convert::Infallible
pub fn hyperdriver::server::Server<A, P, S, B, E>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::Server<A, P, S, B, E> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::Server<A, P, S, B, E>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::Server<A, P, S, B, E>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::server::Server<A, P, S, B, E> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::Server<A, P, S, B, E>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::Server<A, P, S, B, E> where T: core::marker::Sized
pub fn hyperdriver::server::Server<A, P, S, B, E>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::Server<A, P, S, B, E> where T: core::marker::Sized
pub fn hyperdriver::server::Server<A, P, S, B, E>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::Server<A, P, S, B, E>
pub fn hyperdriver::server::Server<A, P, S, B, E>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::Server<A, P, S, B, E> where T: core::marker::Sized
pub fn hyperdriver::server::Server<A, P, S, B, E>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::Server<A, P, S, B, E>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::Server<A, P, S, B, E>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::Server<A, P, S, B, E>
pub struct hyperdriver::server::Serving<A, P, S, B, E> where S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept
impl<'pin, A, P, S, B, E> core::marker::Unpin for hyperdriver::server::Serving<A, P, S, B, E> where S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept, __Serving<'pin, A, P, S, B, E>: core::marker::Unpin
impl<A, P, S, B, E> core::future::future::Future for hyperdriver::server::Serving<A, P, S, B, E> where S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, P: hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef>::Service, <A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept + core::marker::Unpin, B: http_body::Body, E: hyperdriver::server::ServerExecutor<P, S, A, B>
pub type hyperdriver::server::Serving<A, P, S, B, E>::Output = core::result::Result<(), hyperdriver::server::ServerError>
pub fn hyperdriver::server::Serving<A, P, S, B, E>::poll(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<Self::Output>
impl<A, P: core::fmt::Debug, S, B: core::fmt::Debug, E: core::fmt::Debug> core::fmt::Debug for hyperdriver::server::Serving<A, P, S, B, E> where S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B> + core::fmt::Debug, A: hyperdriver::server::Accept + core::fmt::Debug, <A as hyperdriver::server::Accept>::Conn: core::fmt::Debug, <S as hyperdriver::service::MakeServiceRef>::Future: core::fmt::Debug
pub fn hyperdriver::server::Serving<A, P, S, B, E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<A, P, S, B, E> core::marker::Freeze for hyperdriver::server::Serving<A, P, S, B, E> where A: core::marker::Freeze, P: core::marker::Freeze, S: core::marker::Freeze, E: core::marker::Freeze, <S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Future: core::marker::Freeze, <A as hyperdriver::server::Accept>::Conn: core::marker::Freeze
impl<A, P, S, B, E> core::marker::Send for hyperdriver::server::Serving<A, P, S, B, E> where A: core::marker::Send, P: core::marker::Send, S: core::marker::Send, E: core::marker::Send, <S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Future: core::marker::Send, <A as hyperdriver::server::Accept>::Conn: core::marker::Send
impl<A, P, S, B, E> core::marker::Sync for hyperdriver::server::Serving<A, P, S, B, E> where A: core::marker::Sync, P: core::marker::Sync, S: core::marker::Sync, E: core::marker::Sync, <S as hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>>::Future: core::marker::Sync, <A as hyperdriver::server::Accept>::Conn: core::marker::Sync
impl<A, P, S, B, E> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::Serving<A, P, S, B, E>
impl<A, P, S, B, E> !core::panic::unwind_safe::UnwindSafe for hyperdriver::server::Serving<A, P, S, B, E>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::Serving<A, P, S, B, E> where B: http_body::Body
impl<F, T, E> futures_core::future::TryFuture for hyperdriver::server::Serving<A, P, S, B, E> where F: core::future::future::Future<Output = core::result::Result<T, E>> + core::marker::Sized
pub type hyperdriver::server::Serving<A, P, S, B, E>::Error = E
pub type hyperdriver::server::Serving<A, P, S, B, E>::Ok = T
pub fn hyperdriver::server::Serving<A, P, S, B, E>::try_poll(self: core::pin::Pin<&mut F>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<<F as core::future::future::Future>::Output>
impl<F> core::future::into_future::IntoFuture for hyperdriver::server::Serving<A, P, S, B, E> where F: core::future::future::Future
pub type hyperdriver::server::Serving<A, P, S, B, E>::IntoFuture = F
pub type hyperdriver::server::Serving<A, P, S, B, E>::Output = <F as core::future::future::Future>::Output
pub fn hyperdriver::server::Serving<A, P, S, B, E>::into_future(self) -> <F as core::future::into_future::IntoFuture>::IntoFuture
impl<Fut> futures_util::future::try_future::TryFutureExt for hyperdriver::server::Serving<A, P, S, B, E> where Fut: futures_core::future::TryFuture + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::server::Serving<A, P, S, B, E> where U: core::convert::From<T>
pub fn hyperdriver::server::Serving<A, P, S, B, E>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::Serving<A, P, S, B, E> where U: core::convert::Into<T>
pub type hyperdriver::server::Serving<A, P, S, B, E>::Error = core::convert::Infallible
pub fn hyperdriver::server::Serving<A, P, S, B, E>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::Serving<A, P, S, B, E> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::Serving<A, P, S, B, E>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::Serving<A, P, S, B, E>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::server::Serving<A, P, S, B, E> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::Serving<A, P, S, B, E>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::Serving<A, P, S, B, E> where T: core::marker::Sized
pub fn hyperdriver::server::Serving<A, P, S, B, E>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::Serving<A, P, S, B, E> where T: core::marker::Sized
pub fn hyperdriver::server::Serving<A, P, S, B, E>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::Serving<A, P, S, B, E>
pub fn hyperdriver::server::Serving<A, P, S, B, E>::from(t: T) -> T
impl<T> futures_util::future::future::FutureExt for hyperdriver::server::Serving<A, P, S, B, E> where T: core::future::future::Future + core::marker::Sized
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::Serving<A, P, S, B, E> where T: core::marker::Sized
pub fn hyperdriver::server::Serving<A, P, S, B, E>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::Serving<A, P, S, B, E>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::Serving<A, P, S, B, E>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::Serving<A, P, S, B, E>
pub trait hyperdriver::server::Accept
pub type hyperdriver::server::Accept::Conn: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin + 'static
pub type hyperdriver::server::Accept::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub fn hyperdriver::server::Accept::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<Self::Conn, Self::Error>>
impl hyperdriver::server::Accept for hyperdriver::server::conn::AcceptorCore
pub type hyperdriver::server::conn::AcceptorCore::Conn = hyperdriver::stream::Braid
pub type hyperdriver::server::conn::AcceptorCore::Error = std::io::error::Error
pub fn hyperdriver::server::conn::AcceptorCore::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<Self::Conn, Self::Error>>
impl hyperdriver::server::Accept for hyperdriver::stream::duplex::DuplexIncoming
pub type hyperdriver::stream::duplex::DuplexIncoming::Conn = hyperdriver::stream::duplex::DuplexStream
pub type hyperdriver::stream::duplex::DuplexIncoming::Error = std::io::error::Error
pub fn hyperdriver::stream::duplex::DuplexIncoming::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<Self::Conn, Self::Error>>
impl hyperdriver::server::Accept for tokio::net::tcp::listener::TcpListener
pub type tokio::net::tcp::listener::TcpListener::Conn = hyperdriver::stream::tcp::TcpStream
pub type tokio::net::tcp::listener::TcpListener::Error = std::io::error::Error
pub fn tokio::net::tcp::listener::TcpListener::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<std::io::error::Result<Self::Conn>>
impl hyperdriver::server::Accept for tokio::net::unix::listener::UnixListener
pub type tokio::net::unix::listener::UnixListener::Conn = hyperdriver::stream::unix::UnixStream
pub type tokio::net::unix::listener::UnixListener::Error = std::io::error::Error
pub fn tokio::net::unix::listener::UnixListener::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<std::io::error::Result<Self::Conn>>
impl<A> hyperdriver::server::Accept for hyperdriver::server::conn::Acceptor<A> where A: hyperdriver::server::Accept, <A as hyperdriver::server::Accept>::Conn: hyperdriver::info::HasConnectionInfo, <<A as hyperdriver::server::Accept>::Conn as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Unpin + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::server::conn::Acceptor<A>::Conn = hyperdriver::server::conn::Stream<<A as hyperdriver::server::Accept>::Conn>
pub type hyperdriver::server::conn::Acceptor<A>::Error = <A as hyperdriver::server::Accept>::Error
pub fn hyperdriver::server::conn::Acceptor<A>::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<Self::Conn, Self::Error>>
impl<A> hyperdriver::server::Accept for hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A> where A: hyperdriver::server::Accept, <A as hyperdriver::server::Accept>::Conn: hyperdriver::info::HasConnectionInfo, <<A as hyperdriver::server::Accept>::Conn as hyperdriver::info::HasConnectionInfo>::Addr: core::clone::Clone + core::marker::Unpin + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::Conn = hyperdriver::server::conn::tls::TlsStream<<A as hyperdriver::server::Accept>::Conn>
pub type hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::Error = <A as hyperdriver::server::Accept>::Error
pub fn hyperdriver::server::conn::tls::acceptor::TlsAcceptor<A>::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<Self::Conn, Self::Error>>
pub trait hyperdriver::server::GracefulServerExecutor<P, S, A, B> where P: hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef>::Service, <A as hyperdriver::server::Accept>::Conn, B>, S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept: hyper::rt::Executor<GracefulConnectionDriver<tracing::instrument::Instrumented<<P as hyperdriver::server::Protocol>::Connection>, <P as hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef>::Service, <A as hyperdriver::server::Accept>::Conn, B>>::Error>> + hyperdriver::server::ServerExecutor<P, S, A, B> + Sealed<(P, S, A, B, ())>
impl<P, S, A, B, E> hyperdriver::server::GracefulServerExecutor<P, S, A, B> for E where P: hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef>::Service, <A as hyperdriver::server::Accept>::Conn, B>, S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept, E: hyperdriver::server::ServerExecutor<P, S, A, B> + hyper::rt::Executor<GracefulConnectionDriver<tracing::instrument::Instrumented<<P as hyperdriver::server::Protocol>::Connection>, <P as hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef>::Service, <A as hyperdriver::server::Accept>::Conn, B>>::Error>> + Sealed<(P, S, A, B, ())>
pub trait hyperdriver::server::Protocol<S, IO, B>
pub type hyperdriver::server::Protocol::Connection: hyperdriver::server::conn::Connection + core::future::future::Future<Output = core::result::Result<(), Self::Error>> + 'static
pub type hyperdriver::server::Protocol::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub type hyperdriver::server::Protocol::ResponseBody: http_body::Body + core::marker::Send + 'static
pub fn hyperdriver::server::Protocol::serve_connection_with_upgrades(&self, stream: IO, service: S) -> Self::Connection
impl<S, IO, BIn, BOut, E> hyperdriver::server::Protocol<S, IO, BIn> for hyper::server::conn::http2::Builder<E> where S: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>> + core::clone::Clone + 'static, <S as tower_service::Service>::Future: 'static, <S as tower_service::Service>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, BIn: http_body::Body + core::convert::From<hyper::body::incoming::Incoming> + core::marker::Send + 'static, BOut: http_body::Body + core::marker::Send + 'static, <BOut as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, <BOut as http_body::Body>::Data: core::marker::Send + 'static, IO: tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin + 'static, E: hyper::rt::bounds::h2::Http2ServerConnExec<hyperdriver::bridge::service::TowerHyperFuture<hyperdriver::body::AdaptIncomingService<S, BIn, BOut>, http::request::Request<hyper::body::incoming::Incoming>>, BOut> + core::clone::Clone + core::marker::Send + 'static
pub type hyper::server::conn::http2::Builder<E>::Connection = hyper::server::conn::http2::Connection<hyperdriver::bridge::io::TokioIo<IO>, hyperdriver::bridge::service::TowerHyperService<hyperdriver::body::AdaptIncomingService<S, BIn, BOut>>, E>
pub type hyper::server::conn::http2::Builder<E>::Error = hyper::error::Error
pub type hyper::server::conn::http2::Builder<E>::ResponseBody = BOut
pub fn hyper::server::conn::http2::Builder<E>::serve_connection_with_upgrades(&self, stream: IO, service: S) -> Self::Connection
impl<S, IO, BIn, BOut, E> hyperdriver::server::Protocol<S, IO, BIn> for hyperdriver::server::conn::auto::Builder<E> where S: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>> + core::clone::Clone + core::marker::Send + 'static, <S as tower_service::Service>::Future: core::marker::Send + 'static, <S as tower_service::Service>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, BIn: http_body::Body + core::convert::From<hyper::body::incoming::Incoming> + 'static, BOut: http_body::Body + core::marker::Send + 'static, <BOut as http_body::Body>::Data: core::marker::Send + 'static, <BOut as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, IO: tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, E: hyper::rt::bounds::h2::Http2ServerConnExec<<hyperdriver::bridge::service::TowerHyperService<hyperdriver::body::AdaptIncomingService<S, BIn, BOut>> as hyper::service::http::HttpService<hyper::body::incoming::Incoming>>::Future, BOut> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static
pub type hyperdriver::server::conn::auto::Builder<E>::Connection = Connecting<S, IO, BIn, BOut, E>
pub type hyperdriver::server::conn::auto::Builder<E>::Error = hyperdriver::server::conn::ConnectionError
pub type hyperdriver::server::conn::auto::Builder<E>::ResponseBody = BOut
pub fn hyperdriver::server::conn::auto::Builder<E>::serve_connection_with_upgrades(&self, stream: IO, service: S) -> Self::Connection
impl<S, IO, BIn, BOut> hyperdriver::server::Protocol<S, IO, BIn> for hyper::server::conn::http1::Builder where S: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>> + core::clone::Clone + core::marker::Send + 'static, <S as tower_service::Service>::Future: core::marker::Send + 'static, <S as tower_service::Service>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, BIn: core::convert::From<hyper::body::incoming::Incoming> + core::marker::Send + 'static, BOut: http_body::Body + core::marker::Send + 'static, <BOut as http_body::Body>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, <BOut as http_body::Body>::Data: core::marker::Send, IO: tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static
pub type hyper::server::conn::http1::Builder::Connection = hyper::server::conn::http1::UpgradeableConnection<hyperdriver::bridge::io::TokioIo<IO>, hyperdriver::bridge::service::TowerHyperService<hyperdriver::body::AdaptIncomingService<S, BIn, BOut>>>
pub type hyper::server::conn::http1::Builder::Error = hyper::error::Error
pub type hyper::server::conn::http1::Builder::ResponseBody = BOut
pub fn hyper::server::conn::http1::Builder::serve_connection_with_upgrades(&self, stream: IO, service: S) -> Self::Connection where IO: tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin + 'static
pub trait hyperdriver::server::ServerExecutor<P, S, A, B> where P: hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef>::Service, <A as hyperdriver::server::Accept>::Conn, B>, S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept: hyper::rt::Executor<ConnectionDriver<tracing::instrument::Instrumented<<P as hyperdriver::server::Protocol>::Connection>, <P as hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef>::Service, <A as hyperdriver::server::Accept>::Conn, B>>::Error>> + Sealed<(P, S, A, B)>
impl<P, S, A, B, E> hyperdriver::server::ServerExecutor<P, S, A, B> for E where P: hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef>::Service, <A as hyperdriver::server::Accept>::Conn, B>, S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept, E: hyper::rt::Executor<ConnectionDriver<tracing::instrument::Instrumented<<P as hyperdriver::server::Protocol>::Connection>, <P as hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef>::Service, <A as hyperdriver::server::Accept>::Conn, B>>::Error>>
pub mod hyperdriver::service
pub use hyperdriver::service::Service
pub use hyperdriver::service::ServiceBuilder
pub use hyperdriver::service::ServiceExt
pub use hyperdriver::service::service_fn
pub struct hyperdriver::service::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::new() -> Self
impl<BIn, BOut, S> tower_layer::Layer<S> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Service = hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::layer(&self, inner: S) -> Self::Service
impl<BIn, BOut> core::default::Default for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::default() -> Self
impl<BIn: core::clone::Clone, BOut: core::clone::Clone> core::clone::Clone for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::clone(&self) -> hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn: core::fmt::Debug, BOut: core::fmt::Debug> core::fmt::Debug for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<BIn, BOut> core::marker::Freeze for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::marker::Send for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::marker::Sync for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::marker::Unpin for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::panic::unwind_safe::UnwindSafe for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where U: core::convert::From<T>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where U: core::convert::Into<T>
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Error = core::convert::Infallible
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where U: core::convert::TryFrom<T>
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::clone::Clone
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Owned = T
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::clone_into(&self, target: &mut T)
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::clone::Clone
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: 'static + core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::clone::Clone
pub unsafe fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub struct hyperdriver::service::AdaptIncomingService<S, BIn, BOut>
impl<S, BIn, BOut> hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::new(inner: S) -> Self
impl<S: core::clone::Clone, BIn, BOut> core::clone::Clone for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::clone(&self) -> Self
impl<S: core::default::Default, BIn, BOut> core::default::Default for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::default() -> Self
impl<S: core::fmt::Debug, BIn, BOut> core::fmt::Debug for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T, BIn, BOut> tower_service::Service<http::request::Request<hyper::body::incoming::Incoming>> for hyperdriver::body::AdaptIncomingService<T, BIn, BOut> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BIn: core::convert::From<hyper::body::incoming::Incoming>
pub type hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::Response = http::response::Response<BOut>
pub fn hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::call(&mut self, req: http::request::Request<hyper::body::incoming::Incoming>) -> Self::Future
pub fn hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S, BIn, BOut> core::marker::Freeze for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Freeze
impl<S, BIn, BOut> core::marker::Send for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Send
impl<S, BIn, BOut> core::marker::Sync for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Sync
impl<S, BIn, BOut> core::marker::Unpin for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Unpin
impl<S, BIn, BOut> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::panic::unwind_safe::RefUnwindSafe
impl<S, BIn, BOut> core::panic::unwind_safe::UnwindSafe for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: tower_service::Service<R>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::ResBody = BOut
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where U: core::convert::From<T>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where U: core::convert::Into<T>
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Error = core::convert::Infallible
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where U: core::convert::TryFrom<T>
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::clone::Clone
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Owned = T
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::clone_into(&self, target: &mut T)
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::clone::Clone
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: 'static + core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::clone::Clone
pub unsafe fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub struct hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>
impl<In, T, U, E> hyperdriver::service::BoxMakeServiceLayer<In, T, U, E>
pub fn hyperdriver::service::BoxMakeServiceLayer<In, T, U, E>::new<L, F>(inner_layer: L) -> Self where L: tower_layer::Layer<In> + core::marker::Send + core::marker::Sync + 'static, <L as tower_layer::Layer>::Service: for<'a> tower_service::Service<&'a T, Response = U, Error = E, Future = F> + core::marker::Send + 'static, F: core::future::future::Future<Output = core::result::Result<U, E>> + core::marker::Send + 'static, T: 'static
impl<In, T, U, E> core::clone::Clone for hyperdriver::service::BoxMakeServiceLayer<In, T, U, E>
pub fn hyperdriver::service::BoxMakeServiceLayer<In, T, U, E>::clone(&self) -> Self
impl<In, T, U, E> core::fmt::Debug for hyperdriver::service::BoxMakeServiceLayer<In, T, U, E>
pub fn hyperdriver::service::BoxMakeServiceLayer<In, T, U, E>::fmt(&self, fmt: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<In, T, U, E> tower_layer::Layer<In> for hyperdriver::service::BoxMakeServiceLayer<In, T, U, E>
pub type hyperdriver::service::BoxMakeServiceLayer<In, T, U, E>::Service = hyperdriver::service::BoxMakeServiceRef<T, U, E>
pub fn hyperdriver::service::BoxMakeServiceLayer<In, T, U, E>::layer(&self, inner: In) -> Self::Service
impl<InnerMakeService, Target, InnerService, MakeServiceError> core::marker::Freeze for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>
impl<InnerMakeService, Target, InnerService, MakeServiceError> core::marker::Send for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>
impl<InnerMakeService, Target, InnerService, MakeServiceError> core::marker::Sync for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>
impl<InnerMakeService, Target, InnerService, MakeServiceError> core::marker::Unpin for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>
impl<InnerMakeService, Target, InnerService, MakeServiceError> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>
impl<InnerMakeService, Target, InnerService, MakeServiceError> !core::panic::unwind_safe::UnwindSafe for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError> where U: core::convert::From<T>
pub fn hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError> where U: core::convert::Into<T>
pub type hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::Error = core::convert::Infallible
pub fn hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError> where T: core::clone::Clone
pub type hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::Owned = T
pub fn hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError> where T: core::clone::Clone
pub fn hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError> where T: core::marker::Sized
pub fn hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError> where T: core::marker::Sized
pub fn hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>
pub fn hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError> where T: core::marker::Sized
pub fn hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::BoxMakeServiceLayer<InnerMakeService, Target, InnerService, MakeServiceError>
pub struct hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>
impl<T, S, E> hyperdriver::service::BoxMakeServiceRef<T, S, E>
pub fn hyperdriver::service::BoxMakeServiceRef<T, S, E>::new<U, F>(inner: U) -> Self where U: for<'a> tower_service::Service<&'a T, Response = S, Error = E, Future = F> + core::marker::Send + 'static, F: core::future::future::Future<Output = core::result::Result<S, E>> + core::marker::Send + 'static, T: 'static
impl<T, S, E> core::fmt::Debug for hyperdriver::service::BoxMakeServiceRef<T, S, E>
pub fn hyperdriver::service::BoxMakeServiceRef<T, S, E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T, S, E> tower_service::Service<&T> for hyperdriver::service::BoxMakeServiceRef<T, S, E>
pub type hyperdriver::service::BoxMakeServiceRef<T, S, E>::Error = E
pub type hyperdriver::service::BoxMakeServiceRef<T, S, E>::Future = core::pin::Pin<alloc::boxed::Box<(dyn core::future::future::Future<Output = core::result::Result<S, E>> + core::marker::Send)>>
pub type hyperdriver::service::BoxMakeServiceRef<T, S, E>::Response = S
pub fn hyperdriver::service::BoxMakeServiceRef<T, S, E>::call(&mut self, target: &T) -> Self::Future
pub fn hyperdriver::service::BoxMakeServiceRef<T, S, E>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<Target, Service, MakeServiceError> core::marker::Freeze for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>
impl<Target, Service, MakeServiceError> core::marker::Send for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>
impl<Target, Service, MakeServiceError> !core::marker::Sync for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>
impl<Target, Service, MakeServiceError> core::marker::Unpin for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>
impl<Target, Service, MakeServiceError> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>
impl<Target, Service, MakeServiceError> !core::panic::unwind_safe::UnwindSafe for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError> where B: http_body::Body
impl<IO, T, F, R, E> hyperdriver::service::ServiceRef<IO> for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError> where T: for<'a> tower_service::Service<&'a IO, Future = F, Response = R, Error = E>, F: core::future::future::Future<Output = core::result::Result<R, E>>
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Error = E
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Future = F
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Response = R
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::call(&mut self, stream: &IO) -> <T as hyperdriver::service::ServiceRef<IO>>::Future
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::ServiceRef<IO>>::Error>>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Service = S
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Service = S
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError> where S: tower_service::Service<R>
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Target, E, ME, S, F, IB, OB> hyperdriver::service::MakeServiceRef<Target, IB> for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError> where T: for<'a> tower_service::Service<&'a Target, Error = ME, Response = S, Future = F>, E: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>, ME: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>, S: hyperdriver::service::HttpService<IB, ResBody = OB, Error = E>, F: core::future::future::Future<Output = core::result::Result<S, ME>>, IB: http_body::Body, OB: http_body::Body
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Error = E
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Future = F
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::MakeError = ME
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::ResBody = OB
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Service = S
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::make_service_ref(&mut self, target: &Target) -> <T as hyperdriver::service::MakeServiceRef<Target, IB>>::Future
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::poll_ready_ref(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::MakeServiceRef<Target, IB>>::MakeError>>
impl<T, U> core::convert::Into<U> for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError> where U: core::convert::From<T>
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError> where U: core::convert::Into<T>
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Error = core::convert::Infallible
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError> where T: core::marker::Sized
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError> where T: core::marker::Sized
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError> where T: core::marker::Sized
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::BoxMakeServiceRef<Target, Service, MakeServiceError>
pub struct hyperdriver::service::ExecuteRequest<C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, B, K: hyperdriver::client::pool::Key>
impl<C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, B, K: hyperdriver::client::pool::Key> hyperdriver::service::ExecuteRequest<C, B, K>
pub fn hyperdriver::service::ExecuteRequest<C, B, K>::connection(&self) -> &C
pub fn hyperdriver::service::ExecuteRequest<C, B, K>::into_parts(self) -> (hyperdriver::client::pool::Pooled<C, K>, http::request::Request<B>)
pub fn hyperdriver::service::ExecuteRequest<C, B, K>::new(conn: hyperdriver::client::pool::Pooled<C, K>, request: http::request::Request<B>) -> Self
pub fn hyperdriver::service::ExecuteRequest<C, B, K>::request(&self) -> &http::request::Request<B>
pub fn hyperdriver::service::ExecuteRequest<C, B, K>::request_mut(&mut self) -> &mut http::request::Request<B>
impl<C, B, K> tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>> for hyperdriver::service::RequestExecutor<C, B, K> where C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, B: http_body::Body + core::marker::Unpin + core::marker::Send + 'static, K: hyperdriver::client::pool::Key
pub type hyperdriver::service::RequestExecutor<C, B, K>::Error = hyperdriver::client::Error
pub type hyperdriver::service::RequestExecutor<C, B, K>::Future = core::pin::Pin<alloc::boxed::Box<(dyn core::future::future::Future<Output = core::result::Result<<hyperdriver::service::RequestExecutor<C, B, K> as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Response, <hyperdriver::service::RequestExecutor<C, B, K> as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Error>> + core::marker::Send)>>
pub type hyperdriver::service::RequestExecutor<C, B, K>::Response = http::response::Response<<C as hyperdriver::client::conn::connection::Connection<B>>::ResBody>
pub fn hyperdriver::service::RequestExecutor<C, B, K>::call(&mut self, req: hyperdriver::service::ExecuteRequest<C, B, K>) -> Self::Future
pub fn hyperdriver::service::RequestExecutor<C, B, K>::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<C: core::fmt::Debug + hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, B: core::fmt::Debug, K: core::fmt::Debug + hyperdriver::client::pool::Key> core::fmt::Debug for hyperdriver::service::ExecuteRequest<C, B, K>
pub fn hyperdriver::service::ExecuteRequest<C, B, K>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S, B, C, K> tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>> for hyperdriver::service::SetHostHeader<S> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub type hyperdriver::service::SetHostHeader<S>::Error = <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Error
pub type hyperdriver::service::SetHostHeader<S>::Future = <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Future
pub type hyperdriver::service::SetHostHeader<S>::Response = <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Response
pub fn hyperdriver::service::SetHostHeader<S>::call(&mut self, req: hyperdriver::service::ExecuteRequest<C, B, K>) -> Self::Future
pub fn hyperdriver::service::SetHostHeader<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S, C, B, K> tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>> for hyperdriver::service::Http1ChecksService<S, C, B, K> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>, Error = hyperdriver::client::Error>, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Error = <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Error
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Future = hyperdriver::service::MaybeErrorFuture<<S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Future, <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Response, <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Error>
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Response = <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Response
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::call(&mut self, req: hyperdriver::service::ExecuteRequest<C, B, K>) -> Self::Future
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S, C, B, K> tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>> for hyperdriver::service::Http2ChecksService<S, C, B, K> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>, Error = hyperdriver::client::Error>, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Error = <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Error
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Future = hyperdriver::service::MaybeErrorFuture<<S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Future, <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Response, <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Error>
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Response = <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Response
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::call(&mut self, req: hyperdriver::service::ExecuteRequest<C, B, K>) -> Self::Future
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<C, B, K> !core::marker::Freeze for hyperdriver::service::ExecuteRequest<C, B, K>
impl<C, B, K> core::marker::Send for hyperdriver::service::ExecuteRequest<C, B, K> where B: core::marker::Send
impl<C, B, K> core::marker::Sync for hyperdriver::service::ExecuteRequest<C, B, K> where K: core::marker::Sync, B: core::marker::Sync, C: core::marker::Sync
impl<C, B, K> core::marker::Unpin for hyperdriver::service::ExecuteRequest<C, B, K> where B: core::marker::Unpin
impl<C, B, K> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::ExecuteRequest<C, B, K>
impl<C, B, K> !core::panic::unwind_safe::UnwindSafe for hyperdriver::service::ExecuteRequest<C, B, K>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::ExecuteRequest<C, B, K> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::service::ExecuteRequest<C, B, K> where U: core::convert::From<T>
pub fn hyperdriver::service::ExecuteRequest<C, B, K>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::ExecuteRequest<C, B, K> where U: core::convert::Into<T>
pub type hyperdriver::service::ExecuteRequest<C, B, K>::Error = core::convert::Infallible
pub fn hyperdriver::service::ExecuteRequest<C, B, K>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::ExecuteRequest<C, B, K> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::ExecuteRequest<C, B, K>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::ExecuteRequest<C, B, K>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::service::ExecuteRequest<C, B, K> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::ExecuteRequest<C, B, K>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::ExecuteRequest<C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::ExecuteRequest<C, B, K>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::ExecuteRequest<C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::ExecuteRequest<C, B, K>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::service::ExecuteRequest<C, B, K>
pub fn hyperdriver::service::ExecuteRequest<C, B, K>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::ExecuteRequest<C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::ExecuteRequest<C, B, K>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::ExecuteRequest<C, B, K>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::ExecuteRequest<C, B, K>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::ExecuteRequest<C, B, K>
pub struct hyperdriver::service::Http1ChecksLayer<C, B, K>
impl<C, B, K> hyperdriver::service::Http1ChecksLayer<C, B, K>
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::new() -> Self
impl<C, B, K, S> tower_layer::Layer<S> for hyperdriver::service::Http1ChecksLayer<C, B, K> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>, Error = hyperdriver::client::Error>, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub type hyperdriver::service::Http1ChecksLayer<C, B, K>::Service = hyperdriver::service::Http1ChecksService<S, C, B, K>
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::layer(&self, service: S) -> Self::Service
impl<C, B, K> core::clone::Clone for hyperdriver::service::Http1ChecksLayer<C, B, K>
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::clone(&self) -> Self
impl<C, B, K> core::default::Default for hyperdriver::service::Http1ChecksLayer<C, B, K>
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::default() -> Self
impl<C, B, K> core::fmt::Debug for hyperdriver::service::Http1ChecksLayer<C, B, K>
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<C, B, K> core::marker::Freeze for hyperdriver::service::Http1ChecksLayer<C, B, K>
impl<C, B, K> core::marker::Send for hyperdriver::service::Http1ChecksLayer<C, B, K>
impl<C, B, K> core::marker::Sync for hyperdriver::service::Http1ChecksLayer<C, B, K>
impl<C, B, K> core::marker::Unpin for hyperdriver::service::Http1ChecksLayer<C, B, K>
impl<C, B, K> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::Http1ChecksLayer<C, B, K>
impl<C, B, K> core::panic::unwind_safe::UnwindSafe for hyperdriver::service::Http1ChecksLayer<C, B, K>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::Http1ChecksLayer<C, B, K> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::service::Http1ChecksLayer<C, B, K> where U: core::convert::From<T>
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::Http1ChecksLayer<C, B, K> where U: core::convert::Into<T>
pub type hyperdriver::service::Http1ChecksLayer<C, B, K>::Error = core::convert::Infallible
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::Http1ChecksLayer<C, B, K> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::Http1ChecksLayer<C, B, K>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::Http1ChecksLayer<C, B, K> where T: core::clone::Clone
pub type hyperdriver::service::Http1ChecksLayer<C, B, K>::Owned = T
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::Http1ChecksLayer<C, B, K> where T: core::clone::Clone
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::Http1ChecksLayer<C, B, K> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::Http1ChecksLayer<C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::Http1ChecksLayer<C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::Http1ChecksLayer<C, B, K> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::Http1ChecksLayer<C, B, K>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::Http1ChecksLayer<C, B, K>
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::Http1ChecksLayer<C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::Http1ChecksLayer<C, B, K>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::Http1ChecksLayer<C, B, K>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::Http1ChecksLayer<C, B, K>
pub struct hyperdriver::service::Http1ChecksService<S, C, B, K> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>, Error = hyperdriver::client::Error>, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
impl<S, C, B, K> hyperdriver::service::Http1ChecksService<S, C, B, K> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>, Error = hyperdriver::client::Error>, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::new(service: S) -> Self
impl<S, C, B, K> core::clone::Clone for hyperdriver::service::Http1ChecksService<S, C, B, K> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>, Error = hyperdriver::client::Error> + core::clone::Clone, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::clone(&self) -> Self
impl<S, C, B, K> tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>> for hyperdriver::service::Http1ChecksService<S, C, B, K> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>, Error = hyperdriver::client::Error>, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Error = <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Error
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Future = hyperdriver::service::MaybeErrorFuture<<S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Future, <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Response, <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Error>
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Response = <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Response
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::call(&mut self, req: hyperdriver::service::ExecuteRequest<C, B, K>) -> Self::Future
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S, C, B: core::fmt::Debug, K> core::fmt::Debug for hyperdriver::service::Http1ChecksService<S, C, B, K> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>, Error = hyperdriver::client::Error> + core::fmt::Debug, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection + core::fmt::Debug, K: hyperdriver::client::pool::Key + core::fmt::Debug, <S as tower_service::Service>::Error: core::fmt::Debug
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S, C, B, K> core::marker::Freeze for hyperdriver::service::Http1ChecksService<S, C, B, K> where S: core::marker::Freeze
impl<S, C, B, K> core::marker::Send for hyperdriver::service::Http1ChecksService<S, C, B, K> where S: core::marker::Send
impl<S, C, B, K> core::marker::Sync for hyperdriver::service::Http1ChecksService<S, C, B, K> where S: core::marker::Sync
impl<S, C, B, K> core::marker::Unpin for hyperdriver::service::Http1ChecksService<S, C, B, K> where S: core::marker::Unpin
impl<S, C, B, K> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::Http1ChecksService<S, C, B, K> where S: core::panic::unwind_safe::RefUnwindSafe
impl<S, C, B, K> core::panic::unwind_safe::UnwindSafe for hyperdriver::service::Http1ChecksService<S, C, B, K> where S: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::Http1ChecksService<S, C, B, K> where B: http_body::Body
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::Http1ChecksService<S, C, B, K> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::Http1ChecksService<S, C, B, K> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Service = S
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Service = S
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::service::Http1ChecksService<S, C, B, K> where S: tower_service::Service<R>
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::Http1ChecksService<S, C, B, K> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::Http1ChecksService<S, C, B, K> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::service::Http1ChecksService<S, C, B, K> where U: core::convert::From<T>
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::Http1ChecksService<S, C, B, K> where U: core::convert::Into<T>
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Error = core::convert::Infallible
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::Http1ChecksService<S, C, B, K> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::Http1ChecksService<S, C, B, K> where T: core::clone::Clone
pub type hyperdriver::service::Http1ChecksService<S, C, B, K>::Owned = T
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::Http1ChecksService<S, C, B, K> where T: core::clone::Clone
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::Http1ChecksService<S, C, B, K> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::Http1ChecksService<S, C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::Http1ChecksService<S, C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::Http1ChecksService<S, C, B, K> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::Http1ChecksService<S, C, B, K>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::Http1ChecksService<S, C, B, K>
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::Http1ChecksService<S, C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::Http1ChecksService<S, C, B, K>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::Http1ChecksService<S, C, B, K>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::Http1ChecksService<S, C, B, K>
pub struct hyperdriver::service::Http2ChecksLayer<C, B, K>
impl<C, B, K> hyperdriver::service::Http2ChecksLayer<C, B, K>
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::new() -> Self
impl<C, B, K> core::clone::Clone for hyperdriver::service::Http2ChecksLayer<C, B, K>
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::clone(&self) -> Self
impl<C, B, K> core::default::Default for hyperdriver::service::Http2ChecksLayer<C, B, K>
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::default() -> Self
impl<C, B, K> core::fmt::Debug for hyperdriver::service::Http2ChecksLayer<C, B, K>
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S, C, B, K> tower_layer::Layer<S> for hyperdriver::service::Http2ChecksLayer<C, B, K> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>, Error = hyperdriver::client::Error>, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub type hyperdriver::service::Http2ChecksLayer<C, B, K>::Service = hyperdriver::service::Http2ChecksService<S, C, B, K>
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::layer(&self, inner: S) -> Self::Service
impl<C, B, K> core::marker::Freeze for hyperdriver::service::Http2ChecksLayer<C, B, K>
impl<C, B, K> core::marker::Send for hyperdriver::service::Http2ChecksLayer<C, B, K>
impl<C, B, K> core::marker::Sync for hyperdriver::service::Http2ChecksLayer<C, B, K>
impl<C, B, K> core::marker::Unpin for hyperdriver::service::Http2ChecksLayer<C, B, K>
impl<C, B, K> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::Http2ChecksLayer<C, B, K>
impl<C, B, K> core::panic::unwind_safe::UnwindSafe for hyperdriver::service::Http2ChecksLayer<C, B, K>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::Http2ChecksLayer<C, B, K> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::service::Http2ChecksLayer<C, B, K> where U: core::convert::From<T>
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::Http2ChecksLayer<C, B, K> where U: core::convert::Into<T>
pub type hyperdriver::service::Http2ChecksLayer<C, B, K>::Error = core::convert::Infallible
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::Http2ChecksLayer<C, B, K> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::Http2ChecksLayer<C, B, K>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::Http2ChecksLayer<C, B, K> where T: core::clone::Clone
pub type hyperdriver::service::Http2ChecksLayer<C, B, K>::Owned = T
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::Http2ChecksLayer<C, B, K> where T: core::clone::Clone
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::Http2ChecksLayer<C, B, K> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::Http2ChecksLayer<C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::Http2ChecksLayer<C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::Http2ChecksLayer<C, B, K> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::Http2ChecksLayer<C, B, K>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::Http2ChecksLayer<C, B, K>
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::Http2ChecksLayer<C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::Http2ChecksLayer<C, B, K>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::Http2ChecksLayer<C, B, K>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::Http2ChecksLayer<C, B, K>
pub struct hyperdriver::service::Http2ChecksService<S, C, B, K> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>, Error = hyperdriver::client::Error>, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
impl<S, C, B, K> hyperdriver::service::Http2ChecksService<S, C, B, K> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>, Error = hyperdriver::client::Error>, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::new(inner: S) -> Self
impl<S, C, B, K> core::clone::Clone for hyperdriver::service::Http2ChecksService<S, C, B, K> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>, Error = hyperdriver::client::Error> + core::clone::Clone, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::clone(&self) -> Self
impl<S, C, B, K> tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>> for hyperdriver::service::Http2ChecksService<S, C, B, K> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>, Error = hyperdriver::client::Error>, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Error = <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Error
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Future = hyperdriver::service::MaybeErrorFuture<<S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Future, <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Response, <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Error>
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Response = <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Response
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::call(&mut self, req: hyperdriver::service::ExecuteRequest<C, B, K>) -> Self::Future
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S, C, B: core::fmt::Debug, K> core::fmt::Debug for hyperdriver::service::Http2ChecksService<S, C, B, K> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>, Error = hyperdriver::client::Error> + core::fmt::Debug, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection + core::fmt::Debug, K: hyperdriver::client::pool::Key + core::fmt::Debug, <S as tower_service::Service>::Error: core::fmt::Debug
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S, C, B, K> core::marker::Freeze for hyperdriver::service::Http2ChecksService<S, C, B, K> where S: core::marker::Freeze
impl<S, C, B, K> core::marker::Send for hyperdriver::service::Http2ChecksService<S, C, B, K> where S: core::marker::Send
impl<S, C, B, K> core::marker::Sync for hyperdriver::service::Http2ChecksService<S, C, B, K> where S: core::marker::Sync
impl<S, C, B, K> core::marker::Unpin for hyperdriver::service::Http2ChecksService<S, C, B, K> where S: core::marker::Unpin
impl<S, C, B, K> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::Http2ChecksService<S, C, B, K> where S: core::panic::unwind_safe::RefUnwindSafe
impl<S, C, B, K> core::panic::unwind_safe::UnwindSafe for hyperdriver::service::Http2ChecksService<S, C, B, K> where S: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::Http2ChecksService<S, C, B, K> where B: http_body::Body
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::Http2ChecksService<S, C, B, K> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::Http2ChecksService<S, C, B, K> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Service = S
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Service = S
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::service::Http2ChecksService<S, C, B, K> where S: tower_service::Service<R>
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::Http2ChecksService<S, C, B, K> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::Http2ChecksService<S, C, B, K> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::service::Http2ChecksService<S, C, B, K> where U: core::convert::From<T>
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::Http2ChecksService<S, C, B, K> where U: core::convert::Into<T>
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Error = core::convert::Infallible
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::Http2ChecksService<S, C, B, K> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::Http2ChecksService<S, C, B, K> where T: core::clone::Clone
pub type hyperdriver::service::Http2ChecksService<S, C, B, K>::Owned = T
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::Http2ChecksService<S, C, B, K> where T: core::clone::Clone
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::Http2ChecksService<S, C, B, K> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::Http2ChecksService<S, C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::Http2ChecksService<S, C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::Http2ChecksService<S, C, B, K> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::Http2ChecksService<S, C, B, K>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::Http2ChecksService<S, C, B, K>
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::Http2ChecksService<S, C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::Http2ChecksService<S, C, B, K>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::Http2ChecksService<S, C, B, K>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::Http2ChecksService<S, C, B, K>
pub struct hyperdriver::service::IncomingRequestLayer<BIn, BOut>
impl<BIn, BOut> hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::new() -> Self
impl<BIn, BOut, S> tower_layer::Layer<S> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Service = hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::layer(&self, inner: S) -> Self::Service
impl<BIn, BOut> core::default::Default for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::default() -> Self
impl<BIn: core::clone::Clone, BOut: core::clone::Clone> core::clone::Clone for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::clone(&self) -> hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn: core::fmt::Debug, BOut: core::fmt::Debug> core::fmt::Debug for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<BIn, BOut> core::marker::Freeze for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::marker::Send for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::marker::Sync for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::marker::Unpin for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<BIn, BOut> core::panic::unwind_safe::UnwindSafe for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where U: core::convert::From<T>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where U: core::convert::Into<T>
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Error = core::convert::Infallible
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where U: core::convert::TryFrom<T>
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::clone::Clone
pub type hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::Owned = T
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::clone_into(&self, target: &mut T)
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::clone::Clone
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: 'static + core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::clone::Clone
pub unsafe fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::body::AdaptIncomingLayer<BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::body::AdaptIncomingLayer<BIn, BOut>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::body::AdaptIncomingLayer<BIn, BOut>
pub struct hyperdriver::service::IncomingRequestService<S, BIn, BOut>
impl<S, BIn, BOut> hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::new(inner: S) -> Self
impl<S: core::clone::Clone, BIn, BOut> core::clone::Clone for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::clone(&self) -> Self
impl<S: core::default::Default, BIn, BOut> core::default::Default for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::default() -> Self
impl<S: core::fmt::Debug, BIn, BOut> core::fmt::Debug for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T, BIn, BOut> tower_service::Service<http::request::Request<hyper::body::incoming::Incoming>> for hyperdriver::body::AdaptIncomingService<T, BIn, BOut> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BIn: core::convert::From<hyper::body::incoming::Incoming>
pub type hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::Response = http::response::Response<BOut>
pub fn hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::call(&mut self, req: http::request::Request<hyper::body::incoming::Incoming>) -> Self::Future
pub fn hyperdriver::body::AdaptIncomingService<T, BIn, BOut>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S, BIn, BOut> core::marker::Freeze for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Freeze
impl<S, BIn, BOut> core::marker::Send for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Send
impl<S, BIn, BOut> core::marker::Sync for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Sync
impl<S, BIn, BOut> core::marker::Unpin for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::marker::Unpin
impl<S, BIn, BOut> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::panic::unwind_safe::RefUnwindSafe
impl<S, BIn, BOut> core::panic::unwind_safe::UnwindSafe for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where S: tower_service::Service<R>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::ResBody = BOut
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where U: core::convert::From<T>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where U: core::convert::Into<T>
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Error = core::convert::Infallible
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where U: core::convert::TryFrom<T>
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::clone::Clone
pub type hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::Owned = T
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::clone_into(&self, target: &mut T)
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::clone::Clone
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: 'static + core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::clone::Clone
pub unsafe fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::body::AdaptIncomingService<S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::body::AdaptIncomingService<S, BIn, BOut>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::body::AdaptIncomingService<S, BIn, BOut>
pub struct hyperdriver::service::IncomingResponseLayer<BIn, BOut>
impl<BIn, BOut> hyperdriver::service::IncomingResponseLayer<BIn, BOut>
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::new() -> Self
impl<BIn, BOut, S> tower_layer::Layer<S> for hyperdriver::service::IncomingResponseLayer<BIn, BOut>
pub type hyperdriver::service::IncomingResponseLayer<BIn, BOut>::Service = hyperdriver::service::IncomingResponseService<S, BIn, BOut>
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::layer(&self, inner: S) -> Self::Service
impl<BIn, BOut> core::default::Default for hyperdriver::service::IncomingResponseLayer<BIn, BOut>
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::default() -> Self
impl<BIn: core::clone::Clone, BOut: core::clone::Clone> core::clone::Clone for hyperdriver::service::IncomingResponseLayer<BIn, BOut>
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::clone(&self) -> hyperdriver::service::IncomingResponseLayer<BIn, BOut>
impl<BIn: core::fmt::Debug, BOut: core::fmt::Debug> core::fmt::Debug for hyperdriver::service::IncomingResponseLayer<BIn, BOut>
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<BIn, BOut> core::marker::Freeze for hyperdriver::service::IncomingResponseLayer<BIn, BOut>
impl<BIn, BOut> core::marker::Send for hyperdriver::service::IncomingResponseLayer<BIn, BOut>
impl<BIn, BOut> core::marker::Sync for hyperdriver::service::IncomingResponseLayer<BIn, BOut>
impl<BIn, BOut> core::marker::Unpin for hyperdriver::service::IncomingResponseLayer<BIn, BOut>
impl<BIn, BOut> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::IncomingResponseLayer<BIn, BOut>
impl<BIn, BOut> core::panic::unwind_safe::UnwindSafe for hyperdriver::service::IncomingResponseLayer<BIn, BOut>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::IncomingResponseLayer<BIn, BOut> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::service::IncomingResponseLayer<BIn, BOut> where U: core::convert::From<T>
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::IncomingResponseLayer<BIn, BOut> where U: core::convert::Into<T>
pub type hyperdriver::service::IncomingResponseLayer<BIn, BOut>::Error = core::convert::Infallible
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::IncomingResponseLayer<BIn, BOut> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::IncomingResponseLayer<BIn, BOut>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::IncomingResponseLayer<BIn, BOut> where T: core::clone::Clone
pub type hyperdriver::service::IncomingResponseLayer<BIn, BOut>::Owned = T
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::IncomingResponseLayer<BIn, BOut> where T: core::clone::Clone
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::IncomingResponseLayer<BIn, BOut> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::IncomingResponseLayer<BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::IncomingResponseLayer<BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::IncomingResponseLayer<BIn, BOut> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::IncomingResponseLayer<BIn, BOut>
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::IncomingResponseLayer<BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::IncomingResponseLayer<BIn, BOut>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::IncomingResponseLayer<BIn, BOut>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::IncomingResponseLayer<BIn, BOut>
pub struct hyperdriver::service::IncomingResponseService<S, BIn, BOut>
impl<S, BIn, BOut> hyperdriver::service::IncomingResponseService<S, BIn, BOut>
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::new(inner: S) -> Self
impl<S: core::clone::Clone, BIn, BOut> core::clone::Clone for hyperdriver::service::IncomingResponseService<S, BIn, BOut>
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::clone(&self) -> Self
impl<S: core::default::Default, BIn, BOut> core::default::Default for hyperdriver::service::IncomingResponseService<S, BIn, BOut>
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::default() -> Self
impl<S: core::fmt::Debug, BIn, BOut> core::fmt::Debug for hyperdriver::service::IncomingResponseService<S, BIn, BOut>
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T, BIn, BOut> tower_service::Service<http::request::Request<BIn>> for hyperdriver::service::IncomingResponseService<T, BIn, BOut> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<hyper::body::incoming::Incoming>>, BOut: core::convert::From<hyper::body::incoming::Incoming>
pub type hyperdriver::service::IncomingResponseService<T, BIn, BOut>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::service::IncomingResponseService<T, BIn, BOut>::Future = IncomingResponseFuture<<T as tower_service::Service<http::request::Request<BIn>>>::Future, BOut, <T as tower_service::Service<http::request::Request<BIn>>>::Error>
pub type hyperdriver::service::IncomingResponseService<T, BIn, BOut>::Response = http::response::Response<BOut>
pub fn hyperdriver::service::IncomingResponseService<T, BIn, BOut>::call(&mut self, req: http::request::Request<BIn>) -> Self::Future
pub fn hyperdriver::service::IncomingResponseService<T, BIn, BOut>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S, BIn, BOut> core::marker::Freeze for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where S: core::marker::Freeze
impl<S, BIn, BOut> core::marker::Send for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where S: core::marker::Send
impl<S, BIn, BOut> core::marker::Sync for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where S: core::marker::Sync
impl<S, BIn, BOut> core::marker::Unpin for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where S: core::marker::Unpin
impl<S, BIn, BOut> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where S: core::panic::unwind_safe::RefUnwindSafe
impl<S, BIn, BOut> core::panic::unwind_safe::UnwindSafe for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where S: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where S: tower_service::Service<R>
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::service::IncomingResponseService<S, BIn, BOut>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::service::IncomingResponseService<S, BIn, BOut>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::service::IncomingResponseService<S, BIn, BOut>::ResBody = BOut
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where U: core::convert::From<T>
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where U: core::convert::Into<T>
pub type hyperdriver::service::IncomingResponseService<S, BIn, BOut>::Error = core::convert::Infallible
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::IncomingResponseService<S, BIn, BOut>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where T: core::clone::Clone
pub type hyperdriver::service::IncomingResponseService<S, BIn, BOut>::Owned = T
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where T: core::clone::Clone
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::IncomingResponseService<S, BIn, BOut>
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::IncomingResponseService<S, BIn, BOut> where T: core::marker::Sized
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::IncomingResponseService<S, BIn, BOut>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::IncomingResponseService<S, BIn, BOut>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::IncomingResponseService<S, BIn, BOut>
pub struct hyperdriver::service::MaybeErrorFuture<F, R, E>
impl<F, R, E> hyperdriver::service::MaybeErrorFuture<F, R, E>
pub fn hyperdriver::service::MaybeErrorFuture<F, R, E>::error(error: E) -> Self
pub fn hyperdriver::service::MaybeErrorFuture<F, R, E>::future(inner: F) -> Self
impl<'pin, F, R, E> core::marker::Unpin for hyperdriver::service::MaybeErrorFuture<F, R, E> where __MaybeErrorFuture<'pin, F, R, E>: core::marker::Unpin
impl<F, R, E> core::future::future::Future for hyperdriver::service::MaybeErrorFuture<F, R, E> where F: core::future::future::Future<Output = core::result::Result<R, E>>
pub type hyperdriver::service::MaybeErrorFuture<F, R, E>::Output = core::result::Result<R, E>
pub fn hyperdriver::service::MaybeErrorFuture<F, R, E>::poll(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<Self::Output>
impl<F: core::fmt::Debug, R: core::fmt::Debug, E: core::fmt::Debug> core::fmt::Debug for hyperdriver::service::MaybeErrorFuture<F, R, E>
pub fn hyperdriver::service::MaybeErrorFuture<F, R, E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<F, R, E> core::marker::Freeze for hyperdriver::service::MaybeErrorFuture<F, R, E> where F: core::marker::Freeze, E: core::marker::Freeze
impl<F, R, E> core::marker::Send for hyperdriver::service::MaybeErrorFuture<F, R, E> where F: core::marker::Send, E: core::marker::Send
impl<F, R, E> core::marker::Sync for hyperdriver::service::MaybeErrorFuture<F, R, E> where F: core::marker::Sync, E: core::marker::Sync
impl<F, R, E> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::MaybeErrorFuture<F, R, E> where F: core::panic::unwind_safe::RefUnwindSafe, E: core::panic::unwind_safe::RefUnwindSafe
impl<F, R, E> core::panic::unwind_safe::UnwindSafe for hyperdriver::service::MaybeErrorFuture<F, R, E> where F: core::panic::unwind_safe::UnwindSafe, E: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::MaybeErrorFuture<F, R, E> where B: http_body::Body
impl<F, T, E> futures_core::future::TryFuture for hyperdriver::service::MaybeErrorFuture<F, R, E> where F: core::future::future::Future<Output = core::result::Result<T, E>> + core::marker::Sized
pub type hyperdriver::service::MaybeErrorFuture<F, R, E>::Error = E
pub type hyperdriver::service::MaybeErrorFuture<F, R, E>::Ok = T
pub fn hyperdriver::service::MaybeErrorFuture<F, R, E>::try_poll(self: core::pin::Pin<&mut F>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<<F as core::future::future::Future>::Output>
impl<F> core::future::into_future::IntoFuture for hyperdriver::service::MaybeErrorFuture<F, R, E> where F: core::future::future::Future
pub type hyperdriver::service::MaybeErrorFuture<F, R, E>::IntoFuture = F
pub type hyperdriver::service::MaybeErrorFuture<F, R, E>::Output = <F as core::future::future::Future>::Output
pub fn hyperdriver::service::MaybeErrorFuture<F, R, E>::into_future(self) -> <F as core::future::into_future::IntoFuture>::IntoFuture
impl<Fut> futures_util::future::try_future::TryFutureExt for hyperdriver::service::MaybeErrorFuture<F, R, E> where Fut: futures_core::future::TryFuture + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::service::MaybeErrorFuture<F, R, E> where U: core::convert::From<T>
pub fn hyperdriver::service::MaybeErrorFuture<F, R, E>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::MaybeErrorFuture<F, R, E> where U: core::convert::Into<T>
pub type hyperdriver::service::MaybeErrorFuture<F, R, E>::Error = core::convert::Infallible
pub fn hyperdriver::service::MaybeErrorFuture<F, R, E>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::MaybeErrorFuture<F, R, E> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::MaybeErrorFuture<F, R, E>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::MaybeErrorFuture<F, R, E>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::service::MaybeErrorFuture<F, R, E> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::MaybeErrorFuture<F, R, E>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::MaybeErrorFuture<F, R, E> where T: core::marker::Sized
pub fn hyperdriver::service::MaybeErrorFuture<F, R, E>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::MaybeErrorFuture<F, R, E> where T: core::marker::Sized
pub fn hyperdriver::service::MaybeErrorFuture<F, R, E>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::service::MaybeErrorFuture<F, R, E>
pub fn hyperdriver::service::MaybeErrorFuture<F, R, E>::from(t: T) -> T
impl<T> futures_util::future::future::FutureExt for hyperdriver::service::MaybeErrorFuture<F, R, E> where T: core::future::future::Future + core::marker::Sized
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::MaybeErrorFuture<F, R, E> where T: core::marker::Sized
pub fn hyperdriver::service::MaybeErrorFuture<F, R, E>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::MaybeErrorFuture<F, R, E>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::MaybeErrorFuture<F, R, E>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::MaybeErrorFuture<F, R, E>
pub struct hyperdriver::service::OptionLayer<M>
impl<M> hyperdriver::service::OptionLayer<M>
pub fn hyperdriver::service::OptionLayer<M>::new(middleware: core::option::Option<M>) -> Self
impl<M, S> tower_layer::Layer<S> for hyperdriver::service::OptionLayer<M> where M: tower_layer::Layer<S>
pub type hyperdriver::service::OptionLayer<M>::Service = hyperdriver::service::OptionService<<M as tower_layer::Layer<S>>::Service, S>
pub fn hyperdriver::service::OptionLayer<M>::layer(&self, inner: S) -> Self::Service
impl<M: core::clone::Clone> core::clone::Clone for hyperdriver::service::OptionLayer<M>
pub fn hyperdriver::service::OptionLayer<M>::clone(&self) -> hyperdriver::service::OptionLayer<M>
impl<M: core::fmt::Debug> core::fmt::Debug for hyperdriver::service::OptionLayer<M>
pub fn hyperdriver::service::OptionLayer<M>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<M> core::marker::Freeze for hyperdriver::service::OptionLayer<M> where M: core::marker::Freeze
impl<M> core::marker::Send for hyperdriver::service::OptionLayer<M> where M: core::marker::Send
impl<M> core::marker::Sync for hyperdriver::service::OptionLayer<M> where M: core::marker::Sync
impl<M> core::marker::Unpin for hyperdriver::service::OptionLayer<M> where M: core::marker::Unpin
impl<M> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::OptionLayer<M> where M: core::panic::unwind_safe::RefUnwindSafe
impl<M> core::panic::unwind_safe::UnwindSafe for hyperdriver::service::OptionLayer<M> where M: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::OptionLayer<M> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::service::OptionLayer<M> where U: core::convert::From<T>
pub fn hyperdriver::service::OptionLayer<M>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::OptionLayer<M> where U: core::convert::Into<T>
pub type hyperdriver::service::OptionLayer<M>::Error = core::convert::Infallible
pub fn hyperdriver::service::OptionLayer<M>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::OptionLayer<M> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::OptionLayer<M>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::OptionLayer<M>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::OptionLayer<M> where T: core::clone::Clone
pub type hyperdriver::service::OptionLayer<M>::Owned = T
pub fn hyperdriver::service::OptionLayer<M>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::OptionLayer<M>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::OptionLayer<M> where T: core::clone::Clone
pub fn hyperdriver::service::OptionLayer<M>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::OptionLayer<M> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::OptionLayer<M>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::OptionLayer<M> where T: core::marker::Sized
pub fn hyperdriver::service::OptionLayer<M>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::OptionLayer<M> where T: core::marker::Sized
pub fn hyperdriver::service::OptionLayer<M>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::OptionLayer<M> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::OptionLayer<M>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::OptionLayer<M>
pub fn hyperdriver::service::OptionLayer<M>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::OptionLayer<M> where T: core::marker::Sized
pub fn hyperdriver::service::OptionLayer<M>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::OptionLayer<M>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::OptionLayer<M>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::OptionLayer<M>
pub struct hyperdriver::service::OptionService<M, S>
impl<M, S, Req, E> tower_service::Service<Req> for hyperdriver::service::OptionService<M, S> where S: tower_service::Service<Req, Error = E>, M: tower_service::Service<Req, Response = <S as tower_service::Service>::Response>, <M as tower_service::Service>::Error: core::convert::Into<E>
pub type hyperdriver::service::OptionService<M, S>::Error = E
pub type hyperdriver::service::OptionService<M, S>::Future = OptionServiceFuture<<M as tower_service::Service<Req>>::Future, <S as tower_service::Service<Req>>::Future>
pub type hyperdriver::service::OptionService<M, S>::Response = <S as tower_service::Service<Req>>::Response
pub fn hyperdriver::service::OptionService<M, S>::call(&mut self, req: Req) -> Self::Future
pub fn hyperdriver::service::OptionService<M, S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<M: core::clone::Clone, S: core::clone::Clone> core::clone::Clone for hyperdriver::service::OptionService<M, S>
pub fn hyperdriver::service::OptionService<M, S>::clone(&self) -> hyperdriver::service::OptionService<M, S>
impl<M: core::fmt::Debug, S: core::fmt::Debug> core::fmt::Debug for hyperdriver::service::OptionService<M, S>
pub fn hyperdriver::service::OptionService<M, S>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<M, S> core::marker::Freeze for hyperdriver::service::OptionService<M, S> where M: core::marker::Freeze, S: core::marker::Freeze
impl<M, S> core::marker::Send for hyperdriver::service::OptionService<M, S> where M: core::marker::Send, S: core::marker::Send
impl<M, S> core::marker::Sync for hyperdriver::service::OptionService<M, S> where M: core::marker::Sync, S: core::marker::Sync
impl<M, S> core::marker::Unpin for hyperdriver::service::OptionService<M, S> where M: core::marker::Unpin, S: core::marker::Unpin
impl<M, S> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::OptionService<M, S> where M: core::panic::unwind_safe::RefUnwindSafe, S: core::panic::unwind_safe::RefUnwindSafe
impl<M, S> core::panic::unwind_safe::UnwindSafe for hyperdriver::service::OptionService<M, S> where M: core::panic::unwind_safe::UnwindSafe, S: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::OptionService<M, S> where B: http_body::Body
impl<IO, T, F, R, E> hyperdriver::service::ServiceRef<IO> for hyperdriver::service::OptionService<M, S> where T: for<'a> tower_service::Service<&'a IO, Future = F, Response = R, Error = E>, F: core::future::future::Future<Output = core::result::Result<R, E>>
pub type hyperdriver::service::OptionService<M, S>::Error = E
pub type hyperdriver::service::OptionService<M, S>::Future = F
pub type hyperdriver::service::OptionService<M, S>::Response = R
pub fn hyperdriver::service::OptionService<M, S>::call(&mut self, stream: &IO) -> <T as hyperdriver::service::ServiceRef<IO>>::Future
pub fn hyperdriver::service::OptionService<M, S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::ServiceRef<IO>>::Error>>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::OptionService<M, S> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::OptionService<M, S> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
pub type hyperdriver::service::OptionService<M, S>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::OptionService<M, S>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::OptionService<M, S>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::OptionService<M, S>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::OptionService<M, S>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::OptionService<M, S>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::OptionService<M, S>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::OptionService<M, S>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::OptionService<M, S>::Service = S
pub type hyperdriver::service::OptionService<M, S>::Service = S
pub fn hyperdriver::service::OptionService<M, S>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::OptionService<M, S>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::OptionService<M, S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
pub fn hyperdriver::service::OptionService<M, S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::service::OptionService<M, S> where S: tower_service::Service<R>
pub fn hyperdriver::service::OptionService<M, S>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::service::OptionService<M, S>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::service::OptionService<M, S> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::service::OptionService<M, S>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::service::OptionService<M, S>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::service::OptionService<M, S>::ResBody = BOut
pub fn hyperdriver::service::OptionService<M, S>::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::service::OptionService<M, S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::OptionService<M, S> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::OptionService<M, S> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Target, E, ME, S, F, IB, OB> hyperdriver::service::MakeServiceRef<Target, IB> for hyperdriver::service::OptionService<M, S> where T: for<'a> tower_service::Service<&'a Target, Error = ME, Response = S, Future = F>, E: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>, ME: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>, S: hyperdriver::service::HttpService<IB, ResBody = OB, Error = E>, F: core::future::future::Future<Output = core::result::Result<S, ME>>, IB: http_body::Body, OB: http_body::Body
pub type hyperdriver::service::OptionService<M, S>::Error = E
pub type hyperdriver::service::OptionService<M, S>::Future = F
pub type hyperdriver::service::OptionService<M, S>::MakeError = ME
pub type hyperdriver::service::OptionService<M, S>::ResBody = OB
pub type hyperdriver::service::OptionService<M, S>::Service = S
pub fn hyperdriver::service::OptionService<M, S>::make_service_ref(&mut self, target: &Target) -> <T as hyperdriver::service::MakeServiceRef<Target, IB>>::Future
pub fn hyperdriver::service::OptionService<M, S>::poll_ready_ref(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::MakeServiceRef<Target, IB>>::MakeError>>
impl<T, U> core::convert::Into<U> for hyperdriver::service::OptionService<M, S> where U: core::convert::From<T>
pub fn hyperdriver::service::OptionService<M, S>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::OptionService<M, S> where U: core::convert::Into<T>
pub type hyperdriver::service::OptionService<M, S>::Error = core::convert::Infallible
pub fn hyperdriver::service::OptionService<M, S>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::OptionService<M, S> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::OptionService<M, S>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::OptionService<M, S>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::OptionService<M, S> where T: core::clone::Clone
pub type hyperdriver::service::OptionService<M, S>::Owned = T
pub fn hyperdriver::service::OptionService<M, S>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::OptionService<M, S>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::OptionService<M, S> where T: core::clone::Clone
pub fn hyperdriver::service::OptionService<M, S>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::OptionService<M, S> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::OptionService<M, S>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::OptionService<M, S> where T: core::marker::Sized
pub fn hyperdriver::service::OptionService<M, S>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::OptionService<M, S> where T: core::marker::Sized
pub fn hyperdriver::service::OptionService<M, S>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::OptionService<M, S> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::OptionService<M, S>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::OptionService<M, S>
pub fn hyperdriver::service::OptionService<M, S>::from(t: T) -> T
impl<T> hyperdriver::client::conn::transport::TransportExt for hyperdriver::service::OptionService<M, S> where T: hyperdriver::client::conn::transport::Transport
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::OptionService<M, S> where T: core::marker::Sized
pub fn hyperdriver::service::OptionService<M, S>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::OptionService<M, S>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::OptionService<M, S>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::OptionService<M, S>
pub struct hyperdriver::service::PreprocessLayer<F>
impl<F> hyperdriver::service::PreprocessLayer<F>
pub fn hyperdriver::service::PreprocessLayer<F>::new(preprocessor: F) -> Self
impl<F: core::clone::Clone> core::clone::Clone for hyperdriver::service::PreprocessLayer<F>
pub fn hyperdriver::service::PreprocessLayer<F>::clone(&self) -> hyperdriver::service::PreprocessLayer<F>
impl<F> core::fmt::Debug for hyperdriver::service::PreprocessLayer<F>
pub fn hyperdriver::service::PreprocessLayer<F>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S, F: core::clone::Clone> tower_layer::Layer<S> for hyperdriver::service::PreprocessLayer<F>
pub type hyperdriver::service::PreprocessLayer<F>::Service = hyperdriver::service::PreprocessService<S, F>
pub fn hyperdriver::service::PreprocessLayer<F>::layer(&self, inner: S) -> Self::Service
impl<F> core::marker::Freeze for hyperdriver::service::PreprocessLayer<F> where F: core::marker::Freeze
impl<F> core::marker::Send for hyperdriver::service::PreprocessLayer<F> where F: core::marker::Send
impl<F> core::marker::Sync for hyperdriver::service::PreprocessLayer<F> where F: core::marker::Sync
impl<F> core::marker::Unpin for hyperdriver::service::PreprocessLayer<F> where F: core::marker::Unpin
impl<F> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::PreprocessLayer<F> where F: core::panic::unwind_safe::RefUnwindSafe
impl<F> core::panic::unwind_safe::UnwindSafe for hyperdriver::service::PreprocessLayer<F> where F: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::PreprocessLayer<F> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::service::PreprocessLayer<F> where U: core::convert::From<T>
pub fn hyperdriver::service::PreprocessLayer<F>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::PreprocessLayer<F> where U: core::convert::Into<T>
pub type hyperdriver::service::PreprocessLayer<F>::Error = core::convert::Infallible
pub fn hyperdriver::service::PreprocessLayer<F>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::PreprocessLayer<F> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::PreprocessLayer<F>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::PreprocessLayer<F>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::PreprocessLayer<F> where T: core::clone::Clone
pub type hyperdriver::service::PreprocessLayer<F>::Owned = T
pub fn hyperdriver::service::PreprocessLayer<F>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::PreprocessLayer<F>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::PreprocessLayer<F> where T: core::clone::Clone
pub fn hyperdriver::service::PreprocessLayer<F>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::PreprocessLayer<F> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::PreprocessLayer<F>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::PreprocessLayer<F> where T: core::marker::Sized
pub fn hyperdriver::service::PreprocessLayer<F>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::PreprocessLayer<F> where T: core::marker::Sized
pub fn hyperdriver::service::PreprocessLayer<F>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::PreprocessLayer<F> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::PreprocessLayer<F>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::PreprocessLayer<F>
pub fn hyperdriver::service::PreprocessLayer<F>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::PreprocessLayer<F> where T: core::marker::Sized
pub fn hyperdriver::service::PreprocessLayer<F>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::PreprocessLayer<F>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::PreprocessLayer<F>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::PreprocessLayer<F>
pub struct hyperdriver::service::PreprocessService<S, F>
impl<S, F> hyperdriver::service::PreprocessService<S, F>
pub fn hyperdriver::service::PreprocessService<S, F>::new(inner: S, preprocessor: F) -> Self
pub fn hyperdriver::service::PreprocessService<S, F>::service(&self) -> &S
impl<S, F, R> tower_service::Service<R> for hyperdriver::service::PreprocessService<S, F> where S: tower_service::Service<R>, F: core::ops::function::Fn(R) -> core::result::Result<R, <S as tower_service::Service>::Error>
pub type hyperdriver::service::PreprocessService<S, F>::Error = <S as tower_service::Service<R>>::Error
pub type hyperdriver::service::PreprocessService<S, F>::Future = hyperdriver::service::MaybeErrorFuture<<S as tower_service::Service<R>>::Future, <S as tower_service::Service<R>>::Response, <S as tower_service::Service<R>>::Error>
pub type hyperdriver::service::PreprocessService<S, F>::Response = <S as tower_service::Service<R>>::Response
pub fn hyperdriver::service::PreprocessService<S, F>::call(&mut self, req: R) -> Self::Future
pub fn hyperdriver::service::PreprocessService<S, F>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S: core::clone::Clone, F: core::clone::Clone> core::clone::Clone for hyperdriver::service::PreprocessService<S, F>
pub fn hyperdriver::service::PreprocessService<S, F>::clone(&self) -> hyperdriver::service::PreprocessService<S, F>
impl<S: core::fmt::Debug, F> core::fmt::Debug for hyperdriver::service::PreprocessService<S, F>
pub fn hyperdriver::service::PreprocessService<S, F>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S, F> core::marker::Freeze for hyperdriver::service::PreprocessService<S, F> where S: core::marker::Freeze, F: core::marker::Freeze
impl<S, F> core::marker::Send for hyperdriver::service::PreprocessService<S, F> where S: core::marker::Send, F: core::marker::Send
impl<S, F> core::marker::Sync for hyperdriver::service::PreprocessService<S, F> where S: core::marker::Sync, F: core::marker::Sync
impl<S, F> core::marker::Unpin for hyperdriver::service::PreprocessService<S, F> where S: core::marker::Unpin, F: core::marker::Unpin
impl<S, F> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::PreprocessService<S, F> where S: core::panic::unwind_safe::RefUnwindSafe, F: core::panic::unwind_safe::RefUnwindSafe
impl<S, F> core::panic::unwind_safe::UnwindSafe for hyperdriver::service::PreprocessService<S, F> where S: core::panic::unwind_safe::UnwindSafe, F: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::PreprocessService<S, F> where B: http_body::Body
impl<IO, T, F, R, E> hyperdriver::service::ServiceRef<IO> for hyperdriver::service::PreprocessService<S, F> where T: for<'a> tower_service::Service<&'a IO, Future = F, Response = R, Error = E>, F: core::future::future::Future<Output = core::result::Result<R, E>>
pub type hyperdriver::service::PreprocessService<S, F>::Error = E
pub type hyperdriver::service::PreprocessService<S, F>::Future = F
pub type hyperdriver::service::PreprocessService<S, F>::Response = R
pub fn hyperdriver::service::PreprocessService<S, F>::call(&mut self, stream: &IO) -> <T as hyperdriver::service::ServiceRef<IO>>::Future
pub fn hyperdriver::service::PreprocessService<S, F>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::ServiceRef<IO>>::Error>>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::PreprocessService<S, F> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::PreprocessService<S, F> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
pub type hyperdriver::service::PreprocessService<S, F>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::PreprocessService<S, F>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::PreprocessService<S, F>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::PreprocessService<S, F>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::PreprocessService<S, F>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::PreprocessService<S, F>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::PreprocessService<S, F>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::PreprocessService<S, F>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::PreprocessService<S, F>::Service = S
pub type hyperdriver::service::PreprocessService<S, F>::Service = S
pub fn hyperdriver::service::PreprocessService<S, F>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::PreprocessService<S, F>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::PreprocessService<S, F>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
pub fn hyperdriver::service::PreprocessService<S, F>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::service::PreprocessService<S, F> where S: tower_service::Service<R>
pub fn hyperdriver::service::PreprocessService<S, F>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::service::PreprocessService<S, F>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::service::PreprocessService<S, F> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::service::PreprocessService<S, F>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::service::PreprocessService<S, F>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::service::PreprocessService<S, F>::ResBody = BOut
pub fn hyperdriver::service::PreprocessService<S, F>::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::service::PreprocessService<S, F>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::PreprocessService<S, F> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::PreprocessService<S, F> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Target, E, ME, S, F, IB, OB> hyperdriver::service::MakeServiceRef<Target, IB> for hyperdriver::service::PreprocessService<S, F> where T: for<'a> tower_service::Service<&'a Target, Error = ME, Response = S, Future = F>, E: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>, ME: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>, S: hyperdriver::service::HttpService<IB, ResBody = OB, Error = E>, F: core::future::future::Future<Output = core::result::Result<S, ME>>, IB: http_body::Body, OB: http_body::Body
pub type hyperdriver::service::PreprocessService<S, F>::Error = E
pub type hyperdriver::service::PreprocessService<S, F>::Future = F
pub type hyperdriver::service::PreprocessService<S, F>::MakeError = ME
pub type hyperdriver::service::PreprocessService<S, F>::ResBody = OB
pub type hyperdriver::service::PreprocessService<S, F>::Service = S
pub fn hyperdriver::service::PreprocessService<S, F>::make_service_ref(&mut self, target: &Target) -> <T as hyperdriver::service::MakeServiceRef<Target, IB>>::Future
pub fn hyperdriver::service::PreprocessService<S, F>::poll_ready_ref(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::MakeServiceRef<Target, IB>>::MakeError>>
impl<T, U> core::convert::Into<U> for hyperdriver::service::PreprocessService<S, F> where U: core::convert::From<T>
pub fn hyperdriver::service::PreprocessService<S, F>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::PreprocessService<S, F> where U: core::convert::Into<T>
pub type hyperdriver::service::PreprocessService<S, F>::Error = core::convert::Infallible
pub fn hyperdriver::service::PreprocessService<S, F>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::PreprocessService<S, F> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::PreprocessService<S, F>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::PreprocessService<S, F>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::PreprocessService<S, F> where T: core::clone::Clone
pub type hyperdriver::service::PreprocessService<S, F>::Owned = T
pub fn hyperdriver::service::PreprocessService<S, F>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::PreprocessService<S, F>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::PreprocessService<S, F> where T: core::clone::Clone
pub fn hyperdriver::service::PreprocessService<S, F>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::PreprocessService<S, F> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::PreprocessService<S, F>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::PreprocessService<S, F> where T: core::marker::Sized
pub fn hyperdriver::service::PreprocessService<S, F>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::PreprocessService<S, F> where T: core::marker::Sized
pub fn hyperdriver::service::PreprocessService<S, F>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::PreprocessService<S, F> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::PreprocessService<S, F>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::PreprocessService<S, F>
pub fn hyperdriver::service::PreprocessService<S, F>::from(t: T) -> T
impl<T> hyperdriver::client::conn::transport::TransportExt for hyperdriver::service::PreprocessService<S, F> where T: hyperdriver::client::conn::transport::Transport
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::PreprocessService<S, F> where T: core::marker::Sized
pub fn hyperdriver::service::PreprocessService<S, F>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::PreprocessService<S, F>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::PreprocessService<S, F>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::PreprocessService<S, F>
pub struct hyperdriver::service::RequestExecutor<C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, B, K: hyperdriver::client::pool::Key>
impl<C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, B, K: hyperdriver::client::pool::Key> hyperdriver::service::RequestExecutor<C, B, K>
pub fn hyperdriver::service::RequestExecutor<C, B, K>::new() -> Self
impl<C, B, K> tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>> for hyperdriver::service::RequestExecutor<C, B, K> where C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, B: http_body::Body + core::marker::Unpin + core::marker::Send + 'static, K: hyperdriver::client::pool::Key
pub type hyperdriver::service::RequestExecutor<C, B, K>::Error = hyperdriver::client::Error
pub type hyperdriver::service::RequestExecutor<C, B, K>::Future = core::pin::Pin<alloc::boxed::Box<(dyn core::future::future::Future<Output = core::result::Result<<hyperdriver::service::RequestExecutor<C, B, K> as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Response, <hyperdriver::service::RequestExecutor<C, B, K> as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Error>> + core::marker::Send)>>
pub type hyperdriver::service::RequestExecutor<C, B, K>::Response = http::response::Response<<C as hyperdriver::client::conn::connection::Connection<B>>::ResBody>
pub fn hyperdriver::service::RequestExecutor<C, B, K>::call(&mut self, req: hyperdriver::service::ExecuteRequest<C, B, K>) -> Self::Future
pub fn hyperdriver::service::RequestExecutor<C, B, K>::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, B, K: hyperdriver::client::pool::Key> core::clone::Clone for hyperdriver::service::RequestExecutor<C, B, K>
pub fn hyperdriver::service::RequestExecutor<C, B, K>::clone(&self) -> Self
impl<C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, B, K: hyperdriver::client::pool::Key> core::default::Default for hyperdriver::service::RequestExecutor<C, B, K>
pub fn hyperdriver::service::RequestExecutor<C, B, K>::default() -> Self
impl<C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, B, K: hyperdriver::client::pool::Key> core::fmt::Debug for hyperdriver::service::RequestExecutor<C, B, K>
pub fn hyperdriver::service::RequestExecutor<C, B, K>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<C, B, K> core::marker::Freeze for hyperdriver::service::RequestExecutor<C, B, K>
impl<C, B, K> core::marker::Send for hyperdriver::service::RequestExecutor<C, B, K>
impl<C, B, K> core::marker::Sync for hyperdriver::service::RequestExecutor<C, B, K>
impl<C, B, K> core::marker::Unpin for hyperdriver::service::RequestExecutor<C, B, K>
impl<C, B, K> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::RequestExecutor<C, B, K>
impl<C, B, K> core::panic::unwind_safe::UnwindSafe for hyperdriver::service::RequestExecutor<C, B, K>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::RequestExecutor<C, B, K> where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::service::RequestExecutor<C, B, K> where S: tower_service::Service<R>
pub fn hyperdriver::service::RequestExecutor<C, B, K>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::service::RequestExecutor<C, B, K>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::RequestExecutor<C, B, K> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::RequestExecutor<C, B, K> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::service::RequestExecutor<C, B, K> where U: core::convert::From<T>
pub fn hyperdriver::service::RequestExecutor<C, B, K>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::RequestExecutor<C, B, K> where U: core::convert::Into<T>
pub type hyperdriver::service::RequestExecutor<C, B, K>::Error = core::convert::Infallible
pub fn hyperdriver::service::RequestExecutor<C, B, K>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::RequestExecutor<C, B, K> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::RequestExecutor<C, B, K>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::RequestExecutor<C, B, K>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::RequestExecutor<C, B, K> where T: core::clone::Clone
pub type hyperdriver::service::RequestExecutor<C, B, K>::Owned = T
pub fn hyperdriver::service::RequestExecutor<C, B, K>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::RequestExecutor<C, B, K>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::RequestExecutor<C, B, K> where T: core::clone::Clone
pub fn hyperdriver::service::RequestExecutor<C, B, K>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::RequestExecutor<C, B, K> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::RequestExecutor<C, B, K>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::RequestExecutor<C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::RequestExecutor<C, B, K>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::RequestExecutor<C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::RequestExecutor<C, B, K>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::RequestExecutor<C, B, K> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::RequestExecutor<C, B, K>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::RequestExecutor<C, B, K>
pub fn hyperdriver::service::RequestExecutor<C, B, K>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::RequestExecutor<C, B, K> where T: core::marker::Sized
pub fn hyperdriver::service::RequestExecutor<C, B, K>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::RequestExecutor<C, B, K>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::RequestExecutor<C, B, K>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::RequestExecutor<C, B, K>
pub struct hyperdriver::service::SetHostHeader<S>
impl<S, B, C, K> tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>> for hyperdriver::service::SetHostHeader<S> where S: tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>, C: hyperdriver::client::conn::connection::Connection<B> + hyperdriver::client::pool::PoolableConnection, K: hyperdriver::client::pool::Key
pub type hyperdriver::service::SetHostHeader<S>::Error = <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Error
pub type hyperdriver::service::SetHostHeader<S>::Future = <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Future
pub type hyperdriver::service::SetHostHeader<S>::Response = <S as tower_service::Service<hyperdriver::service::ExecuteRequest<C, B, K>>>::Response
pub fn hyperdriver::service::SetHostHeader<S>::call(&mut self, req: hyperdriver::service::ExecuteRequest<C, B, K>) -> Self::Future
pub fn hyperdriver::service::SetHostHeader<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S, B> tower_service::Service<http::request::Request<B>> for hyperdriver::service::SetHostHeader<S> where S: tower_service::Service<http::request::Request<B>>
pub type hyperdriver::service::SetHostHeader<S>::Error = <S as tower_service::Service<http::request::Request<B>>>::Error
pub type hyperdriver::service::SetHostHeader<S>::Future = <S as tower_service::Service<http::request::Request<B>>>::Future
pub type hyperdriver::service::SetHostHeader<S>::Response = <S as tower_service::Service<http::request::Request<B>>>::Response
pub fn hyperdriver::service::SetHostHeader<S>::call(&mut self, req: http::request::Request<B>) -> Self::Future
pub fn hyperdriver::service::SetHostHeader<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S: core::clone::Clone> core::clone::Clone for hyperdriver::service::SetHostHeader<S>
pub fn hyperdriver::service::SetHostHeader<S>::clone(&self) -> hyperdriver::service::SetHostHeader<S>
impl<S: core::default::Default> core::default::Default for hyperdriver::service::SetHostHeader<S>
pub fn hyperdriver::service::SetHostHeader<S>::default() -> hyperdriver::service::SetHostHeader<S>
impl<S: core::fmt::Debug> core::fmt::Debug for hyperdriver::service::SetHostHeader<S>
pub fn hyperdriver::service::SetHostHeader<S>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S> core::marker::Freeze for hyperdriver::service::SetHostHeader<S> where S: core::marker::Freeze
impl<S> core::marker::Send for hyperdriver::service::SetHostHeader<S> where S: core::marker::Send
impl<S> core::marker::Sync for hyperdriver::service::SetHostHeader<S> where S: core::marker::Sync
impl<S> core::marker::Unpin for hyperdriver::service::SetHostHeader<S> where S: core::marker::Unpin
impl<S> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::SetHostHeader<S> where S: core::panic::unwind_safe::RefUnwindSafe
impl<S> core::panic::unwind_safe::UnwindSafe for hyperdriver::service::SetHostHeader<S> where S: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::SetHostHeader<S> where B: http_body::Body
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::SetHostHeader<S> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::SetHostHeader<S> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
pub type hyperdriver::service::SetHostHeader<S>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::SetHostHeader<S>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::SetHostHeader<S>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::SetHostHeader<S>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::SetHostHeader<S>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::SetHostHeader<S>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::SetHostHeader<S>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::SetHostHeader<S>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::SetHostHeader<S>::Service = S
pub type hyperdriver::service::SetHostHeader<S>::Service = S
pub fn hyperdriver::service::SetHostHeader<S>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::SetHostHeader<S>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::SetHostHeader<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
pub fn hyperdriver::service::SetHostHeader<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::service::SetHostHeader<S> where S: tower_service::Service<R>
pub fn hyperdriver::service::SetHostHeader<S>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::service::SetHostHeader<S>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::service::SetHostHeader<S> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::service::SetHostHeader<S>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::service::SetHostHeader<S>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::service::SetHostHeader<S>::ResBody = BOut
pub fn hyperdriver::service::SetHostHeader<S>::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::service::SetHostHeader<S>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::SetHostHeader<S> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::SetHostHeader<S> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::service::SetHostHeader<S> where U: core::convert::From<T>
pub fn hyperdriver::service::SetHostHeader<S>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::SetHostHeader<S> where U: core::convert::Into<T>
pub type hyperdriver::service::SetHostHeader<S>::Error = core::convert::Infallible
pub fn hyperdriver::service::SetHostHeader<S>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::SetHostHeader<S> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::SetHostHeader<S>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::SetHostHeader<S>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::SetHostHeader<S> where T: core::clone::Clone
pub type hyperdriver::service::SetHostHeader<S>::Owned = T
pub fn hyperdriver::service::SetHostHeader<S>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::SetHostHeader<S>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::SetHostHeader<S> where T: core::clone::Clone
pub fn hyperdriver::service::SetHostHeader<S>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::SetHostHeader<S> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::SetHostHeader<S>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::SetHostHeader<S> where T: core::marker::Sized
pub fn hyperdriver::service::SetHostHeader<S>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::SetHostHeader<S> where T: core::marker::Sized
pub fn hyperdriver::service::SetHostHeader<S>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::SetHostHeader<S> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::SetHostHeader<S>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::SetHostHeader<S>
pub fn hyperdriver::service::SetHostHeader<S>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::SetHostHeader<S> where T: core::marker::Sized
pub fn hyperdriver::service::SetHostHeader<S>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::SetHostHeader<S>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::SetHostHeader<S>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::SetHostHeader<S>
pub struct hyperdriver::service::SetHostHeaderLayer
impl hyperdriver::service::SetHostHeaderLayer
pub fn hyperdriver::service::SetHostHeaderLayer::new() -> Self
impl core::clone::Clone for hyperdriver::service::SetHostHeaderLayer
pub fn hyperdriver::service::SetHostHeaderLayer::clone(&self) -> hyperdriver::service::SetHostHeaderLayer
impl core::default::Default for hyperdriver::service::SetHostHeaderLayer
pub fn hyperdriver::service::SetHostHeaderLayer::default() -> hyperdriver::service::SetHostHeaderLayer
impl core::fmt::Debug for hyperdriver::service::SetHostHeaderLayer
pub fn hyperdriver::service::SetHostHeaderLayer::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S> tower_layer::Layer<S> for hyperdriver::service::SetHostHeaderLayer
pub type hyperdriver::service::SetHostHeaderLayer::Service = hyperdriver::service::SetHostHeader<S>
pub fn hyperdriver::service::SetHostHeaderLayer::layer(&self, inner: S) -> Self::Service
impl core::marker::Freeze for hyperdriver::service::SetHostHeaderLayer
impl core::marker::Send for hyperdriver::service::SetHostHeaderLayer
impl core::marker::Sync for hyperdriver::service::SetHostHeaderLayer
impl core::marker::Unpin for hyperdriver::service::SetHostHeaderLayer
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::SetHostHeaderLayer
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::service::SetHostHeaderLayer
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::SetHostHeaderLayer where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::service::SetHostHeaderLayer where U: core::convert::From<T>
pub fn hyperdriver::service::SetHostHeaderLayer::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::SetHostHeaderLayer where U: core::convert::Into<T>
pub type hyperdriver::service::SetHostHeaderLayer::Error = core::convert::Infallible
pub fn hyperdriver::service::SetHostHeaderLayer::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::SetHostHeaderLayer where U: core::convert::TryFrom<T>
pub type hyperdriver::service::SetHostHeaderLayer::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::SetHostHeaderLayer::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::SetHostHeaderLayer where T: core::clone::Clone
pub type hyperdriver::service::SetHostHeaderLayer::Owned = T
pub fn hyperdriver::service::SetHostHeaderLayer::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::SetHostHeaderLayer::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::SetHostHeaderLayer where T: core::clone::Clone
pub fn hyperdriver::service::SetHostHeaderLayer::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::SetHostHeaderLayer where T: 'static + core::marker::Sized
pub fn hyperdriver::service::SetHostHeaderLayer::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::SetHostHeaderLayer where T: core::marker::Sized
pub fn hyperdriver::service::SetHostHeaderLayer::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::SetHostHeaderLayer where T: core::marker::Sized
pub fn hyperdriver::service::SetHostHeaderLayer::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::SetHostHeaderLayer where T: core::clone::Clone
pub unsafe fn hyperdriver::service::SetHostHeaderLayer::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::SetHostHeaderLayer
pub fn hyperdriver::service::SetHostHeaderLayer::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::SetHostHeaderLayer where T: core::marker::Sized
pub fn hyperdriver::service::SetHostHeaderLayer::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::SetHostHeaderLayer::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::SetHostHeaderLayer
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::SetHostHeaderLayer
pub struct hyperdriver::service::SharedService<T, U, E>(_)
impl<T, U, E> hyperdriver::service::SharedService<T, U, E>
pub fn hyperdriver::service::SharedService<T, U, E>::layer<S>() -> impl tower_layer::Layer<S, Service = hyperdriver::service::SharedService<T, U, E>> where S: tower_service::Service<T, Response = U, Error = E> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, <S as tower_service::Service>::Future: core::marker::Send + 'static
pub fn hyperdriver::service::SharedService<T, U, E>::new<S>(service: S) -> Self where S: tower_service::Service<T, Response = U, Error = E> + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static, <S as tower_service::Service>::Future: core::marker::Send + 'static
impl<T, U, E> core::clone::Clone for hyperdriver::service::SharedService<T, U, E>
pub fn hyperdriver::service::SharedService<T, U, E>::clone(&self) -> Self
impl<T, U, E> core::fmt::Debug for hyperdriver::service::SharedService<T, U, E>
pub fn hyperdriver::service::SharedService<T, U, E>::fmt(&self, fmt: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T, U, E> tower_service::Service<T> for hyperdriver::service::SharedService<T, U, E>
pub type hyperdriver::service::SharedService<T, U, E>::Error = E
pub type hyperdriver::service::SharedService<T, U, E>::Future = core::pin::Pin<alloc::boxed::Box<(dyn core::future::future::Future<Output = core::result::Result<U, E>> + core::marker::Send)>>
pub type hyperdriver::service::SharedService<T, U, E>::Response = U
pub fn hyperdriver::service::SharedService<T, U, E>::call(&mut self, req: T) -> Self::Future
pub fn hyperdriver::service::SharedService<T, U, E>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<T, U, E> core::marker::Freeze for hyperdriver::service::SharedService<T, U, E>
impl<T, U, E> core::marker::Send for hyperdriver::service::SharedService<T, U, E>
impl<T, U, E> core::marker::Sync for hyperdriver::service::SharedService<T, U, E>
impl<T, U, E> core::marker::Unpin for hyperdriver::service::SharedService<T, U, E>
impl<T, U, E> !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::SharedService<T, U, E>
impl<T, U, E> !core::panic::unwind_safe::UnwindSafe for hyperdriver::service::SharedService<T, U, E>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::SharedService<T, U, E> where B: http_body::Body
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::SharedService<T, U, E> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::SharedService<T, U, E> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
pub type hyperdriver::service::SharedService<T, U, E>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::SharedService<T, U, E>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::SharedService<T, U, E>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::SharedService<T, U, E>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::SharedService<T, U, E>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::SharedService<T, U, E>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::SharedService<T, U, E>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::SharedService<T, U, E>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::SharedService<T, U, E>::Service = S
pub type hyperdriver::service::SharedService<T, U, E>::Service = S
pub fn hyperdriver::service::SharedService<T, U, E>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::SharedService<T, U, E>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::SharedService<T, U, E>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
pub fn hyperdriver::service::SharedService<T, U, E>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::service::SharedService<T, U, E> where S: tower_service::Service<R>
pub fn hyperdriver::service::SharedService<T, U, E>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::service::SharedService<T, U, E>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::service::SharedService<T, U, E> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::service::SharedService<T, U, E>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::service::SharedService<T, U, E>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::service::SharedService<T, U, E>::ResBody = BOut
pub fn hyperdriver::service::SharedService<T, U, E>::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::service::SharedService<T, U, E>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::SharedService<T, U, E> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::SharedService<T, U, E> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::service::SharedService<T, U, E> where U: core::convert::From<T>
pub fn hyperdriver::service::SharedService<T, U, E>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::SharedService<T, U, E> where U: core::convert::Into<T>
pub type hyperdriver::service::SharedService<T, U, E>::Error = core::convert::Infallible
pub fn hyperdriver::service::SharedService<T, U, E>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::SharedService<T, U, E> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::SharedService<T, U, E>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::SharedService<T, U, E>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::SharedService<T, U, E> where T: core::clone::Clone
pub type hyperdriver::service::SharedService<T, U, E>::Owned = T
pub fn hyperdriver::service::SharedService<T, U, E>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::SharedService<T, U, E>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::SharedService<T, U, E> where T: core::clone::Clone
pub fn hyperdriver::service::SharedService<T, U, E>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::SharedService<T, U, E> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::SharedService<T, U, E>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::SharedService<T, U, E> where T: core::marker::Sized
pub fn hyperdriver::service::SharedService<T, U, E>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::SharedService<T, U, E> where T: core::marker::Sized
pub fn hyperdriver::service::SharedService<T, U, E>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::SharedService<T, U, E> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::SharedService<T, U, E>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::SharedService<T, U, E>
pub fn hyperdriver::service::SharedService<T, U, E>::from(t: T) -> T
impl<T> hyperdriver::client::conn::transport::TransportExt for hyperdriver::service::SharedService<T, U, E> where T: hyperdriver::client::conn::transport::Transport
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::SharedService<T, U, E> where T: core::marker::Sized
pub fn hyperdriver::service::SharedService<T, U, E>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::SharedService<T, U, E>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::SharedService<T, U, E>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::SharedService<T, U, E>
pub struct hyperdriver::service::Timeout<S, E>
impl<S, E> hyperdriver::service::Timeout<S, E>
pub fn hyperdriver::service::Timeout<S, E>::new(inner: S, timeout: core::time::Duration, error: alloc::boxed::Box<fn() -> E>) -> Self
impl<S, E, Req> tower_service::Service<Req> for hyperdriver::service::Timeout<S, E> where S: tower_service::Service<Req, Error = E>
pub type hyperdriver::service::Timeout<S, E>::Error = E
pub type hyperdriver::service::Timeout<S, E>::Future = TimeoutFuture<<S as tower_service::Service<Req>>::Future, <S as tower_service::Service<Req>>::Response, E>
pub type hyperdriver::service::Timeout<S, E>::Response = <S as tower_service::Service<Req>>::Response
pub fn hyperdriver::service::Timeout<S, E>::call(&mut self, req: Req) -> Self::Future
pub fn hyperdriver::service::Timeout<S, E>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<S, E> core::clone::Clone for hyperdriver::service::Timeout<S, E> where S: core::clone::Clone
pub fn hyperdriver::service::Timeout<S, E>::clone(&self) -> Self
impl<S, E> core::fmt::Debug for hyperdriver::service::Timeout<S, E> where S: core::fmt::Debug
pub fn hyperdriver::service::Timeout<S, E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S, E> core::marker::Freeze for hyperdriver::service::Timeout<S, E> where S: core::marker::Freeze
impl<S, E> core::marker::Send for hyperdriver::service::Timeout<S, E> where S: core::marker::Send
impl<S, E> core::marker::Sync for hyperdriver::service::Timeout<S, E> where S: core::marker::Sync
impl<S, E> core::marker::Unpin for hyperdriver::service::Timeout<S, E> where S: core::marker::Unpin
impl<S, E> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::Timeout<S, E> where S: core::panic::unwind_safe::RefUnwindSafe
impl<S, E> core::panic::unwind_safe::UnwindSafe for hyperdriver::service::Timeout<S, E> where S: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::Timeout<S, E> where B: http_body::Body
impl<IO, T, F, R, E> hyperdriver::service::ServiceRef<IO> for hyperdriver::service::Timeout<S, E> where T: for<'a> tower_service::Service<&'a IO, Future = F, Response = R, Error = E>, F: core::future::future::Future<Output = core::result::Result<R, E>>
pub type hyperdriver::service::Timeout<S, E>::Error = E
pub type hyperdriver::service::Timeout<S, E>::Future = F
pub type hyperdriver::service::Timeout<S, E>::Response = R
pub fn hyperdriver::service::Timeout<S, E>::call(&mut self, stream: &IO) -> <T as hyperdriver::service::ServiceRef<IO>>::Future
pub fn hyperdriver::service::Timeout<S, E>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::ServiceRef<IO>>::Error>>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::Timeout<S, E> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
impl<M, S, Target, Request> tower::make::make_service::MakeService<Target, Request> for hyperdriver::service::Timeout<S, E> where M: tower_service::Service<Target, Response = S>, S: tower_service::Service<Request>
pub type hyperdriver::service::Timeout<S, E>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::Timeout<S, E>::Error = <S as tower_service::Service<Request>>::Error
pub type hyperdriver::service::Timeout<S, E>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::Timeout<S, E>::Future = <M as tower_service::Service<Target>>::Future
pub type hyperdriver::service::Timeout<S, E>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::Timeout<S, E>::MakeError = <M as tower_service::Service<Target>>::Error
pub type hyperdriver::service::Timeout<S, E>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::Timeout<S, E>::Response = <S as tower_service::Service<Request>>::Response
pub type hyperdriver::service::Timeout<S, E>::Service = S
pub type hyperdriver::service::Timeout<S, E>::Service = S
pub fn hyperdriver::service::Timeout<S, E>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::Timeout<S, E>::make_service(&mut self, target: Target) -> <M as tower::make::make_service::MakeService<Target, Request>>::Future
pub fn hyperdriver::service::Timeout<S, E>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
pub fn hyperdriver::service::Timeout<S, E>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <M as tower::make::make_service::MakeService<Target, Request>>::MakeError>>
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::service::Timeout<S, E> where S: tower_service::Service<R>
pub fn hyperdriver::service::Timeout<S, E>::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::service::Timeout<S, E>::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::service::Timeout<S, E> where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::service::Timeout<S, E>::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::service::Timeout<S, E>::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::service::Timeout<S, E>::ResBody = BOut
pub fn hyperdriver::service::Timeout<S, E>::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::service::Timeout<S, E>::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::Timeout<S, E> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::service::Timeout<S, E> where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Target, E, ME, S, F, IB, OB> hyperdriver::service::MakeServiceRef<Target, IB> for hyperdriver::service::Timeout<S, E> where T: for<'a> tower_service::Service<&'a Target, Error = ME, Response = S, Future = F>, E: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>, ME: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>, S: hyperdriver::service::HttpService<IB, ResBody = OB, Error = E>, F: core::future::future::Future<Output = core::result::Result<S, ME>>, IB: http_body::Body, OB: http_body::Body
pub type hyperdriver::service::Timeout<S, E>::Error = E
pub type hyperdriver::service::Timeout<S, E>::Future = F
pub type hyperdriver::service::Timeout<S, E>::MakeError = ME
pub type hyperdriver::service::Timeout<S, E>::ResBody = OB
pub type hyperdriver::service::Timeout<S, E>::Service = S
pub fn hyperdriver::service::Timeout<S, E>::make_service_ref(&mut self, target: &Target) -> <T as hyperdriver::service::MakeServiceRef<Target, IB>>::Future
pub fn hyperdriver::service::Timeout<S, E>::poll_ready_ref(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::MakeServiceRef<Target, IB>>::MakeError>>
impl<T, U> core::convert::Into<U> for hyperdriver::service::Timeout<S, E> where U: core::convert::From<T>
pub fn hyperdriver::service::Timeout<S, E>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::Timeout<S, E> where U: core::convert::Into<T>
pub type hyperdriver::service::Timeout<S, E>::Error = core::convert::Infallible
pub fn hyperdriver::service::Timeout<S, E>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::Timeout<S, E> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::Timeout<S, E>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::Timeout<S, E>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::Timeout<S, E> where T: core::clone::Clone
pub type hyperdriver::service::Timeout<S, E>::Owned = T
pub fn hyperdriver::service::Timeout<S, E>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::Timeout<S, E>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::Timeout<S, E> where T: core::clone::Clone
pub fn hyperdriver::service::Timeout<S, E>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::Timeout<S, E> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::Timeout<S, E>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::Timeout<S, E> where T: core::marker::Sized
pub fn hyperdriver::service::Timeout<S, E>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::Timeout<S, E> where T: core::marker::Sized
pub fn hyperdriver::service::Timeout<S, E>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::Timeout<S, E> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::Timeout<S, E>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::Timeout<S, E>
pub fn hyperdriver::service::Timeout<S, E>::from(t: T) -> T
impl<T> hyperdriver::client::conn::transport::TransportExt for hyperdriver::service::Timeout<S, E> where T: hyperdriver::client::conn::transport::Transport
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::Timeout<S, E> where T: core::marker::Sized
pub fn hyperdriver::service::Timeout<S, E>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::Timeout<S, E>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::Timeout<S, E>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::Timeout<S, E>
pub struct hyperdriver::service::TimeoutLayer<E>
impl<E> hyperdriver::service::TimeoutLayer<E>
pub fn hyperdriver::service::TimeoutLayer<E>::new(error: fn() -> E, timeout: core::time::Duration) -> Self
impl<E> core::clone::Clone for hyperdriver::service::TimeoutLayer<E>
pub fn hyperdriver::service::TimeoutLayer<E>::clone(&self) -> Self
impl<E> core::fmt::Debug for hyperdriver::service::TimeoutLayer<E>
pub fn hyperdriver::service::TimeoutLayer<E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<S, E> tower_layer::Layer<S> for hyperdriver::service::TimeoutLayer<E>
pub type hyperdriver::service::TimeoutLayer<E>::Service = hyperdriver::service::Timeout<S, E>
pub fn hyperdriver::service::TimeoutLayer<E>::layer(&self, inner: S) -> Self::Service
impl<E> core::marker::Freeze for hyperdriver::service::TimeoutLayer<E>
impl<E> core::marker::Send for hyperdriver::service::TimeoutLayer<E>
impl<E> core::marker::Sync for hyperdriver::service::TimeoutLayer<E>
impl<E> core::marker::Unpin for hyperdriver::service::TimeoutLayer<E>
impl<E> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::service::TimeoutLayer<E>
impl<E> core::panic::unwind_safe::UnwindSafe for hyperdriver::service::TimeoutLayer<E>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::service::TimeoutLayer<E> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::service::TimeoutLayer<E> where U: core::convert::From<T>
pub fn hyperdriver::service::TimeoutLayer<E>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::service::TimeoutLayer<E> where U: core::convert::Into<T>
pub type hyperdriver::service::TimeoutLayer<E>::Error = core::convert::Infallible
pub fn hyperdriver::service::TimeoutLayer<E>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::service::TimeoutLayer<E> where U: core::convert::TryFrom<T>
pub type hyperdriver::service::TimeoutLayer<E>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::service::TimeoutLayer<E>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::service::TimeoutLayer<E> where T: core::clone::Clone
pub type hyperdriver::service::TimeoutLayer<E>::Owned = T
pub fn hyperdriver::service::TimeoutLayer<E>::clone_into(&self, target: &mut T)
pub fn hyperdriver::service::TimeoutLayer<E>::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::service::TimeoutLayer<E> where T: core::clone::Clone
pub fn hyperdriver::service::TimeoutLayer<E>::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::service::TimeoutLayer<E> where T: 'static + core::marker::Sized
pub fn hyperdriver::service::TimeoutLayer<E>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::service::TimeoutLayer<E> where T: core::marker::Sized
pub fn hyperdriver::service::TimeoutLayer<E>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::service::TimeoutLayer<E> where T: core::marker::Sized
pub fn hyperdriver::service::TimeoutLayer<E>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::service::TimeoutLayer<E> where T: core::clone::Clone
pub unsafe fn hyperdriver::service::TimeoutLayer<E>::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::service::TimeoutLayer<E>
pub fn hyperdriver::service::TimeoutLayer<E>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::service::TimeoutLayer<E> where T: core::marker::Sized
pub fn hyperdriver::service::TimeoutLayer<E>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::service::TimeoutLayer<E>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::service::TimeoutLayer<E>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::service::TimeoutLayer<E>
pub trait hyperdriver::service::HttpService<ReqBody>
pub type hyperdriver::service::HttpService::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub type hyperdriver::service::HttpService::Future: core::future::future::Future<Output = core::result::Result<http::response::Response<Self::ResBody>, Self::Error>>
pub type hyperdriver::service::HttpService::ResBody: http_body::Body
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for T where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub type T::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type T::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type T::ResBody = BOut
pub trait hyperdriver::service::MakeServiceRef<Target, ReqBody>: Sealed<(Target, ReqBody)>
pub type hyperdriver::service::MakeServiceRef::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub type hyperdriver::service::MakeServiceRef::Future: core::future::future::Future<Output = core::result::Result<Self::Service, Self::MakeError>>
pub type hyperdriver::service::MakeServiceRef::MakeError: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub type hyperdriver::service::MakeServiceRef::ResBody: http_body::Body
pub type hyperdriver::service::MakeServiceRef::Service: hyperdriver::service::HttpService<ReqBody, ResBody = Self::ResBody, Error = Self::Error>
pub fn hyperdriver::service::MakeServiceRef::make_service_ref(&mut self, target: &Target) -> Self::Future
pub fn hyperdriver::service::MakeServiceRef::poll_ready_ref(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::MakeError>>
impl<T, Target, E, ME, S, F, IB, OB> hyperdriver::service::MakeServiceRef<Target, IB> for T where T: for<'a> tower_service::Service<&'a Target, Error = ME, Response = S, Future = F>, E: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, ME: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>, S: hyperdriver::service::HttpService<IB, ResBody = OB, Error = E>, F: core::future::future::Future<Output = core::result::Result<S, ME>>, IB: http_body::Body, OB: http_body::Body
pub type T::Error = E
pub type T::Future = F
pub type T::MakeError = ME
pub type T::ResBody = OB
pub type T::Service = S
pub fn T::make_service_ref(&mut self, target: &Target) -> <T as hyperdriver::service::MakeServiceRef<Target, IB>>::Future
pub fn T::poll_ready_ref(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::MakeServiceRef<Target, IB>>::MakeError>>
pub trait hyperdriver::service::OptionLayerExt<S>
pub fn hyperdriver::service::OptionLayerExt::optional<T>(self, middleware: core::option::Option<T>) -> tower::builder::ServiceBuilder<tower_layer::stack::Stack<hyperdriver::service::OptionLayer<T>, S>>
impl<S> hyperdriver::service::OptionLayerExt<S> for tower::builder::ServiceBuilder<S>
pub fn tower::builder::ServiceBuilder<S>::optional<T>(self, middleware: core::option::Option<T>) -> tower::builder::ServiceBuilder<tower_layer::stack::Stack<hyperdriver::service::OptionLayer<T>, S>>
pub trait hyperdriver::service::ServiceRef<IO>: Sealed<IO>
pub type hyperdriver::service::ServiceRef::Error
pub type hyperdriver::service::ServiceRef::Future: core::future::future::Future<Output = core::result::Result<Self::Response, Self::Error>>
pub type hyperdriver::service::ServiceRef::Response
pub fn hyperdriver::service::ServiceRef::call(&mut self, stream: &IO) -> Self::Future
pub fn hyperdriver::service::ServiceRef::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl<IO, T, F, R, E> hyperdriver::service::ServiceRef<IO> for T where T: for<'a> tower_service::Service<&'a IO, Future = F, Response = R, Error = E>, F: core::future::future::Future<Output = core::result::Result<R, E>>
pub type T::Error = E
pub type T::Future = F
pub type T::Response = R
pub fn T::call(&mut self, stream: &IO) -> <T as hyperdriver::service::ServiceRef<IO>>::Future
pub fn T::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::ServiceRef<IO>>::Error>>
pub fn hyperdriver::service::make_service_fn<F, Target, Ret>(f: F) -> MakeServiceFn<F> where F: core::ops::function::FnMut(&Target) -> Ret, Ret: core::future::future::Future
pub mod hyperdriver::stream
pub mod hyperdriver::stream::duplex
pub struct hyperdriver::stream::duplex::DuplexAddr
impl hyperdriver::stream::duplex::DuplexAddr
pub fn hyperdriver::stream::duplex::DuplexAddr::new() -> Self
impl core::clone::Clone for hyperdriver::stream::duplex::DuplexAddr
pub fn hyperdriver::stream::duplex::DuplexAddr::clone(&self) -> hyperdriver::stream::duplex::DuplexAddr
impl core::cmp::Eq for hyperdriver::stream::duplex::DuplexAddr
impl core::cmp::PartialEq for hyperdriver::stream::duplex::DuplexAddr
pub fn hyperdriver::stream::duplex::DuplexAddr::eq(&self, other: &hyperdriver::stream::duplex::DuplexAddr) -> bool
impl core::convert::From<hyperdriver::stream::duplex::DuplexAddr> for hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::from(hyperdriver::stream::duplex::DuplexAddr) -> Self
impl core::default::Default for hyperdriver::stream::duplex::DuplexAddr
pub fn hyperdriver::stream::duplex::DuplexAddr::default() -> hyperdriver::stream::duplex::DuplexAddr
impl core::fmt::Debug for hyperdriver::stream::duplex::DuplexAddr
pub fn hyperdriver::stream::duplex::DuplexAddr::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::stream::duplex::DuplexAddr
pub fn hyperdriver::stream::duplex::DuplexAddr::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for hyperdriver::stream::duplex::DuplexAddr
pub fn hyperdriver::stream::duplex::DuplexAddr::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::StructuralPartialEq for hyperdriver::stream::duplex::DuplexAddr
impl core::marker::Freeze for hyperdriver::stream::duplex::DuplexAddr
impl core::marker::Send for hyperdriver::stream::duplex::DuplexAddr
impl core::marker::Sync for hyperdriver::stream::duplex::DuplexAddr
impl core::marker::Unpin for hyperdriver::stream::duplex::DuplexAddr
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::stream::duplex::DuplexAddr
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::stream::duplex::DuplexAddr
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::stream::duplex::DuplexAddr where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::stream::duplex::DuplexAddr where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexAddr::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::stream::duplex::DuplexAddr where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexAddr::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::stream::duplex::DuplexAddr where U: core::convert::From<T>
pub fn hyperdriver::stream::duplex::DuplexAddr::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::stream::duplex::DuplexAddr where U: core::convert::Into<T>
pub type hyperdriver::stream::duplex::DuplexAddr::Error = core::convert::Infallible
pub fn hyperdriver::stream::duplex::DuplexAddr::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::stream::duplex::DuplexAddr where U: core::convert::TryFrom<T>
pub type hyperdriver::stream::duplex::DuplexAddr::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::stream::duplex::DuplexAddr::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::stream::duplex::DuplexAddr where T: core::clone::Clone
pub type hyperdriver::stream::duplex::DuplexAddr::Owned = T
pub fn hyperdriver::stream::duplex::DuplexAddr::clone_into(&self, target: &mut T)
pub fn hyperdriver::stream::duplex::DuplexAddr::to_owned(&self) -> T
impl<T> alloc::string::ToString for hyperdriver::stream::duplex::DuplexAddr where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexAddr::to_string(&self) -> alloc::string::String
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::stream::duplex::DuplexAddr where T: core::clone::Clone
pub fn hyperdriver::stream::duplex::DuplexAddr::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::stream::duplex::DuplexAddr where T: 'static + core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexAddr::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::stream::duplex::DuplexAddr where T: core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexAddr::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::stream::duplex::DuplexAddr where T: core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexAddr::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::stream::duplex::DuplexAddr where T: core::clone::Clone
pub unsafe fn hyperdriver::stream::duplex::DuplexAddr::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::stream::duplex::DuplexAddr
pub fn hyperdriver::stream::duplex::DuplexAddr::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::stream::duplex::DuplexAddr where T: core::fmt::Display
pub fn hyperdriver::stream::duplex::DuplexAddr::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::stream::duplex::DuplexAddr where T: core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexAddr::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::stream::duplex::DuplexAddr::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::stream::duplex::DuplexAddr
impl<T> tracing::instrument::WithSubscriber for hyperdriver::stream::duplex::DuplexAddr
pub struct hyperdriver::stream::duplex::DuplexClient
impl hyperdriver::stream::duplex::DuplexClient
pub async fn hyperdriver::stream::duplex::DuplexClient::connect(&self, max_buf_size: usize) -> core::result::Result<hyperdriver::stream::duplex::DuplexStream, std::io::error::Error>
impl core::clone::Clone for hyperdriver::stream::duplex::DuplexClient
pub fn hyperdriver::stream::duplex::DuplexClient::clone(&self) -> hyperdriver::stream::duplex::DuplexClient
impl core::fmt::Debug for hyperdriver::stream::duplex::DuplexClient
pub fn hyperdriver::stream::duplex::DuplexClient::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Freeze for hyperdriver::stream::duplex::DuplexClient
impl core::marker::Send for hyperdriver::stream::duplex::DuplexClient
impl core::marker::Sync for hyperdriver::stream::duplex::DuplexClient
impl core::marker::Unpin for hyperdriver::stream::duplex::DuplexClient
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::stream::duplex::DuplexClient
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::stream::duplex::DuplexClient
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::stream::duplex::DuplexClient where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::stream::duplex::DuplexClient where U: core::convert::From<T>
pub fn hyperdriver::stream::duplex::DuplexClient::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::stream::duplex::DuplexClient where U: core::convert::Into<T>
pub type hyperdriver::stream::duplex::DuplexClient::Error = core::convert::Infallible
pub fn hyperdriver::stream::duplex::DuplexClient::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::stream::duplex::DuplexClient where U: core::convert::TryFrom<T>
pub type hyperdriver::stream::duplex::DuplexClient::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::stream::duplex::DuplexClient::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::stream::duplex::DuplexClient where T: core::clone::Clone
pub type hyperdriver::stream::duplex::DuplexClient::Owned = T
pub fn hyperdriver::stream::duplex::DuplexClient::clone_into(&self, target: &mut T)
pub fn hyperdriver::stream::duplex::DuplexClient::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::stream::duplex::DuplexClient where T: core::clone::Clone
pub fn hyperdriver::stream::duplex::DuplexClient::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::stream::duplex::DuplexClient where T: 'static + core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexClient::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::stream::duplex::DuplexClient where T: core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexClient::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::stream::duplex::DuplexClient where T: core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexClient::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::stream::duplex::DuplexClient where T: core::clone::Clone
pub unsafe fn hyperdriver::stream::duplex::DuplexClient::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::stream::duplex::DuplexClient
pub fn hyperdriver::stream::duplex::DuplexClient::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::stream::duplex::DuplexClient where T: core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexClient::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::stream::duplex::DuplexClient::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::stream::duplex::DuplexClient
impl<T> tracing::instrument::WithSubscriber for hyperdriver::stream::duplex::DuplexClient
pub struct hyperdriver::stream::duplex::DuplexIncoming
impl hyperdriver::stream::duplex::DuplexIncoming
pub fn hyperdriver::stream::duplex::DuplexIncoming::with_max_buf_size(self, max_buf_size: usize) -> Self
impl core::convert::From<hyperdriver::stream::duplex::DuplexIncoming> for hyperdriver::server::conn::AcceptorCore
pub fn hyperdriver::server::conn::AcceptorCore::from(value: hyperdriver::stream::duplex::DuplexIncoming) -> Self
impl core::fmt::Debug for hyperdriver::stream::duplex::DuplexIncoming
pub fn hyperdriver::stream::duplex::DuplexIncoming::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl futures_core::stream::Stream for hyperdriver::stream::duplex::DuplexIncoming
pub type hyperdriver::stream::duplex::DuplexIncoming::Item = core::result::Result<hyperdriver::stream::duplex::DuplexStream, std::io::error::Error>
pub fn hyperdriver::stream::duplex::DuplexIncoming::poll_next(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::option::Option<Self::Item>>
impl hyperdriver::server::Accept for hyperdriver::stream::duplex::DuplexIncoming
pub type hyperdriver::stream::duplex::DuplexIncoming::Conn = hyperdriver::stream::duplex::DuplexStream
pub type hyperdriver::stream::duplex::DuplexIncoming::Error = std::io::error::Error
pub fn hyperdriver::stream::duplex::DuplexIncoming::poll_accept(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<Self::Conn, Self::Error>>
impl core::marker::Freeze for hyperdriver::stream::duplex::DuplexIncoming
impl core::marker::Send for hyperdriver::stream::duplex::DuplexIncoming
impl core::marker::Sync for hyperdriver::stream::duplex::DuplexIncoming
impl core::marker::Unpin for hyperdriver::stream::duplex::DuplexIncoming
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::stream::duplex::DuplexIncoming
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::stream::duplex::DuplexIncoming
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::stream::duplex::DuplexIncoming where B: http_body::Body
impl<A> hyperdriver::server::conn::AcceptExt for hyperdriver::stream::duplex::DuplexIncoming where A: hyperdriver::server::Accept
impl<A> hyperdriver::server::conn::tls::acceptor::TlsAcceptExt for hyperdriver::stream::duplex::DuplexIncoming where A: hyperdriver::server::Accept
impl<S, T, E> futures_core::stream::TryStream for hyperdriver::stream::duplex::DuplexIncoming where S: futures_core::stream::Stream<Item = core::result::Result<T, E>> + core::marker::Sized
pub type hyperdriver::stream::duplex::DuplexIncoming::Error = E
pub type hyperdriver::stream::duplex::DuplexIncoming::Ok = T
pub fn hyperdriver::stream::duplex::DuplexIncoming::try_poll_next(self: core::pin::Pin<&mut S>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::option::Option<core::result::Result<<S as futures_core::stream::TryStream>::Ok, <S as futures_core::stream::TryStream>::Error>>>
impl<S> futures_util::stream::try_stream::TryStreamExt for hyperdriver::stream::duplex::DuplexIncoming where S: futures_core::stream::TryStream + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::stream::duplex::DuplexIncoming where U: core::convert::From<T>
pub fn hyperdriver::stream::duplex::DuplexIncoming::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::stream::duplex::DuplexIncoming where U: core::convert::Into<T>
pub type hyperdriver::stream::duplex::DuplexIncoming::Error = core::convert::Infallible
pub fn hyperdriver::stream::duplex::DuplexIncoming::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::stream::duplex::DuplexIncoming where U: core::convert::TryFrom<T>
pub type hyperdriver::stream::duplex::DuplexIncoming::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::stream::duplex::DuplexIncoming::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::stream::duplex::DuplexIncoming where T: 'static + core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexIncoming::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::stream::duplex::DuplexIncoming where T: core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexIncoming::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::stream::duplex::DuplexIncoming where T: core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexIncoming::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::stream::duplex::DuplexIncoming
pub fn hyperdriver::stream::duplex::DuplexIncoming::from(t: T) -> T
impl<T> futures_util::stream::stream::StreamExt for hyperdriver::stream::duplex::DuplexIncoming where T: futures_core::stream::Stream + core::marker::Sized
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::stream::duplex::DuplexIncoming where T: core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexIncoming::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::stream::duplex::DuplexIncoming::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::stream::duplex::DuplexIncoming
impl<T> tracing::instrument::WithSubscriber for hyperdriver::stream::duplex::DuplexIncoming
pub struct hyperdriver::stream::duplex::DuplexStream
impl hyperdriver::stream::duplex::DuplexStream
pub fn hyperdriver::stream::duplex::DuplexStream::new(max_buf_size: usize) -> (Self, Self)
impl core::convert::From<hyperdriver::stream::duplex::DuplexStream> for hyperdriver::client::conn::stream::Stream
pub fn hyperdriver::client::conn::stream::Stream::from(stream: hyperdriver::stream::duplex::DuplexStream) -> Self
impl core::convert::From<hyperdriver::stream::duplex::DuplexStream> for hyperdriver::server::conn::Stream
pub fn hyperdriver::server::conn::Stream::from(stream: hyperdriver::stream::duplex::DuplexStream) -> Self
impl core::convert::From<hyperdriver::stream::duplex::DuplexStream> for hyperdriver::stream::Braid
pub fn hyperdriver::stream::Braid::from(stream: hyperdriver::stream::duplex::DuplexStream) -> Self
impl core::fmt::Debug for hyperdriver::stream::duplex::DuplexStream
pub fn hyperdriver::stream::duplex::DuplexStream::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl hyperdriver::client::pool::PoolableStream for hyperdriver::stream::duplex::DuplexStream
pub fn hyperdriver::stream::duplex::DuplexStream::can_share(&self) -> bool
impl hyperdriver::info::HasConnectionInfo for hyperdriver::stream::duplex::DuplexStream
pub type hyperdriver::stream::duplex::DuplexStream::Addr = hyperdriver::stream::duplex::DuplexAddr
pub fn hyperdriver::stream::duplex::DuplexStream::info(&self) -> hyperdriver::info::ConnectionInfo<hyperdriver::stream::duplex::DuplexAddr>
impl tokio::io::async_read::AsyncRead for hyperdriver::stream::duplex::DuplexStream
pub fn hyperdriver::stream::duplex::DuplexStream::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &mut tokio::io::read_buf::ReadBuf<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
impl tokio::io::async_write::AsyncWrite for hyperdriver::stream::duplex::DuplexStream
pub fn hyperdriver::stream::duplex::DuplexStream::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::duplex::DuplexStream::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::duplex::DuplexStream::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
impl<'pin> core::marker::Unpin for hyperdriver::stream::duplex::DuplexStream where __DuplexStream<'pin>: core::marker::Unpin
impl core::marker::Freeze for hyperdriver::stream::duplex::DuplexStream
impl core::marker::Send for hyperdriver::stream::duplex::DuplexStream
impl core::marker::Sync for hyperdriver::stream::duplex::DuplexStream
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::stream::duplex::DuplexStream
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::stream::duplex::DuplexStream
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::stream::duplex::DuplexStream where B: http_body::Body
impl<R> tokio::io::util::async_read_ext::AsyncReadExt for hyperdriver::stream::duplex::DuplexStream where R: tokio::io::async_read::AsyncRead + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::stream::duplex::DuplexStream where U: core::convert::From<T>
pub fn hyperdriver::stream::duplex::DuplexStream::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::stream::duplex::DuplexStream where U: core::convert::Into<T>
pub type hyperdriver::stream::duplex::DuplexStream::Error = core::convert::Infallible
pub fn hyperdriver::stream::duplex::DuplexStream::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::stream::duplex::DuplexStream where U: core::convert::TryFrom<T>
pub type hyperdriver::stream::duplex::DuplexStream::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::stream::duplex::DuplexStream::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::stream::duplex::DuplexStream where T: 'static + core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexStream::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::stream::duplex::DuplexStream where T: core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexStream::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::stream::duplex::DuplexStream where T: core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexStream::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::stream::duplex::DuplexStream
pub fn hyperdriver::stream::duplex::DuplexStream::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::stream::duplex::DuplexStream where T: core::marker::Sized
pub fn hyperdriver::stream::duplex::DuplexStream::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::stream::duplex::DuplexStream::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::stream::duplex::DuplexStream
impl<T> tracing::instrument::WithSubscriber for hyperdriver::stream::duplex::DuplexStream
impl<W> tokio::io::util::async_write_ext::AsyncWriteExt for hyperdriver::stream::duplex::DuplexStream where W: tokio::io::async_write::AsyncWrite + core::marker::Sized
pub fn hyperdriver::stream::duplex::pair() -> (hyperdriver::stream::duplex::DuplexClient, hyperdriver::stream::duplex::DuplexIncoming)
pub mod hyperdriver::stream::tcp
pub use hyperdriver::stream::tcp::TcpListener
pub struct hyperdriver::stream::tcp::TcpStream
impl hyperdriver::stream::tcp::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::client(inner: tokio::net::tcp::stream::TcpStream) -> Self
pub async fn hyperdriver::stream::tcp::TcpStream::connect<A: tokio::net::addr::ToSocketAddrs>(addr: A) -> std::io::error::Result<Self>
pub fn hyperdriver::stream::tcp::TcpStream::into_inner(self) -> tokio::net::tcp::stream::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::local_addr(&self) -> std::io::error::Result<core::net::socket_addr::SocketAddr>
pub fn hyperdriver::stream::tcp::TcpStream::peer_addr(&self) -> std::io::error::Result<core::net::socket_addr::SocketAddr>
pub fn hyperdriver::stream::tcp::TcpStream::server(inner: tokio::net::tcp::stream::TcpStream, remote: core::net::socket_addr::SocketAddr) -> Self
impl core::convert::From<hyperdriver::stream::tcp::TcpStream> for hyperdriver::client::conn::stream::Stream
pub fn hyperdriver::client::conn::stream::Stream::from(stream: hyperdriver::stream::tcp::TcpStream) -> Self
impl core::convert::From<hyperdriver::stream::tcp::TcpStream> for hyperdriver::stream::Braid
pub fn hyperdriver::stream::Braid::from(stream: hyperdriver::stream::tcp::TcpStream) -> Self
impl core::fmt::Debug for hyperdriver::stream::tcp::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::deref::Deref for hyperdriver::stream::tcp::TcpStream
pub type hyperdriver::stream::tcp::TcpStream::Target = tokio::net::tcp::stream::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::deref(&self) -> &Self::Target
impl core::ops::deref::DerefMut for hyperdriver::stream::tcp::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::deref_mut(&mut self) -> &mut Self::Target
impl hyperdriver::client::pool::PoolableStream for hyperdriver::stream::tcp::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::can_share(&self) -> bool
impl hyperdriver::info::HasConnectionInfo for hyperdriver::stream::tcp::TcpStream
pub type hyperdriver::stream::tcp::TcpStream::Addr = core::net::socket_addr::SocketAddr
pub fn hyperdriver::stream::tcp::TcpStream::info(&self) -> hyperdriver::info::ConnectionInfo<Self::Addr>
impl tokio::io::async_read::AsyncRead for hyperdriver::stream::tcp::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &mut tokio::io::read_buf::ReadBuf<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
impl tokio::io::async_write::AsyncWrite for hyperdriver::stream::tcp::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::is_write_vectored(&self) -> bool
pub fn hyperdriver::stream::tcp::TcpStream::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::tcp::TcpStream::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::tcp::TcpStream::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
pub fn hyperdriver::stream::tcp::TcpStream::poll_write_vectored(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, bufs: &[std::io::IoSlice<'_>]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
impl<'pin> core::marker::Unpin for hyperdriver::stream::tcp::TcpStream where __TcpStream<'pin>: core::marker::Unpin
impl !core::marker::Freeze for hyperdriver::stream::tcp::TcpStream
impl core::marker::Send for hyperdriver::stream::tcp::TcpStream
impl core::marker::Sync for hyperdriver::stream::tcp::TcpStream
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::stream::tcp::TcpStream
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::stream::tcp::TcpStream
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::stream::tcp::TcpStream where B: http_body::Body
impl<R> tokio::io::util::async_read_ext::AsyncReadExt for hyperdriver::stream::tcp::TcpStream where R: tokio::io::async_read::AsyncRead + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::stream::tcp::TcpStream where U: core::convert::From<T>
pub fn hyperdriver::stream::tcp::TcpStream::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::stream::tcp::TcpStream where U: core::convert::Into<T>
pub type hyperdriver::stream::tcp::TcpStream::Error = core::convert::Infallible
pub fn hyperdriver::stream::tcp::TcpStream::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::stream::tcp::TcpStream where U: core::convert::TryFrom<T>
pub type hyperdriver::stream::tcp::TcpStream::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::stream::tcp::TcpStream::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::stream::tcp::TcpStream where T: 'static + core::marker::Sized
pub fn hyperdriver::stream::tcp::TcpStream::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::stream::tcp::TcpStream where T: core::marker::Sized
pub fn hyperdriver::stream::tcp::TcpStream::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::stream::tcp::TcpStream where T: core::marker::Sized
pub fn hyperdriver::stream::tcp::TcpStream::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::stream::tcp::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::stream::tcp::TcpStream where T: core::marker::Sized
pub fn hyperdriver::stream::tcp::TcpStream::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::stream::tcp::TcpStream::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::stream::tcp::TcpStream
impl<T> tracing::instrument::WithSubscriber for hyperdriver::stream::tcp::TcpStream
impl<W> tokio::io::util::async_write_ext::AsyncWriteExt for hyperdriver::stream::tcp::TcpStream where W: tokio::io::async_write::AsyncWrite + core::marker::Sized
pub mod hyperdriver::stream::tls
pub enum hyperdriver::stream::tls::TlsBraid<Tls, NoTls>
pub hyperdriver::stream::tls::TlsBraid::NoTls(NoTls)
pub hyperdriver::stream::tls::TlsBraid::Tls(Tls)
impl<'pin, Tls, NoTls> core::marker::Unpin for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where __TlsBraid<'pin, Tls, NoTls>: core::marker::Unpin
impl<Tls, NoTls> core::convert::From<NoTls> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::from(stream: NoTls) -> Self
impl<Tls, NoTls> hyperdriver::client::pool::PoolableStream for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where Tls: hyperdriver::stream::tls::TlsHandshakeStream + core::marker::Send + core::marker::Unpin + 'static, NoTls: tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::can_share(&self) -> bool
impl<Tls, NoTls> hyperdriver::stream::tls::TlsHandshakeStream for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where Tls: hyperdriver::stream::tls::TlsHandshakeStream + core::marker::Unpin, NoTls: tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::poll_handshake(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
impl<Tls, NoTls> tokio::io::async_read::AsyncRead for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where Tls: tokio::io::async_read::AsyncRead, NoTls: tokio::io::async_read::AsyncRead
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &mut tokio::io::read_buf::ReadBuf<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
impl<Tls, NoTls> tokio::io::async_write::AsyncWrite for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where Tls: tokio::io::async_write::AsyncWrite, NoTls: tokio::io::async_write::AsyncWrite
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
impl<Tls: core::fmt::Debug, NoTls: core::fmt::Debug> core::fmt::Debug for hyperdriver::stream::tls::TlsBraid<Tls, NoTls>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<Tls, NoTls> core::marker::Freeze for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where NoTls: core::marker::Freeze, Tls: core::marker::Freeze
impl<Tls, NoTls> core::marker::Send for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where NoTls: core::marker::Send, Tls: core::marker::Send
impl<Tls, NoTls> core::marker::Sync for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where NoTls: core::marker::Sync, Tls: core::marker::Sync
impl<Tls, NoTls> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where NoTls: core::panic::unwind_safe::RefUnwindSafe, Tls: core::panic::unwind_safe::RefUnwindSafe
impl<Tls, NoTls> core::panic::unwind_safe::UnwindSafe for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where NoTls: core::panic::unwind_safe::UnwindSafe, Tls: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where B: http_body::Body
impl<R> tokio::io::util::async_read_ext::AsyncReadExt for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where R: tokio::io::async_read::AsyncRead + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where U: core::convert::From<T>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where U: core::convert::Into<T>
pub type hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::Error = core::convert::Infallible
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where U: core::convert::TryFrom<T>
pub type hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where T: 'static + core::marker::Sized
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where T: core::marker::Sized
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where T: core::marker::Sized
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::from(t: T) -> T
impl<T> core::convert::From<never> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::from(t: never) -> T
impl<T> hyperdriver::stream::tls::TlsHandshakeExt for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where T: hyperdriver::stream::tls::TlsHandshakeStream
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where T: core::marker::Sized
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::stream::tls::TlsBraid<Tls, NoTls>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::stream::tls::TlsBraid<Tls, NoTls>
impl<W> tokio::io::util::async_write_ext::AsyncWriteExt for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where W: tokio::io::async_write::AsyncWrite + core::marker::Sized
pub struct hyperdriver::stream::tls::Handshaking<'a, T: core::marker::Sized>
impl<'a, T: core::fmt::Debug + core::marker::Sized> core::fmt::Debug for hyperdriver::stream::tls::Handshaking<'a, T>
pub fn hyperdriver::stream::tls::Handshaking<'a, T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'a, T> core::future::future::Future for hyperdriver::stream::tls::Handshaking<'a, T> where T: hyperdriver::stream::tls::TlsHandshakeStream + core::marker::Sized
pub type hyperdriver::stream::tls::Handshaking<'a, T>::Output = core::result::Result<(), std::io::error::Error>
pub fn hyperdriver::stream::tls::Handshaking<'a, T>::poll(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<Self::Output>
impl<'pin, 'a, T: core::marker::Sized> core::marker::Unpin for hyperdriver::stream::tls::Handshaking<'a, T> where __Handshaking<'pin, 'a, T>: core::marker::Unpin
impl<'a, T> core::marker::Freeze for hyperdriver::stream::tls::Handshaking<'a, T> where T: core::marker::Sized
impl<'a, T> core::marker::Send for hyperdriver::stream::tls::Handshaking<'a, T> where T: core::marker::Send + core::marker::Sized
impl<'a, T> core::marker::Sync for hyperdriver::stream::tls::Handshaking<'a, T> where T: core::marker::Sync + core::marker::Sized
impl<'a, T> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::stream::tls::Handshaking<'a, T> where T: core::panic::unwind_safe::RefUnwindSafe + core::marker::Sized
impl<'a, T> !core::panic::unwind_safe::UnwindSafe for hyperdriver::stream::tls::Handshaking<'a, T>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::stream::tls::Handshaking<'a, T> where B: http_body::Body
impl<F, T, E> futures_core::future::TryFuture for hyperdriver::stream::tls::Handshaking<'a, T> where F: core::future::future::Future<Output = core::result::Result<T, E>> + core::marker::Sized
pub type hyperdriver::stream::tls::Handshaking<'a, T>::Error = E
pub type hyperdriver::stream::tls::Handshaking<'a, T>::Ok = T
pub fn hyperdriver::stream::tls::Handshaking<'a, T>::try_poll(self: core::pin::Pin<&mut F>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<<F as core::future::future::Future>::Output>
impl<F> core::future::into_future::IntoFuture for hyperdriver::stream::tls::Handshaking<'a, T> where F: core::future::future::Future
pub type hyperdriver::stream::tls::Handshaking<'a, T>::IntoFuture = F
pub type hyperdriver::stream::tls::Handshaking<'a, T>::Output = <F as core::future::future::Future>::Output
pub fn hyperdriver::stream::tls::Handshaking<'a, T>::into_future(self) -> <F as core::future::into_future::IntoFuture>::IntoFuture
impl<Fut> futures_util::future::try_future::TryFutureExt for hyperdriver::stream::tls::Handshaking<'a, T> where Fut: futures_core::future::TryFuture + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::stream::tls::Handshaking<'a, T> where U: core::convert::From<T>
pub fn hyperdriver::stream::tls::Handshaking<'a, T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::stream::tls::Handshaking<'a, T> where U: core::convert::Into<T>
pub type hyperdriver::stream::tls::Handshaking<'a, T>::Error = core::convert::Infallible
pub fn hyperdriver::stream::tls::Handshaking<'a, T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::stream::tls::Handshaking<'a, T> where U: core::convert::TryFrom<T>
pub type hyperdriver::stream::tls::Handshaking<'a, T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::stream::tls::Handshaking<'a, T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::stream::tls::Handshaking<'a, T> where T: 'static + core::marker::Sized
pub fn hyperdriver::stream::tls::Handshaking<'a, T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::stream::tls::Handshaking<'a, T> where T: core::marker::Sized
pub fn hyperdriver::stream::tls::Handshaking<'a, T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::stream::tls::Handshaking<'a, T> where T: core::marker::Sized
pub fn hyperdriver::stream::tls::Handshaking<'a, T>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::stream::tls::Handshaking<'a, T>
pub fn hyperdriver::stream::tls::Handshaking<'a, T>::from(t: T) -> T
impl<T> futures_util::future::future::FutureExt for hyperdriver::stream::tls::Handshaking<'a, T> where T: core::future::future::Future + core::marker::Sized
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::stream::tls::Handshaking<'a, T> where T: core::marker::Sized
pub fn hyperdriver::stream::tls::Handshaking<'a, T>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::stream::tls::Handshaking<'a, T>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::stream::tls::Handshaking<'a, T>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::stream::tls::Handshaking<'a, T>
pub struct hyperdriver::stream::tls::TlsConnectionInfo
pub hyperdriver::stream::tls::TlsConnectionInfo::alpn: core::option::Option<hyperdriver::info::Protocol>
pub hyperdriver::stream::tls::TlsConnectionInfo::server_name: core::option::Option<alloc::string::String>
pub hyperdriver::stream::tls::TlsConnectionInfo::validated_server_name: bool
impl core::clone::Clone for hyperdriver::info::tls::TlsConnectionInfo
pub fn hyperdriver::info::tls::TlsConnectionInfo::clone(&self) -> hyperdriver::info::tls::TlsConnectionInfo
impl core::cmp::Eq for hyperdriver::info::tls::TlsConnectionInfo
impl core::cmp::PartialEq for hyperdriver::info::tls::TlsConnectionInfo
pub fn hyperdriver::info::tls::TlsConnectionInfo::eq(&self, other: &hyperdriver::info::tls::TlsConnectionInfo) -> bool
impl core::default::Default for hyperdriver::info::tls::TlsConnectionInfo
pub fn hyperdriver::info::tls::TlsConnectionInfo::default() -> hyperdriver::info::tls::TlsConnectionInfo
impl core::fmt::Debug for hyperdriver::info::tls::TlsConnectionInfo
pub fn hyperdriver::info::tls::TlsConnectionInfo::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::StructuralPartialEq for hyperdriver::info::tls::TlsConnectionInfo
impl core::marker::Freeze for hyperdriver::info::tls::TlsConnectionInfo
impl core::marker::Send for hyperdriver::info::tls::TlsConnectionInfo
impl core::marker::Sync for hyperdriver::info::tls::TlsConnectionInfo
impl core::marker::Unpin for hyperdriver::info::tls::TlsConnectionInfo
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::info::tls::TlsConnectionInfo
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::info::tls::TlsConnectionInfo
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::info::tls::TlsConnectionInfo where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::info::tls::TlsConnectionInfo where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::info::tls::TlsConnectionInfo where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::info::tls::TlsConnectionInfo where U: core::convert::From<T>
pub fn hyperdriver::info::tls::TlsConnectionInfo::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::info::tls::TlsConnectionInfo where U: core::convert::Into<T>
pub type hyperdriver::info::tls::TlsConnectionInfo::Error = core::convert::Infallible
pub fn hyperdriver::info::tls::TlsConnectionInfo::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::info::tls::TlsConnectionInfo where U: core::convert::TryFrom<T>
pub type hyperdriver::info::tls::TlsConnectionInfo::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::info::tls::TlsConnectionInfo::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::info::tls::TlsConnectionInfo where T: core::clone::Clone
pub type hyperdriver::info::tls::TlsConnectionInfo::Owned = T
pub fn hyperdriver::info::tls::TlsConnectionInfo::clone_into(&self, target: &mut T)
pub fn hyperdriver::info::tls::TlsConnectionInfo::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::info::tls::TlsConnectionInfo where T: core::clone::Clone
pub fn hyperdriver::info::tls::TlsConnectionInfo::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::info::tls::TlsConnectionInfo where T: 'static + core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::info::tls::TlsConnectionInfo where T: core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::info::tls::TlsConnectionInfo where T: core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::info::tls::TlsConnectionInfo where T: core::clone::Clone
pub unsafe fn hyperdriver::info::tls::TlsConnectionInfo::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::info::tls::TlsConnectionInfo
pub fn hyperdriver::info::tls::TlsConnectionInfo::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::info::tls::TlsConnectionInfo where T: core::marker::Sized
pub fn hyperdriver::info::tls::TlsConnectionInfo::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::info::tls::TlsConnectionInfo::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::info::tls::TlsConnectionInfo
impl<T> tracing::instrument::WithSubscriber for hyperdriver::info::tls::TlsConnectionInfo
pub struct hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>
impl<'pin, 's, S> core::marker::Unpin for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where __TlsHandshakeFuture<'pin, 's, S>: core::marker::Unpin
impl<'s, S: core::fmt::Debug> core::fmt::Debug for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>
pub fn hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'s, S> core::future::future::Future for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where S: hyperdriver::stream::tls::TlsHandshakeStream
pub type hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::Output = core::result::Result<(), std::io::error::Error>
pub fn hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::poll(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<Self::Output>
impl<'s, S> core::marker::Freeze for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>
impl<'s, S> core::marker::Send for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where S: core::marker::Send
impl<'s, S> core::marker::Sync for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where S: core::marker::Sync
impl<'s, S> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where S: core::panic::unwind_safe::RefUnwindSafe
impl<'s, S> !core::panic::unwind_safe::UnwindSafe for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where B: http_body::Body
impl<F, T, E> futures_core::future::TryFuture for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where F: core::future::future::Future<Output = core::result::Result<T, E>> + core::marker::Sized
pub type hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::Error = E
pub type hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::Ok = T
pub fn hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::try_poll(self: core::pin::Pin<&mut F>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<<F as core::future::future::Future>::Output>
impl<F> core::future::into_future::IntoFuture for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where F: core::future::future::Future
pub type hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::IntoFuture = F
pub type hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::Output = <F as core::future::future::Future>::Output
pub fn hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::into_future(self) -> <F as core::future::into_future::IntoFuture>::IntoFuture
impl<Fut> futures_util::future::try_future::TryFutureExt for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where Fut: futures_core::future::TryFuture + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where U: core::convert::From<T>
pub fn hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where U: core::convert::Into<T>
pub type hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::Error = core::convert::Infallible
pub fn hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where U: core::convert::TryFrom<T>
pub type hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where T: 'static + core::marker::Sized
pub fn hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where T: core::marker::Sized
pub fn hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where T: core::marker::Sized
pub fn hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>
pub fn hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::from(t: T) -> T
impl<T> futures_util::future::future::FutureExt for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where T: core::future::future::Future + core::marker::Sized
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S> where T: core::marker::Sized
pub fn hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::stream::tls::TlsHandshakeFuture<'s, S>
pub trait hyperdriver::stream::tls::TlsHandshakeExt: hyperdriver::stream::tls::TlsHandshakeStream
pub fn hyperdriver::stream::tls::TlsHandshakeExt::handshake(&mut self) -> hyperdriver::stream::tls::TlsHandshakeFuture<'_, Self> where Self: core::marker::Sized
impl<T> hyperdriver::stream::tls::TlsHandshakeExt for T where T: hyperdriver::stream::tls::TlsHandshakeStream
pub trait hyperdriver::stream::tls::TlsHandshakeStream
pub fn hyperdriver::stream::tls::TlsHandshakeStream::finish_handshake(&mut self) -> hyperdriver::stream::tls::Handshaking<'_, Self>
pub fn hyperdriver::stream::tls::TlsHandshakeStream::poll_handshake(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
impl<IO> hyperdriver::stream::tls::TlsHandshakeStream for hyperdriver::client::conn::stream::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send + core::marker::Unpin + core::clone::Clone
pub fn hyperdriver::client::conn::stream::Stream<IO>::poll_handshake(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
impl<IO> hyperdriver::stream::tls::TlsHandshakeStream for hyperdriver::client::conn::stream::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send + core::marker::Unpin
pub fn hyperdriver::client::conn::stream::TlsStream<IO>::poll_handshake(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
impl<IO> hyperdriver::stream::tls::TlsHandshakeStream for hyperdriver::client::conn::stream::mock::MockTls<IO> where IO: hyperdriver::stream::tls::TlsHandshakeStream
pub fn hyperdriver::client::conn::stream::mock::MockTls<IO>::poll_handshake(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
impl<IO> hyperdriver::stream::tls::TlsHandshakeStream for hyperdriver::server::conn::Stream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Send + core::marker::Unpin
pub fn hyperdriver::server::conn::Stream<IO>::poll_handshake(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
impl<IO> hyperdriver::stream::tls::TlsHandshakeStream for hyperdriver::server::conn::tls::TlsStream<IO> where IO: hyperdriver::info::HasConnectionInfo + tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin, <IO as hyperdriver::info::HasConnectionInfo>::Addr: core::marker::Unpin
pub fn hyperdriver::server::conn::tls::TlsStream<IO>::poll_handshake(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
impl<Tls, NoTls> hyperdriver::stream::tls::TlsHandshakeStream for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where Tls: hyperdriver::stream::tls::TlsHandshakeStream + core::marker::Unpin, NoTls: tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::poll_handshake(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub mod hyperdriver::stream::unix
pub use hyperdriver::stream::unix::UnixListener
pub struct hyperdriver::stream::unix::UnixAddr
impl hyperdriver::stream::unix::UnixAddr
pub fn hyperdriver::stream::unix::UnixAddr::from_pathbuf(path: camino::Utf8PathBuf) -> Self
pub fn hyperdriver::stream::unix::UnixAddr::is_named(&self) -> bool
pub fn hyperdriver::stream::unix::UnixAddr::path(&self) -> core::option::Option<&camino::Utf8Path>
pub fn hyperdriver::stream::unix::UnixAddr::unnamed() -> Self
impl core::clone::Clone for hyperdriver::stream::unix::UnixAddr
pub fn hyperdriver::stream::unix::UnixAddr::clone(&self) -> hyperdriver::stream::unix::UnixAddr
impl core::cmp::Eq for hyperdriver::stream::unix::UnixAddr
impl core::cmp::PartialEq for hyperdriver::stream::unix::UnixAddr
pub fn hyperdriver::stream::unix::UnixAddr::eq(&self, other: &hyperdriver::stream::unix::UnixAddr) -> bool
impl core::convert::From<hyperdriver::stream::unix::UnixAddr> for hyperdriver::info::BraidAddr
pub fn hyperdriver::info::BraidAddr::from(addr: hyperdriver::stream::unix::UnixAddr) -> Self
impl core::convert::TryFrom<std::os::unix::net::addr::SocketAddr> for hyperdriver::stream::unix::UnixAddr
pub type hyperdriver::stream::unix::UnixAddr::Error = std::io::error::Error
pub fn hyperdriver::stream::unix::UnixAddr::try_from(addr: std::os::unix::net::addr::SocketAddr) -> core::result::Result<Self, Self::Error>
impl core::convert::TryFrom<tokio::net::unix::socketaddr::SocketAddr> for hyperdriver::stream::unix::UnixAddr
pub type hyperdriver::stream::unix::UnixAddr::Error = std::io::error::Error
pub fn hyperdriver::stream::unix::UnixAddr::try_from(addr: tokio::net::unix::socketaddr::SocketAddr) -> core::result::Result<Self, Self::Error>
impl core::default::Default for hyperdriver::stream::unix::UnixAddr
pub fn hyperdriver::stream::unix::UnixAddr::default() -> hyperdriver::stream::unix::UnixAddr
impl core::fmt::Debug for hyperdriver::stream::unix::UnixAddr
pub fn hyperdriver::stream::unix::UnixAddr::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for hyperdriver::stream::unix::UnixAddr
pub fn hyperdriver::stream::unix::UnixAddr::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for hyperdriver::stream::unix::UnixAddr
pub fn hyperdriver::stream::unix::UnixAddr::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::StructuralPartialEq for hyperdriver::stream::unix::UnixAddr
impl core::marker::Freeze for hyperdriver::stream::unix::UnixAddr
impl core::marker::Send for hyperdriver::stream::unix::UnixAddr
impl core::marker::Sync for hyperdriver::stream::unix::UnixAddr
impl core::marker::Unpin for hyperdriver::stream::unix::UnixAddr
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::stream::unix::UnixAddr
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::stream::unix::UnixAddr
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::stream::unix::UnixAddr where B: http_body::Body
impl<Q, K> equivalent::Equivalent<K> for hyperdriver::stream::unix::UnixAddr where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::stream::unix::UnixAddr::equivalent(&self, key: &K) -> bool
impl<Q, K> hashbrown::Equivalent<K> for hyperdriver::stream::unix::UnixAddr where Q: core::cmp::Eq + core::marker::Sized, K: core::borrow::Borrow<Q> + core::marker::Sized
pub fn hyperdriver::stream::unix::UnixAddr::equivalent(&self, key: &K) -> bool
impl<T, U> core::convert::Into<U> for hyperdriver::stream::unix::UnixAddr where U: core::convert::From<T>
pub fn hyperdriver::stream::unix::UnixAddr::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::stream::unix::UnixAddr where U: core::convert::Into<T>
pub type hyperdriver::stream::unix::UnixAddr::Error = core::convert::Infallible
pub fn hyperdriver::stream::unix::UnixAddr::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::stream::unix::UnixAddr where U: core::convert::TryFrom<T>
pub type hyperdriver::stream::unix::UnixAddr::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::stream::unix::UnixAddr::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::stream::unix::UnixAddr where T: core::clone::Clone
pub type hyperdriver::stream::unix::UnixAddr::Owned = T
pub fn hyperdriver::stream::unix::UnixAddr::clone_into(&self, target: &mut T)
pub fn hyperdriver::stream::unix::UnixAddr::to_owned(&self) -> T
impl<T> alloc::string::ToString for hyperdriver::stream::unix::UnixAddr where T: core::fmt::Display + core::marker::Sized
pub fn hyperdriver::stream::unix::UnixAddr::to_string(&self) -> alloc::string::String
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::stream::unix::UnixAddr where T: core::clone::Clone
pub fn hyperdriver::stream::unix::UnixAddr::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::stream::unix::UnixAddr where T: 'static + core::marker::Sized
pub fn hyperdriver::stream::unix::UnixAddr::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::stream::unix::UnixAddr where T: core::marker::Sized
pub fn hyperdriver::stream::unix::UnixAddr::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::stream::unix::UnixAddr where T: core::marker::Sized
pub fn hyperdriver::stream::unix::UnixAddr::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::stream::unix::UnixAddr where T: core::clone::Clone
pub unsafe fn hyperdriver::stream::unix::UnixAddr::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::stream::unix::UnixAddr
pub fn hyperdriver::stream::unix::UnixAddr::from(t: T) -> T
impl<T> iri_string::format::ToStringFallible for hyperdriver::stream::unix::UnixAddr where T: core::fmt::Display
pub fn hyperdriver::stream::unix::UnixAddr::try_to_string(&self) -> core::result::Result<alloc::string::String, alloc::collections::TryReserveError>
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::stream::unix::UnixAddr where T: core::marker::Sized
pub fn hyperdriver::stream::unix::UnixAddr::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::stream::unix::UnixAddr::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::stream::unix::UnixAddr
impl<T> tracing::instrument::WithSubscriber for hyperdriver::stream::unix::UnixAddr
pub struct hyperdriver::stream::unix::UnixStream
impl hyperdriver::stream::unix::UnixStream
pub async fn hyperdriver::stream::unix::UnixStream::connect<P: core::convert::AsRef<std::path::Path>>(path: P) -> std::io::error::Result<Self>
pub fn hyperdriver::stream::unix::UnixStream::into_inner(self) -> tokio::net::unix::stream::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::local_addr(&self) -> std::io::error::Result<hyperdriver::stream::unix::UnixAddr>
pub fn hyperdriver::stream::unix::UnixStream::new(inner: tokio::net::unix::stream::UnixStream, remote: core::option::Option<hyperdriver::stream::unix::UnixAddr>) -> Self
pub fn hyperdriver::stream::unix::UnixStream::pair() -> std::io::error::Result<(Self, Self)>
pub fn hyperdriver::stream::unix::UnixStream::peer_addr(&self) -> std::io::error::Result<hyperdriver::stream::unix::UnixAddr>
impl core::convert::From<hyperdriver::stream::unix::UnixStream> for hyperdriver::client::conn::stream::Stream
pub fn hyperdriver::client::conn::stream::Stream::from(stream: hyperdriver::stream::unix::UnixStream) -> Self
impl core::convert::From<hyperdriver::stream::unix::UnixStream> for hyperdriver::stream::Braid
pub fn hyperdriver::stream::Braid::from(stream: hyperdriver::stream::unix::UnixStream) -> Self
impl core::fmt::Debug for hyperdriver::stream::unix::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::deref::Deref for hyperdriver::stream::unix::UnixStream
pub type hyperdriver::stream::unix::UnixStream::Target = tokio::net::unix::stream::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::deref(&self) -> &Self::Target
impl core::ops::deref::DerefMut for hyperdriver::stream::unix::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::deref_mut(&mut self) -> &mut Self::Target
impl hyperdriver::client::pool::PoolableStream for hyperdriver::stream::unix::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::can_share(&self) -> bool
impl hyperdriver::info::HasConnectionInfo for hyperdriver::stream::unix::UnixStream
pub type hyperdriver::stream::unix::UnixStream::Addr = hyperdriver::stream::unix::UnixAddr
pub fn hyperdriver::stream::unix::UnixStream::info(&self) -> hyperdriver::info::ConnectionInfo<Self::Addr>
impl tokio::io::async_read::AsyncRead for hyperdriver::stream::unix::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &mut tokio::io::read_buf::ReadBuf<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
impl tokio::io::async_write::AsyncWrite for hyperdriver::stream::unix::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::is_write_vectored(&self) -> bool
pub fn hyperdriver::stream::unix::UnixStream::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::unix::UnixStream::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::unix::UnixStream::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
pub fn hyperdriver::stream::unix::UnixStream::poll_write_vectored(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, bufs: &[std::io::IoSlice<'_>]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
impl<'pin> core::marker::Unpin for hyperdriver::stream::unix::UnixStream where __UnixStream<'pin>: core::marker::Unpin
impl !core::marker::Freeze for hyperdriver::stream::unix::UnixStream
impl core::marker::Send for hyperdriver::stream::unix::UnixStream
impl core::marker::Sync for hyperdriver::stream::unix::UnixStream
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::stream::unix::UnixStream
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::stream::unix::UnixStream
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::stream::unix::UnixStream where B: http_body::Body
impl<R> tokio::io::util::async_read_ext::AsyncReadExt for hyperdriver::stream::unix::UnixStream where R: tokio::io::async_read::AsyncRead + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::stream::unix::UnixStream where U: core::convert::From<T>
pub fn hyperdriver::stream::unix::UnixStream::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::stream::unix::UnixStream where U: core::convert::Into<T>
pub type hyperdriver::stream::unix::UnixStream::Error = core::convert::Infallible
pub fn hyperdriver::stream::unix::UnixStream::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::stream::unix::UnixStream where U: core::convert::TryFrom<T>
pub type hyperdriver::stream::unix::UnixStream::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::stream::unix::UnixStream::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::stream::unix::UnixStream where T: 'static + core::marker::Sized
pub fn hyperdriver::stream::unix::UnixStream::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::stream::unix::UnixStream where T: core::marker::Sized
pub fn hyperdriver::stream::unix::UnixStream::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::stream::unix::UnixStream where T: core::marker::Sized
pub fn hyperdriver::stream::unix::UnixStream::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::stream::unix::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::stream::unix::UnixStream where T: core::marker::Sized
pub fn hyperdriver::stream::unix::UnixStream::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::stream::unix::UnixStream::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::stream::unix::UnixStream
impl<T> tracing::instrument::WithSubscriber for hyperdriver::stream::unix::UnixStream
impl<W> tokio::io::util::async_write_ext::AsyncWriteExt for hyperdriver::stream::unix::UnixStream where W: tokio::io::async_write::AsyncWrite + core::marker::Sized
pub enum hyperdriver::stream::TlsBraid<Tls, NoTls>
pub hyperdriver::stream::TlsBraid::NoTls(NoTls)
pub hyperdriver::stream::TlsBraid::Tls(Tls)
impl<'pin, Tls, NoTls> core::marker::Unpin for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where __TlsBraid<'pin, Tls, NoTls>: core::marker::Unpin
impl<Tls, NoTls> core::convert::From<NoTls> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::from(stream: NoTls) -> Self
impl<Tls, NoTls> hyperdriver::client::pool::PoolableStream for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where Tls: hyperdriver::stream::tls::TlsHandshakeStream + core::marker::Send + core::marker::Unpin + 'static, NoTls: tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Send + core::marker::Unpin + 'static
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::can_share(&self) -> bool
impl<Tls, NoTls> hyperdriver::stream::tls::TlsHandshakeStream for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where Tls: hyperdriver::stream::tls::TlsHandshakeStream + core::marker::Unpin, NoTls: tokio::io::async_read::AsyncRead + tokio::io::async_write::AsyncWrite + core::marker::Unpin
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::poll_handshake(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
impl<Tls, NoTls> tokio::io::async_read::AsyncRead for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where Tls: tokio::io::async_read::AsyncRead, NoTls: tokio::io::async_read::AsyncRead
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &mut tokio::io::read_buf::ReadBuf<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
impl<Tls, NoTls> tokio::io::async_write::AsyncWrite for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where Tls: tokio::io::async_write::AsyncWrite, NoTls: tokio::io::async_write::AsyncWrite
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
impl<Tls: core::fmt::Debug, NoTls: core::fmt::Debug> core::fmt::Debug for hyperdriver::stream::tls::TlsBraid<Tls, NoTls>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<Tls, NoTls> core::marker::Freeze for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where NoTls: core::marker::Freeze, Tls: core::marker::Freeze
impl<Tls, NoTls> core::marker::Send for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where NoTls: core::marker::Send, Tls: core::marker::Send
impl<Tls, NoTls> core::marker::Sync for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where NoTls: core::marker::Sync, Tls: core::marker::Sync
impl<Tls, NoTls> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where NoTls: core::panic::unwind_safe::RefUnwindSafe, Tls: core::panic::unwind_safe::RefUnwindSafe
impl<Tls, NoTls> core::panic::unwind_safe::UnwindSafe for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where NoTls: core::panic::unwind_safe::UnwindSafe, Tls: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where B: http_body::Body
impl<R> tokio::io::util::async_read_ext::AsyncReadExt for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where R: tokio::io::async_read::AsyncRead + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where U: core::convert::From<T>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where U: core::convert::Into<T>
pub type hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::Error = core::convert::Infallible
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where U: core::convert::TryFrom<T>
pub type hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where T: 'static + core::marker::Sized
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where T: core::marker::Sized
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where T: core::marker::Sized
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::from(t: T) -> T
impl<T> core::convert::From<never> for hyperdriver::stream::tls::TlsBraid<Tls, NoTls>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::from(t: never) -> T
impl<T> hyperdriver::stream::tls::TlsHandshakeExt for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where T: hyperdriver::stream::tls::TlsHandshakeStream
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where T: core::marker::Sized
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::stream::tls::TlsBraid<Tls, NoTls>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::stream::tls::TlsBraid<Tls, NoTls>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::stream::tls::TlsBraid<Tls, NoTls>
impl<W> tokio::io::util::async_write_ext::AsyncWriteExt for hyperdriver::stream::tls::TlsBraid<Tls, NoTls> where W: tokio::io::async_write::AsyncWrite + core::marker::Sized
pub struct hyperdriver::stream::Braid
impl core::convert::From<hyperdriver::stream::Braid> for hyperdriver::server::conn::Stream
pub fn hyperdriver::server::conn::Stream::from(stream: hyperdriver::stream::Braid) -> Self
impl core::convert::From<hyperdriver::stream::duplex::DuplexStream> for hyperdriver::stream::Braid
pub fn hyperdriver::stream::Braid::from(stream: hyperdriver::stream::duplex::DuplexStream) -> Self
impl core::convert::From<hyperdriver::stream::tcp::TcpStream> for hyperdriver::stream::Braid
pub fn hyperdriver::stream::Braid::from(stream: hyperdriver::stream::tcp::TcpStream) -> Self
impl core::convert::From<hyperdriver::stream::unix::UnixStream> for hyperdriver::stream::Braid
pub fn hyperdriver::stream::Braid::from(stream: hyperdriver::stream::unix::UnixStream) -> Self
impl core::fmt::Debug for hyperdriver::stream::Braid
pub fn hyperdriver::stream::Braid::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl hyperdriver::info::HasConnectionInfo for hyperdriver::stream::Braid
pub type hyperdriver::stream::Braid::Addr = hyperdriver::info::BraidAddr
pub fn hyperdriver::stream::Braid::info(&self) -> hyperdriver::info::ConnectionInfo<hyperdriver::info::BraidAddr>
impl tokio::io::async_read::AsyncRead for hyperdriver::stream::Braid
pub fn hyperdriver::stream::Braid::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &mut tokio::io::read_buf::ReadBuf<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
impl tokio::io::async_write::AsyncWrite for hyperdriver::stream::Braid
pub fn hyperdriver::stream::Braid::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::Braid::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::Braid::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
impl<'pin> core::marker::Unpin for hyperdriver::stream::Braid where __Braid<'pin>: core::marker::Unpin
impl !core::marker::Freeze for hyperdriver::stream::Braid
impl core::marker::Send for hyperdriver::stream::Braid
impl core::marker::Sync for hyperdriver::stream::Braid
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::stream::Braid
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::stream::Braid
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::stream::Braid where B: http_body::Body
impl<R> tokio::io::util::async_read_ext::AsyncReadExt for hyperdriver::stream::Braid where R: tokio::io::async_read::AsyncRead + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::stream::Braid where U: core::convert::From<T>
pub fn hyperdriver::stream::Braid::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::stream::Braid where U: core::convert::Into<T>
pub type hyperdriver::stream::Braid::Error = core::convert::Infallible
pub fn hyperdriver::stream::Braid::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::stream::Braid where U: core::convert::TryFrom<T>
pub type hyperdriver::stream::Braid::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::stream::Braid::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::stream::Braid where T: 'static + core::marker::Sized
pub fn hyperdriver::stream::Braid::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::stream::Braid where T: core::marker::Sized
pub fn hyperdriver::stream::Braid::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::stream::Braid where T: core::marker::Sized
pub fn hyperdriver::stream::Braid::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::stream::Braid
pub fn hyperdriver::stream::Braid::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::stream::Braid where T: core::marker::Sized
pub fn hyperdriver::stream::Braid::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::stream::Braid::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::stream::Braid
impl<T> tracing::instrument::WithSubscriber for hyperdriver::stream::Braid
impl<W> tokio::io::util::async_write_ext::AsyncWriteExt for hyperdriver::stream::Braid where W: tokio::io::async_write::AsyncWrite + core::marker::Sized
pub struct hyperdriver::stream::TcpStream
impl hyperdriver::stream::tcp::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::client(inner: tokio::net::tcp::stream::TcpStream) -> Self
pub async fn hyperdriver::stream::tcp::TcpStream::connect<A: tokio::net::addr::ToSocketAddrs>(addr: A) -> std::io::error::Result<Self>
pub fn hyperdriver::stream::tcp::TcpStream::into_inner(self) -> tokio::net::tcp::stream::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::local_addr(&self) -> std::io::error::Result<core::net::socket_addr::SocketAddr>
pub fn hyperdriver::stream::tcp::TcpStream::peer_addr(&self) -> std::io::error::Result<core::net::socket_addr::SocketAddr>
pub fn hyperdriver::stream::tcp::TcpStream::server(inner: tokio::net::tcp::stream::TcpStream, remote: core::net::socket_addr::SocketAddr) -> Self
impl core::convert::From<hyperdriver::stream::tcp::TcpStream> for hyperdriver::client::conn::stream::Stream
pub fn hyperdriver::client::conn::stream::Stream::from(stream: hyperdriver::stream::tcp::TcpStream) -> Self
impl core::convert::From<hyperdriver::stream::tcp::TcpStream> for hyperdriver::stream::Braid
pub fn hyperdriver::stream::Braid::from(stream: hyperdriver::stream::tcp::TcpStream) -> Self
impl core::fmt::Debug for hyperdriver::stream::tcp::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::deref::Deref for hyperdriver::stream::tcp::TcpStream
pub type hyperdriver::stream::tcp::TcpStream::Target = tokio::net::tcp::stream::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::deref(&self) -> &Self::Target
impl core::ops::deref::DerefMut for hyperdriver::stream::tcp::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::deref_mut(&mut self) -> &mut Self::Target
impl hyperdriver::client::pool::PoolableStream for hyperdriver::stream::tcp::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::can_share(&self) -> bool
impl hyperdriver::info::HasConnectionInfo for hyperdriver::stream::tcp::TcpStream
pub type hyperdriver::stream::tcp::TcpStream::Addr = core::net::socket_addr::SocketAddr
pub fn hyperdriver::stream::tcp::TcpStream::info(&self) -> hyperdriver::info::ConnectionInfo<Self::Addr>
impl tokio::io::async_read::AsyncRead for hyperdriver::stream::tcp::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &mut tokio::io::read_buf::ReadBuf<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
impl tokio::io::async_write::AsyncWrite for hyperdriver::stream::tcp::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::is_write_vectored(&self) -> bool
pub fn hyperdriver::stream::tcp::TcpStream::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::tcp::TcpStream::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::tcp::TcpStream::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
pub fn hyperdriver::stream::tcp::TcpStream::poll_write_vectored(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, bufs: &[std::io::IoSlice<'_>]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
impl<'pin> core::marker::Unpin for hyperdriver::stream::tcp::TcpStream where __TcpStream<'pin>: core::marker::Unpin
impl !core::marker::Freeze for hyperdriver::stream::tcp::TcpStream
impl core::marker::Send for hyperdriver::stream::tcp::TcpStream
impl core::marker::Sync for hyperdriver::stream::tcp::TcpStream
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::stream::tcp::TcpStream
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::stream::tcp::TcpStream
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::stream::tcp::TcpStream where B: http_body::Body
impl<R> tokio::io::util::async_read_ext::AsyncReadExt for hyperdriver::stream::tcp::TcpStream where R: tokio::io::async_read::AsyncRead + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::stream::tcp::TcpStream where U: core::convert::From<T>
pub fn hyperdriver::stream::tcp::TcpStream::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::stream::tcp::TcpStream where U: core::convert::Into<T>
pub type hyperdriver::stream::tcp::TcpStream::Error = core::convert::Infallible
pub fn hyperdriver::stream::tcp::TcpStream::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::stream::tcp::TcpStream where U: core::convert::TryFrom<T>
pub type hyperdriver::stream::tcp::TcpStream::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::stream::tcp::TcpStream::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::stream::tcp::TcpStream where T: 'static + core::marker::Sized
pub fn hyperdriver::stream::tcp::TcpStream::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::stream::tcp::TcpStream where T: core::marker::Sized
pub fn hyperdriver::stream::tcp::TcpStream::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::stream::tcp::TcpStream where T: core::marker::Sized
pub fn hyperdriver::stream::tcp::TcpStream::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::stream::tcp::TcpStream
pub fn hyperdriver::stream::tcp::TcpStream::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::stream::tcp::TcpStream where T: core::marker::Sized
pub fn hyperdriver::stream::tcp::TcpStream::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::stream::tcp::TcpStream::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::stream::tcp::TcpStream
impl<T> tracing::instrument::WithSubscriber for hyperdriver::stream::tcp::TcpStream
impl<W> tokio::io::util::async_write_ext::AsyncWriteExt for hyperdriver::stream::tcp::TcpStream where W: tokio::io::async_write::AsyncWrite + core::marker::Sized
pub struct hyperdriver::stream::UnixStream
impl hyperdriver::stream::unix::UnixStream
pub async fn hyperdriver::stream::unix::UnixStream::connect<P: core::convert::AsRef<std::path::Path>>(path: P) -> std::io::error::Result<Self>
pub fn hyperdriver::stream::unix::UnixStream::into_inner(self) -> tokio::net::unix::stream::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::local_addr(&self) -> std::io::error::Result<hyperdriver::stream::unix::UnixAddr>
pub fn hyperdriver::stream::unix::UnixStream::new(inner: tokio::net::unix::stream::UnixStream, remote: core::option::Option<hyperdriver::stream::unix::UnixAddr>) -> Self
pub fn hyperdriver::stream::unix::UnixStream::pair() -> std::io::error::Result<(Self, Self)>
pub fn hyperdriver::stream::unix::UnixStream::peer_addr(&self) -> std::io::error::Result<hyperdriver::stream::unix::UnixAddr>
impl core::convert::From<hyperdriver::stream::unix::UnixStream> for hyperdriver::client::conn::stream::Stream
pub fn hyperdriver::client::conn::stream::Stream::from(stream: hyperdriver::stream::unix::UnixStream) -> Self
impl core::convert::From<hyperdriver::stream::unix::UnixStream> for hyperdriver::stream::Braid
pub fn hyperdriver::stream::Braid::from(stream: hyperdriver::stream::unix::UnixStream) -> Self
impl core::fmt::Debug for hyperdriver::stream::unix::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::deref::Deref for hyperdriver::stream::unix::UnixStream
pub type hyperdriver::stream::unix::UnixStream::Target = tokio::net::unix::stream::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::deref(&self) -> &Self::Target
impl core::ops::deref::DerefMut for hyperdriver::stream::unix::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::deref_mut(&mut self) -> &mut Self::Target
impl hyperdriver::client::pool::PoolableStream for hyperdriver::stream::unix::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::can_share(&self) -> bool
impl hyperdriver::info::HasConnectionInfo for hyperdriver::stream::unix::UnixStream
pub type hyperdriver::stream::unix::UnixStream::Addr = hyperdriver::stream::unix::UnixAddr
pub fn hyperdriver::stream::unix::UnixStream::info(&self) -> hyperdriver::info::ConnectionInfo<Self::Addr>
impl tokio::io::async_read::AsyncRead for hyperdriver::stream::unix::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::poll_read(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &mut tokio::io::read_buf::ReadBuf<'_>) -> core::task::poll::Poll<std::io::error::Result<()>>
impl tokio::io::async_write::AsyncWrite for hyperdriver::stream::unix::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::is_write_vectored(&self) -> bool
pub fn hyperdriver::stream::unix::UnixStream::poll_flush(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::unix::UnixStream::poll_shutdown(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), std::io::error::Error>>
pub fn hyperdriver::stream::unix::UnixStream::poll_write(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, buf: &[u8]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
pub fn hyperdriver::stream::unix::UnixStream::poll_write_vectored(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>, bufs: &[std::io::IoSlice<'_>]) -> core::task::poll::Poll<core::result::Result<usize, std::io::error::Error>>
impl<'pin> core::marker::Unpin for hyperdriver::stream::unix::UnixStream where __UnixStream<'pin>: core::marker::Unpin
impl !core::marker::Freeze for hyperdriver::stream::unix::UnixStream
impl core::marker::Send for hyperdriver::stream::unix::UnixStream
impl core::marker::Sync for hyperdriver::stream::unix::UnixStream
impl core::panic::unwind_safe::RefUnwindSafe for hyperdriver::stream::unix::UnixStream
impl core::panic::unwind_safe::UnwindSafe for hyperdriver::stream::unix::UnixStream
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::stream::unix::UnixStream where B: http_body::Body
impl<R> tokio::io::util::async_read_ext::AsyncReadExt for hyperdriver::stream::unix::UnixStream where R: tokio::io::async_read::AsyncRead + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::stream::unix::UnixStream where U: core::convert::From<T>
pub fn hyperdriver::stream::unix::UnixStream::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::stream::unix::UnixStream where U: core::convert::Into<T>
pub type hyperdriver::stream::unix::UnixStream::Error = core::convert::Infallible
pub fn hyperdriver::stream::unix::UnixStream::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::stream::unix::UnixStream where U: core::convert::TryFrom<T>
pub type hyperdriver::stream::unix::UnixStream::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::stream::unix::UnixStream::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::stream::unix::UnixStream where T: 'static + core::marker::Sized
pub fn hyperdriver::stream::unix::UnixStream::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::stream::unix::UnixStream where T: core::marker::Sized
pub fn hyperdriver::stream::unix::UnixStream::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::stream::unix::UnixStream where T: core::marker::Sized
pub fn hyperdriver::stream::unix::UnixStream::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::stream::unix::UnixStream
pub fn hyperdriver::stream::unix::UnixStream::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::stream::unix::UnixStream where T: core::marker::Sized
pub fn hyperdriver::stream::unix::UnixStream::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::stream::unix::UnixStream::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::stream::unix::UnixStream
impl<T> tracing::instrument::WithSubscriber for hyperdriver::stream::unix::UnixStream
impl<W> tokio::io::util::async_write_ext::AsyncWriteExt for hyperdriver::stream::unix::UnixStream where W: tokio::io::async_write::AsyncWrite + core::marker::Sized
pub struct hyperdriver::Body
impl hyperdriver::body::Body
pub fn hyperdriver::body::Body::as_boxed(self) -> http_body_util::combinators::box_body::UnsyncBoxBody<bytes::bytes::Bytes, alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send + 'static)>>
pub fn hyperdriver::body::Body::empty() -> Self
pub fn hyperdriver::body::Body::full<D>(data: D) -> Self where D: core::convert::Into<bytes::bytes::Bytes>
pub fn hyperdriver::body::Body::try_clone(&self) -> core::option::Option<Self>
impl core::convert::From<&'static str> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(body: &'static str) -> Self
impl core::convert::From<alloc::string::String> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(body: alloc::string::String) -> Self
impl core::convert::From<alloc::vec::Vec<u8>> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(body: alloc::vec::Vec<u8>) -> Self
impl core::convert::From<axum_core::body::Body> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(body: axum_core::body::Body) -> Self
impl core::convert::From<bytes::bytes::Bytes> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(body: bytes::bytes::Bytes) -> Self
impl core::convert::From<http_body_util::empty::Empty<bytes::bytes::Bytes>> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(_body: http_body_util::empty::Empty<bytes::bytes::Bytes>) -> Self
impl core::convert::From<http_body_util::full::Full<bytes::bytes::Bytes>> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(body: http_body_util::full::Full<bytes::bytes::Bytes>) -> Self
impl core::convert::From<hyper::body::incoming::Incoming> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(body: hyper::body::incoming::Incoming) -> Self
impl core::convert::From<hyperdriver::body::Body> for axum_core::body::Body
pub fn axum_core::body::Body::from(body: hyperdriver::body::Body) -> Self
impl core::default::Default for hyperdriver::body::Body
pub fn hyperdriver::body::Body::default() -> Self
impl core::fmt::Debug for hyperdriver::body::Body
pub fn hyperdriver::body::Body::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl http_body::Body for hyperdriver::body::Body
pub type hyperdriver::body::Body::Data = bytes::bytes::Bytes
pub type hyperdriver::body::Body::Error = alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>
pub fn hyperdriver::body::Body::is_end_stream(&self) -> bool
pub fn hyperdriver::body::Body::poll_frame(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::option::Option<core::result::Result<http_body::frame::Frame<Self::Data>, Self::Error>>>
pub fn hyperdriver::body::Body::size_hint(&self) -> http_body::size_hint::SizeHint
impl hyperdriver::client::conn::connection::Connection<hyperdriver::body::Body> for hyperdriver::client::conn::protocol::mock::MockSender
pub type hyperdriver::client::conn::protocol::mock::MockSender::Error = hyperdriver::client::conn::protocol::mock::MockProtocolError
pub type hyperdriver::client::conn::protocol::mock::MockSender::Future = core::future::ready::Ready<core::result::Result<http::response::Response<hyperdriver::body::Body>, <hyperdriver::client::conn::protocol::mock::MockSender as hyperdriver::client::conn::connection::Connection<hyperdriver::body::Body>>::Error>>
pub type hyperdriver::client::conn::protocol::mock::MockSender::ResBody = hyperdriver::body::Body
pub fn hyperdriver::client::conn::protocol::mock::MockSender::poll_ready(&mut self, _cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
pub fn hyperdriver::client::conn::protocol::mock::MockSender::send_request(&mut self, request: http::request::Request<hyperdriver::body::Body>) -> Self::Future
pub fn hyperdriver::client::conn::protocol::mock::MockSender::version(&self) -> http::version::Version
impl<'pin> core::marker::Unpin for hyperdriver::body::Body where __Body<'pin>: core::marker::Unpin
impl !core::marker::Freeze for hyperdriver::body::Body
impl core::marker::Send for hyperdriver::body::Body
impl !core::marker::Sync for hyperdriver::body::Body
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::body::Body
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::body::Body
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::body::Body where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::body::Body where U: core::convert::From<T>
pub fn hyperdriver::body::Body::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::body::Body where U: core::convert::Into<T>
pub type hyperdriver::body::Body::Error = core::convert::Infallible
pub fn hyperdriver::body::Body::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::body::Body where U: core::convert::TryFrom<T>
pub type hyperdriver::body::Body::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::body::Body::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::body::Body where T: 'static + core::marker::Sized
pub fn hyperdriver::body::Body::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::body::Body where T: core::marker::Sized
pub fn hyperdriver::body::Body::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::body::Body where T: core::marker::Sized
pub fn hyperdriver::body::Body::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::body::Body
pub fn hyperdriver::body::Body::from(t: T) -> T
impl<T> http_body_util::BodyExt for hyperdriver::body::Body where T: http_body::Body + core::marker::Sized
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::body::Body where T: core::marker::Sized
pub fn hyperdriver::body::Body::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::body::Body::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::body::Body
impl<T> tracing::instrument::WithSubscriber for hyperdriver::body::Body
pub struct hyperdriver::Client
impl hyperdriver::client::Client
pub fn hyperdriver::client::Client::build_tcp_http() -> hyperdriver::client::Builder<hyperdriver::client::conn::transport::tcp::TcpTransportConfig, hyperdriver::client::conn::protocol::auto::HttpConnectionBuilder<hyperdriver::body::Body>>
pub fn hyperdriver::client::Client::builder() -> hyperdriver::client::Builder<(), ()>
pub fn hyperdriver::client::Client::into_inner(self) -> hyperdriver::client::SharedClientService<hyperdriver::body::Body, hyperdriver::body::Body>
pub fn hyperdriver::client::Client::new_from_service<S>(service: S) -> Self where S: core::convert::Into<hyperdriver::client::SharedClientService<hyperdriver::body::Body, hyperdriver::body::Body>>
pub fn hyperdriver::client::Client::new_tcp_http() -> Self
impl hyperdriver::client::Client
pub async fn hyperdriver::client::Client::get(&mut self, uri: http::uri::Uri) -> core::result::Result<http::response::Response<hyperdriver::body::Body>, alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>
pub fn hyperdriver::client::Client::request(&mut self, request: http::request::Request<hyperdriver::body::Body>) -> tower::util::oneshot::Oneshot<hyperdriver::client::SharedClientService<hyperdriver::body::Body, hyperdriver::body::Body>, http::request::Request<hyperdriver::body::Body>>
impl core::clone::Clone for hyperdriver::client::Client
pub fn hyperdriver::client::Client::clone(&self) -> hyperdriver::client::Client
impl core::default::Default for hyperdriver::client::Client
pub fn hyperdriver::client::Client::default() -> Self
impl core::fmt::Debug for hyperdriver::client::Client
pub fn hyperdriver::client::Client::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl tower_service::Service<http::request::Request<hyperdriver::body::Body>> for hyperdriver::client::Client
pub type hyperdriver::client::Client::Error = hyperdriver::client::Error
pub type hyperdriver::client::Client::Future = tower::util::oneshot::Oneshot<hyperdriver::service::SharedService<http::request::Request<hyperdriver::body::Body>, http::response::Response<hyperdriver::body::Body>, hyperdriver::client::Error>, http::request::Request<hyperdriver::body::Body>>
pub type hyperdriver::client::Client::Response = http::response::Response<hyperdriver::body::Body>
pub fn hyperdriver::client::Client::call(&mut self, request: http::request::Request<hyperdriver::body::Body>) -> Self::Future
pub fn hyperdriver::client::Client::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), Self::Error>>
impl core::marker::Freeze for hyperdriver::client::Client
impl core::marker::Send for hyperdriver::client::Client
impl core::marker::Sync for hyperdriver::client::Client
impl core::marker::Unpin for hyperdriver::client::Client
impl !core::panic::unwind_safe::RefUnwindSafe for hyperdriver::client::Client
impl !core::panic::unwind_safe::UnwindSafe for hyperdriver::client::Client
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::client::Client where B: http_body::Body
impl<S, R> axum::service_ext::ServiceExt<R> for hyperdriver::client::Client where S: tower_service::Service<R>
pub fn hyperdriver::client::Client::into_make_service(self) -> axum::routing::into_make_service::IntoMakeService<S>
pub fn hyperdriver::client::Client::into_make_service_with_connect_info<C>(self) -> axum::extract::connect_info::IntoMakeServiceWithConnectInfo<S, C>
impl<T, BIn, BOut> hyperdriver::service::HttpService<BIn> for hyperdriver::client::Client where T: tower_service::Service<http::request::Request<BIn>, Response = http::response::Response<BOut>>, BOut: http_body::Body, <T as tower_service::Service<http::request::Request<BIn>>>::Error: core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Sync + core::marker::Send)>>
pub type hyperdriver::client::Client::Error = <T as tower_service::Service<http::request::Request<BIn>>>::Error
pub type hyperdriver::client::Client::Future = <T as tower_service::Service<http::request::Request<BIn>>>::Future
pub type hyperdriver::client::Client::ResBody = BOut
pub fn hyperdriver::client::Client::call(&mut self, req: http::request::Request<BIn>) -> <T as hyperdriver::service::HttpService<BIn>>::Future
pub fn hyperdriver::client::Client::poll_ready(&mut self, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<core::result::Result<(), <T as hyperdriver::service::HttpService<BIn>>::Error>>
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::Client where T: tower_service::Service<Request> + core::marker::Sized
impl<T, Request> tower::util::ServiceExt<Request> for hyperdriver::client::Client where T: tower_service::Service<Request> + core::marker::Sized
impl<T, U> core::convert::Into<U> for hyperdriver::client::Client where U: core::convert::From<T>
pub fn hyperdriver::client::Client::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::client::Client where U: core::convert::Into<T>
pub type hyperdriver::client::Client::Error = core::convert::Infallible
pub fn hyperdriver::client::Client::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::client::Client where U: core::convert::TryFrom<T>
pub type hyperdriver::client::Client::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::client::Client::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for hyperdriver::client::Client where T: core::clone::Clone
pub type hyperdriver::client::Client::Owned = T
pub fn hyperdriver::client::Client::clone_into(&self, target: &mut T)
pub fn hyperdriver::client::Client::to_owned(&self) -> T
impl<T> axum_core::extract::from_ref::FromRef<T> for hyperdriver::client::Client where T: core::clone::Clone
pub fn hyperdriver::client::Client::from_ref(input: &T) -> T
impl<T> core::any::Any for hyperdriver::client::Client where T: 'static + core::marker::Sized
pub fn hyperdriver::client::Client::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::client::Client where T: core::marker::Sized
pub fn hyperdriver::client::Client::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::client::Client where T: core::marker::Sized
pub fn hyperdriver::client::Client::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for hyperdriver::client::Client where T: core::clone::Clone
pub unsafe fn hyperdriver::client::Client::clone_to_uninit(&self, dst: *mut T)
impl<T> core::convert::From<T> for hyperdriver::client::Client
pub fn hyperdriver::client::Client::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::client::Client where T: core::marker::Sized
pub fn hyperdriver::client::Client::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::client::Client::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::client::Client
impl<T> tracing::instrument::WithSubscriber for hyperdriver::client::Client
pub struct hyperdriver::Server<A, P, S, B, E>
impl hyperdriver::server::Server<(), (), (), (), ()>
pub fn hyperdriver::server::Server<(), (), (), (), ()>::builder<B>() -> hyperdriver::server::Server<NeedsAcceptor, NeedsProtocol, NeedsService, B, NeedsExecutor>
impl<A, P, B, E> hyperdriver::server::Server<A, P, NeedsService, B, E>
pub fn hyperdriver::server::Server<A, P, NeedsService, B, E>::with_make_service<S>(self, make_service: S) -> hyperdriver::server::Server<A, P, S, B, E>
pub fn hyperdriver::server::Server<A, P, NeedsService, B, E>::with_shared_service<S>(self, service: S) -> hyperdriver::server::Server<A, P, tower::make::make_service::shared::Shared<S>, B, E>
impl<A, P, S, B, E> hyperdriver::server::Server<A, P, S, B, E> where S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept
pub fn hyperdriver::server::Server<A, P, S, B, E>::with_connection_info(self) -> hyperdriver::server::Server<A, P, hyperdriver::server::conn::MakeServiceConnectionInfoService<S>, B, E>
pub fn hyperdriver::server::Server<A, P, S, B, E>::with_tls_connection_info(self) -> hyperdriver::server::Server<A, P, hyperdriver::server::conn::tls::info::TlsConnectionInfoService<S>, B, E>
impl<A, P, S, B, E> hyperdriver::server::Server<A, P, S, B, E>
pub fn hyperdriver::server::Server<A, P, S, B, E>::new(acceptor: A, protocol: P, make_service: S, executor: E) -> Self
pub fn hyperdriver::server::Server<A, P, S, B, E>::with_graceful_shutdown<F>(self, signal: F) -> hyperdriver::server::GracefulShutdown<A, P, S, B, E, F> where S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, P: hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef>::Service, <A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept + core::marker::Unpin, B: http_body::Body, F: core::future::future::Future<Output = ()> + core::marker::Send + 'static, E: hyperdriver::server::ServerExecutor<P, S, A, B>
impl<A, P, S, B, E> hyperdriver::server::Server<A, P, S, B, E>
pub fn hyperdriver::server::Server<A, P, S, B, E>::with_body<B2>(self) -> hyperdriver::server::Server<A, P, S, B2, E>
impl<A, P, S, B> hyperdriver::server::Server<A, P, S, B, NeedsExecutor>
pub fn hyperdriver::server::Server<A, P, S, B, NeedsExecutor>::with_executor<E>(self, executor: E) -> hyperdriver::server::Server<A, P, S, B, E>
pub fn hyperdriver::server::Server<A, P, S, B, NeedsExecutor>::with_tokio(self) -> hyperdriver::server::Server<A, P, S, B, hyperdriver::bridge::rt::TokioExecutor>
impl<A, S, B, E> hyperdriver::server::Server<A, NeedsProtocol, S, B, E>
pub fn hyperdriver::server::Server<A, NeedsProtocol, S, B, E>::with_auto_http(self) -> hyperdriver::server::Server<A, hyperdriver::server::conn::auto::Builder, S, B, E>
pub fn hyperdriver::server::Server<A, NeedsProtocol, S, B, E>::with_http1(self) -> hyperdriver::server::Server<A, hyper::server::conn::http1::Builder, S, B, E>
pub fn hyperdriver::server::Server<A, NeedsProtocol, S, B, E>::with_http2(self) -> hyperdriver::server::Server<A, hyper::server::conn::http2::Builder<hyperdriver::bridge::rt::TokioExecutor>, S, B, E>
pub fn hyperdriver::server::Server<A, NeedsProtocol, S, B, E>::with_protocol<P>(self, protocol: P) -> hyperdriver::server::Server<A, P, S, B, E>
impl<P, S, B, E> hyperdriver::server::Server<NeedsAcceptor, P, S, B, E>
pub fn hyperdriver::server::Server<NeedsAcceptor, P, S, B, E>::with_acceptor<A>(self, acceptor: A) -> hyperdriver::server::Server<A, P, S, B, E> where A: hyperdriver::server::Accept
pub async fn hyperdriver::server::Server<NeedsAcceptor, P, S, B, E>::with_bind(self, addr: &core::net::socket_addr::SocketAddr) -> core::result::Result<hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, P, S, B, E>, std::io::error::Error>
pub fn hyperdriver::server::Server<NeedsAcceptor, P, S, B, E>::with_incoming<I>(self, incoming: I) -> hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, P, S, B, E> where I: core::convert::Into<hyperdriver::server::conn::Acceptor> + core::convert::Into<hyperdriver::server::conn::AcceptorCore>
pub async fn hyperdriver::server::Server<NeedsAcceptor, P, S, B, E>::with_listener(self, listener: tokio::net::tcp::listener::TcpListener) -> hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, P, S, B, E>
impl<P, S, B, E> hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, P, S, B, E>
pub fn hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, P, S, B, E>::with_tls<C>(self, config: C) -> hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, P, S, B, E> where C: core::convert::Into<alloc::sync::Arc<rustls::server::server_conn::ServerConfig>>
impl<S, B> hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, hyperdriver::server::conn::auto::Builder<hyperdriver::bridge::rt::TokioExecutor>, S, B, hyperdriver::bridge::rt::TokioExecutor>
pub async fn hyperdriver::server::Server<hyperdriver::server::conn::Acceptor, hyperdriver::server::conn::auto::Builder<hyperdriver::bridge::rt::TokioExecutor>, S, B, hyperdriver::bridge::rt::TokioExecutor>::bind<A: tokio::net::addr::ToSocketAddrs>(addr: A, make_service: S) -> std::io::error::Result<Self>
impl<A, P, S, B, E> core::fmt::Debug for hyperdriver::server::Server<A, P, S, B, E>
pub fn hyperdriver::server::Server<A, P, S, B, E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<A, P, S, B, E> core::future::into_future::IntoFuture for hyperdriver::server::Server<A, P, S, B, E> where S: hyperdriver::service::MakeServiceRef<<A as hyperdriver::server::Accept>::Conn, B>, P: hyperdriver::server::Protocol<<S as hyperdriver::service::MakeServiceRef>::Service, <A as hyperdriver::server::Accept>::Conn, B>, A: hyperdriver::server::Accept + core::marker::Unpin, B: http_body::Body, E: hyperdriver::server::ServerExecutor<P, S, A, B>
pub type hyperdriver::server::Server<A, P, S, B, E>::IntoFuture = hyperdriver::server::Serving<A, P, S, B, E>
pub type hyperdriver::server::Server<A, P, S, B, E>::Output = core::result::Result<(), hyperdriver::server::ServerError>
pub fn hyperdriver::server::Server<A, P, S, B, E>::into_future(self) -> Self::IntoFuture
impl<A, P, S, B, E> core::marker::Freeze for hyperdriver::server::Server<A, P, S, B, E> where A: core::marker::Freeze, P: core::marker::Freeze, S: core::marker::Freeze, E: core::marker::Freeze
impl<A, P, S, B, E> core::marker::Send for hyperdriver::server::Server<A, P, S, B, E> where A: core::marker::Send, P: core::marker::Send, S: core::marker::Send, E: core::marker::Send
impl<A, P, S, B, E> core::marker::Sync for hyperdriver::server::Server<A, P, S, B, E> where A: core::marker::Sync, P: core::marker::Sync, S: core::marker::Sync, E: core::marker::Sync
impl<A, P, S, B, E> core::marker::Unpin for hyperdriver::server::Server<A, P, S, B, E> where A: core::marker::Unpin, P: core::marker::Unpin, S: core::marker::Unpin, E: core::marker::Unpin
impl<A, P, S, B, E> core::panic::unwind_safe::RefUnwindSafe for hyperdriver::server::Server<A, P, S, B, E> where A: core::panic::unwind_safe::RefUnwindSafe, P: core::panic::unwind_safe::RefUnwindSafe, S: core::panic::unwind_safe::RefUnwindSafe, E: core::panic::unwind_safe::RefUnwindSafe
impl<A, P, S, B, E> core::panic::unwind_safe::UnwindSafe for hyperdriver::server::Server<A, P, S, B, E> where A: core::panic::unwind_safe::UnwindSafe, P: core::panic::unwind_safe::UnwindSafe, S: core::panic::unwind_safe::UnwindSafe, E: core::panic::unwind_safe::UnwindSafe
impl<A, B, T> hyper_util::server::conn::auto::HttpServerConnExec<A, B> for hyperdriver::server::Server<A, P, S, B, E> where B: http_body::Body
impl<T, U> core::convert::Into<U> for hyperdriver::server::Server<A, P, S, B, E> where U: core::convert::From<T>
pub fn hyperdriver::server::Server<A, P, S, B, E>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for hyperdriver::server::Server<A, P, S, B, E> where U: core::convert::Into<T>
pub type hyperdriver::server::Server<A, P, S, B, E>::Error = core::convert::Infallible
pub fn hyperdriver::server::Server<A, P, S, B, E>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for hyperdriver::server::Server<A, P, S, B, E> where U: core::convert::TryFrom<T>
pub type hyperdriver::server::Server<A, P, S, B, E>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn hyperdriver::server::Server<A, P, S, B, E>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for hyperdriver::server::Server<A, P, S, B, E> where T: 'static + core::marker::Sized
pub fn hyperdriver::server::Server<A, P, S, B, E>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for hyperdriver::server::Server<A, P, S, B, E> where T: core::marker::Sized
pub fn hyperdriver::server::Server<A, P, S, B, E>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for hyperdriver::server::Server<A, P, S, B, E> where T: core::marker::Sized
pub fn hyperdriver::server::Server<A, P, S, B, E>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for hyperdriver::server::Server<A, P, S, B, E>
pub fn hyperdriver::server::Server<A, P, S, B, E>::from(t: T) -> T
impl<T> tower_http::follow_redirect::policy::PolicyExt for hyperdriver::server::Server<A, P, S, B, E> where T: core::marker::Sized
pub fn hyperdriver::server::Server<A, P, S, B, E>::and<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::and::And<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
pub fn hyperdriver::server::Server<A, P, S, B, E>::or<P, B, E>(self, other: P) -> tower_http::follow_redirect::policy::or::Or<T, P> where T: tower_http::follow_redirect::policy::Policy<B, E>, P: tower_http::follow_redirect::policy::Policy<B, E>
impl<T> tracing::instrument::Instrument for hyperdriver::server::Server<A, P, S, B, E>
impl<T> tracing::instrument::WithSubscriber for hyperdriver::server::Server<A, P, S, B, E>
