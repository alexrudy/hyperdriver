//! A server framework with connection management, automatic HTTP/1.1 and HTTP/2
//! switching, and pluggable acceptors, protocols, and services.
//!
//! # Overview
//! [`Server`] is the primary entry point for this module, and represents the components
//! which are ready to serve requests. It has a builder API for confiugration, [`Server::builder`]
//! and can be `await`-ed to start serving connections.
//!
//! When a new connection arrives, it is the acceptor's job to accept the connection and
//! provide a bi-directional stream of bytes. The server then uses the protocol to determine
//! how to handle that connection and serve requests. A service is used to handle individual
//! requests. The service is generated by the "MakeService" which is provided by the user.
//!
//! A "MakeService" is a service which creates services, aka a service factory. The service
//! factory will recieve a reference to the underlying connection stream.
//!
//! # Low Level Components
//! The [`conn`] module contains the low-level components that are used to build a server,
//! including the built in acceptors and protocols. These can be used to build custom servers
//! with different behavior, or to extend the built-in server with custom acceptors or protocols.
//!
//! # Example
//! ```rust
//! # use hyperdriver::Body;
//! # use hyperdriver::server::{ServerAcceptorExt, ServerProtocolExt};
//! # type BoxError = Box<dyn std::error::Error + Send + Sync + 'static>;
//!
//! async fn echo(req: http::Request<Body>) -> Result<http::Response<Body>, BoxError> {
//!     Ok(http::Response::new(req.into_body()))
//! }
//!
//! async fn example_server() {
//!     let (client, incoming) = hyperdriver::stream::duplex::pair();
//!
//!    let server = hyperdriver::server::Server::builder()
//!     .with_incoming(incoming)
//!     .with_http1()
//!     .with_shared_service(tower::service_fn(echo))
//!     .with_tokio();
//!
//!     server.await.unwrap();
//! }

mod builder;
pub mod conn;

pub use self::builder::{ServerAcceptorExt, ServerConnectionInfoExt, ServerProtocolExt};
pub use self::conn::auto::Builder as AutoBuilder;
pub use chateau::server::{Accept, Connection, Protocol};
pub use chateau::server::{GracefulShutdown, Server, ServerError, Serving};

#[cfg(test)]
mod tests {

    use std::{
        convert::Infallible,
        future::{ready, IntoFuture},
    };

    use super::{builder::ServerProtocolExt as _, *};
    use crate::Body;
    use chateau::stream::duplex;

    use chateau::services::make_service_fn;
    use tower::service_fn;

    #[allow(dead_code, unused_must_use)]
    fn compile() {
        let svc = make_service_fn(|_| {
            ready(Ok::<_, Infallible>(service_fn(|_: http::Request<Body>| {
                ready(Ok::<_, Infallible>(http::Response::new(crate::Body::from(
                    "hello",
                ))))
            })))
        });

        let (_, incoming) = duplex::pair();

        let server = Server::builder::<http::Request<Body>>()
            .with_acceptor(incoming)
            .with_make_service(svc)
            .with_auto_http()
            .with_request::<http::Request<crate::Body>>()
            .with_tokio();

        server.into_future();
    }
}
